/* soapC.cpp
   Generated by gSOAP 2.8.7 from ../../../src/gsoap/smartstreetlightService.h

Copyright(C) 2000-2011, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
1) GPL or 2) Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.7 2016-12-16 07:27:39 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_ns1__EVENTLOG_USCORETYPE_USCOREEnum:
		return soap_in_ns1__EVENTLOG_USCORETYPE_USCOREEnum(soap, NULL, NULL, "ns1:EVENTLOG_TYPE_Enum");
	case SOAP_TYPE_ns1__MESSAGE_USCORERESULT_USCOREEnum:
		return soap_in_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, NULL, NULL, "ns1:MESSAGE_RESULT_Enum");
	case SOAP_TYPE_ns1__SCHEDULE_USCOREINFO_USCOREType:
		return soap_in_ns1__SCHEDULE_USCOREINFO_USCOREType(soap, NULL, NULL, "ns1:SCHEDULE_INFO_Type");
	case SOAP_TYPE_ns1__LISTSCHEDULE_USCOREINFO_USCOREType:
		return soap_in_ns1__LISTSCHEDULE_USCOREINFO_USCOREType(soap, NULL, NULL, "ns1:LISTSCHEDULE_INFO_Type");
	case SOAP_TYPE_ns1__DAYSCHEDULE_USCOREINFO_USCOREType:
		return soap_in_ns1__DAYSCHEDULE_USCOREINFO_USCOREType(soap, NULL, NULL, "ns1:DAYSCHEDULE_INFO_Type");
	case SOAP_TYPE_ns1__PROGRAM_USCOREINFO_USCOREType:
		return soap_in_ns1__PROGRAM_USCOREINFO_USCOREType(soap, NULL, NULL, "ns1:PROGRAM_INFO_Type");
	case SOAP_TYPE_ns1__USER_USCOREINFO_USCOREType:
		return soap_in_ns1__USER_USCOREINFO_USCOREType(soap, NULL, NULL, "ns1:USER_INFO_Type");
	case SOAP_TYPE_ns1__ZONE_USCOREINFO_USCOREType:
		return soap_in_ns1__ZONE_USCOREINFO_USCOREType(soap, NULL, NULL, "ns1:ZONE_INFO_Type");
	case SOAP_TYPE_ns1__USER_USCORELOG_USCOREINFO_USCOREType:
		return soap_in_ns1__USER_USCORELOG_USCOREINFO_USCOREType(soap, NULL, NULL, "ns1:USER_LOG_INFO_Type");
	case SOAP_TYPE_ns1__EVENT_USCORELOG_USCOREINFO_USCOREType:
		return soap_in_ns1__EVENT_USCORELOG_USCOREINFO_USCOREType(soap, NULL, NULL, "ns1:EVENT_LOG_INFO_Type");
	case SOAP_TYPE_ns1__LINE_USCOREINFO_USCOREType:
		return soap_in_ns1__LINE_USCOREINFO_USCOREType(soap, NULL, NULL, "ns1:LINE_INFO_Type");
	case SOAP_TYPE_ns1__LCULOGINFOType:
		return soap_in_ns1__LCULOGINFOType(soap, NULL, NULL, "ns1:LCULOGINFOType");
	case SOAP_TYPE_ns1__LCU_USCOREINFO_USCOREType:
		return soap_in_ns1__LCU_USCOREINFO_USCOREType(soap, NULL, NULL, "ns1:LCU_INFO_Type");
	case SOAP_TYPE_ns1__DCU_USCOREINFO_USCOREType:
		return soap_in_ns1__DCU_USCOREINFO_USCOREType(soap, NULL, NULL, "ns1:DCU_INFO_Type");
	case SOAP_TYPE_ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType:
		return soap_in_ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, NULL, NULL, "ns1:CURR_LOGIN_INFO_Type");
	case SOAP_TYPE_PointerTo_ns1__getLcuLogOperationResponse:
		return soap_in_PointerTo_ns1__getLcuLogOperationResponse(soap, NULL, NULL, "ns1:getLcuLogOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__getLcuLogOperation:
		return soap_in_PointerTo_ns1__getLcuLogOperation(soap, NULL, NULL, "ns1:getLcuLogOperation");
	case SOAP_TYPE_PointerTo_ns1__removeScheduleOperationResponse:
		return soap_in_PointerTo_ns1__removeScheduleOperationResponse(soap, NULL, NULL, "ns1:removeScheduleOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__removeScheduleOperation:
		return soap_in_PointerTo_ns1__removeScheduleOperation(soap, NULL, NULL, "ns1:removeScheduleOperation");
	case SOAP_TYPE_PointerTo_ns1__editScheduleOperationResponse:
		return soap_in_PointerTo_ns1__editScheduleOperationResponse(soap, NULL, NULL, "ns1:editScheduleOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__editScheduleOperation:
		return soap_in_PointerTo_ns1__editScheduleOperation(soap, NULL, NULL, "ns1:editScheduleOperation");
	case SOAP_TYPE_PointerTo_ns1__addScheduleOperationResponse:
		return soap_in_PointerTo_ns1__addScheduleOperationResponse(soap, NULL, NULL, "ns1:addScheduleOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__addScheduleOperation:
		return soap_in_PointerTo_ns1__addScheduleOperation(soap, NULL, NULL, "ns1:addScheduleOperation");
	case SOAP_TYPE_PointerTo_ns1__getScheduleOperationResponse:
		return soap_in_PointerTo_ns1__getScheduleOperationResponse(soap, NULL, NULL, "ns1:getScheduleOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__getScheduleOperation:
		return soap_in_PointerTo_ns1__getScheduleOperation(soap, NULL, NULL, "ns1:getScheduleOperation");
	case SOAP_TYPE_PointerTo_ns1__removeListScheduleOperationResponse:
		return soap_in_PointerTo_ns1__removeListScheduleOperationResponse(soap, NULL, NULL, "ns1:removeListScheduleOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__removeListScheduleOperation:
		return soap_in_PointerTo_ns1__removeListScheduleOperation(soap, NULL, NULL, "ns1:removeListScheduleOperation");
	case SOAP_TYPE_PointerTo_ns1__editListScheduleOperationResponse:
		return soap_in_PointerTo_ns1__editListScheduleOperationResponse(soap, NULL, NULL, "ns1:editListScheduleOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__editListScheduleOperation:
		return soap_in_PointerTo_ns1__editListScheduleOperation(soap, NULL, NULL, "ns1:editListScheduleOperation");
	case SOAP_TYPE_PointerTo_ns1__addListScheduleOperationResponse:
		return soap_in_PointerTo_ns1__addListScheduleOperationResponse(soap, NULL, NULL, "ns1:addListScheduleOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__addListScheduleOperation:
		return soap_in_PointerTo_ns1__addListScheduleOperation(soap, NULL, NULL, "ns1:addListScheduleOperation");
	case SOAP_TYPE_PointerTo_ns1__getListScheduleOperationResponse:
		return soap_in_PointerTo_ns1__getListScheduleOperationResponse(soap, NULL, NULL, "ns1:getListScheduleOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__getListScheduleOperation:
		return soap_in_PointerTo_ns1__getListScheduleOperation(soap, NULL, NULL, "ns1:getListScheduleOperation");
	case SOAP_TYPE_PointerTo_ns1__addDayScheduleOperationResponse:
		return soap_in_PointerTo_ns1__addDayScheduleOperationResponse(soap, NULL, NULL, "ns1:addDayScheduleOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__addDayScheduleOperation:
		return soap_in_PointerTo_ns1__addDayScheduleOperation(soap, NULL, NULL, "ns1:addDayScheduleOperation");
	case SOAP_TYPE_PointerTo_ns1__removeDayScheduleOperationResponse:
		return soap_in_PointerTo_ns1__removeDayScheduleOperationResponse(soap, NULL, NULL, "ns1:removeDayScheduleOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__removeDayScheduleOperation:
		return soap_in_PointerTo_ns1__removeDayScheduleOperation(soap, NULL, NULL, "ns1:removeDayScheduleOperation");
	case SOAP_TYPE_PointerTo_ns1__editDayScheduleOperationResponse:
		return soap_in_PointerTo_ns1__editDayScheduleOperationResponse(soap, NULL, NULL, "ns1:editDayScheduleOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__editDayScheduleOperation:
		return soap_in_PointerTo_ns1__editDayScheduleOperation(soap, NULL, NULL, "ns1:editDayScheduleOperation");
	case SOAP_TYPE_PointerTo_ns1__getDayScheduleOperationResponse:
		return soap_in_PointerTo_ns1__getDayScheduleOperationResponse(soap, NULL, NULL, "ns1:getDayScheduleOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__getDayScheduleOperation:
		return soap_in_PointerTo_ns1__getDayScheduleOperation(soap, NULL, NULL, "ns1:getDayScheduleOperation");
	case SOAP_TYPE_PointerTo_ns1__editProgramOperationResponse:
		return soap_in_PointerTo_ns1__editProgramOperationResponse(soap, NULL, NULL, "ns1:editProgramOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__editProgramOperation:
		return soap_in_PointerTo_ns1__editProgramOperation(soap, NULL, NULL, "ns1:editProgramOperation");
	case SOAP_TYPE_PointerTo_ns1__getProgramOperationResponse:
		return soap_in_PointerTo_ns1__getProgramOperationResponse(soap, NULL, NULL, "ns1:getProgramOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__getProgramOperation:
		return soap_in_PointerTo_ns1__getProgramOperation(soap, NULL, NULL, "ns1:getProgramOperation");
	case SOAP_TYPE_PointerTo_ns1__editUserByUserOperationResponse:
		return soap_in_PointerTo_ns1__editUserByUserOperationResponse(soap, NULL, NULL, "ns1:editUserByUserOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__editUserByUserOperation:
		return soap_in_PointerTo_ns1__editUserByUserOperation(soap, NULL, NULL, "ns1:editUserByUserOperation");
	case SOAP_TYPE_PointerTo_ns1__removeUserOperationResponse:
		return soap_in_PointerTo_ns1__removeUserOperationResponse(soap, NULL, NULL, "ns1:removeUserOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__removeUserOperation:
		return soap_in_PointerTo_ns1__removeUserOperation(soap, NULL, NULL, "ns1:removeUserOperation");
	case SOAP_TYPE_PointerTo_ns1__editUserOperationResponse:
		return soap_in_PointerTo_ns1__editUserOperationResponse(soap, NULL, NULL, "ns1:editUserOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__editUserOperation:
		return soap_in_PointerTo_ns1__editUserOperation(soap, NULL, NULL, "ns1:editUserOperation");
	case SOAP_TYPE_PointerTo_ns1__addUserOperationResponse:
		return soap_in_PointerTo_ns1__addUserOperationResponse(soap, NULL, NULL, "ns1:addUserOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__addUserOperation:
		return soap_in_PointerTo_ns1__addUserOperation(soap, NULL, NULL, "ns1:addUserOperation");
	case SOAP_TYPE_PointerTo_ns1__getAllUserOperationResponse:
		return soap_in_PointerTo_ns1__getAllUserOperationResponse(soap, NULL, NULL, "ns1:getAllUserOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__getAllUserOperation:
		return soap_in_PointerTo_ns1__getAllUserOperation(soap, NULL, NULL, "ns1:getAllUserOperation");
	case SOAP_TYPE_PointerTo_ns1__removeZoneOperationResponse:
		return soap_in_PointerTo_ns1__removeZoneOperationResponse(soap, NULL, NULL, "ns1:removeZoneOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__removeZoneOperation:
		return soap_in_PointerTo_ns1__removeZoneOperation(soap, NULL, NULL, "ns1:removeZoneOperation");
	case SOAP_TYPE_PointerTo_ns1__editZoneOperationResponse:
		return soap_in_PointerTo_ns1__editZoneOperationResponse(soap, NULL, NULL, "ns1:editZoneOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__editZoneOperation:
		return soap_in_PointerTo_ns1__editZoneOperation(soap, NULL, NULL, "ns1:editZoneOperation");
	case SOAP_TYPE_PointerTo_ns1__addZoneOperationResponse:
		return soap_in_PointerTo_ns1__addZoneOperationResponse(soap, NULL, NULL, "ns1:addZoneOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__addZoneOperation:
		return soap_in_PointerTo_ns1__addZoneOperation(soap, NULL, NULL, "ns1:addZoneOperation");
	case SOAP_TYPE_PointerTo_ns1__SetDcuToZoneOperationResponse:
		return soap_in_PointerTo_ns1__SetDcuToZoneOperationResponse(soap, NULL, NULL, "ns1:SetDcuToZoneOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__SetDcuToZoneOperation:
		return soap_in_PointerTo_ns1__SetDcuToZoneOperation(soap, NULL, NULL, "ns1:SetDcuToZoneOperation");
	case SOAP_TYPE_PointerTo_ns1__getAllZoneForUserOperationResponse:
		return soap_in_PointerTo_ns1__getAllZoneForUserOperationResponse(soap, NULL, NULL, "ns1:getAllZoneForUserOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__getAllZoneForUserOperation:
		return soap_in_PointerTo_ns1__getAllZoneForUserOperation(soap, NULL, NULL, "ns1:getAllZoneForUserOperation");
	case SOAP_TYPE_PointerTo_ns1__getAllZoneOperationResponse:
		return soap_in_PointerTo_ns1__getAllZoneOperationResponse(soap, NULL, NULL, "ns1:getAllZoneOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__getAllZoneOperation:
		return soap_in_PointerTo_ns1__getAllZoneOperation(soap, NULL, NULL, "ns1:getAllZoneOperation");
	case SOAP_TYPE_PointerTo_ns1__deleteUserLogOperationResponse:
		return soap_in_PointerTo_ns1__deleteUserLogOperationResponse(soap, NULL, NULL, "ns1:deleteUserLogOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__deleteUserLogOperation:
		return soap_in_PointerTo_ns1__deleteUserLogOperation(soap, NULL, NULL, "ns1:deleteUserLogOperation");
	case SOAP_TYPE_PointerTo_ns1__getUserLogOperationResponse:
		return soap_in_PointerTo_ns1__getUserLogOperationResponse(soap, NULL, NULL, "ns1:getUserLogOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__getUserLogOperation:
		return soap_in_PointerTo_ns1__getUserLogOperation(soap, NULL, NULL, "ns1:getUserLogOperation");
	case SOAP_TYPE_PointerTo_ns1__deleteEventLogOperationResponse:
		return soap_in_PointerTo_ns1__deleteEventLogOperationResponse(soap, NULL, NULL, "ns1:deleteEventLogOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__deleteEventLogOperation:
		return soap_in_PointerTo_ns1__deleteEventLogOperation(soap, NULL, NULL, "ns1:deleteEventLogOperation");
	case SOAP_TYPE_PointerTo_ns1__updateReadEventLogOperationResponse:
		return soap_in_PointerTo_ns1__updateReadEventLogOperationResponse(soap, NULL, NULL, "ns1:updateReadEventLogOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__updateReadEventLogOperation:
		return soap_in_PointerTo_ns1__updateReadEventLogOperation(soap, NULL, NULL, "ns1:updateReadEventLogOperation");
	case SOAP_TYPE_PointerTo_ns1__getEventLogOperationResponse:
		return soap_in_PointerTo_ns1__getEventLogOperationResponse(soap, NULL, NULL, "ns1:getEventLogOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__getEventLogOperation:
		return soap_in_PointerTo_ns1__getEventLogOperation(soap, NULL, NULL, "ns1:getEventLogOperation");
	case SOAP_TYPE_PointerTo_ns1__setProgramDcuOperationResponse:
		return soap_in_PointerTo_ns1__setProgramDcuOperationResponse(soap, NULL, NULL, "ns1:setProgramDcuOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__setProgramDcuOperation:
		return soap_in_PointerTo_ns1__setProgramDcuOperation(soap, NULL, NULL, "ns1:setProgramDcuOperation");
	case SOAP_TYPE_PointerTo_ns1__controlLineOperationResponse:
		return soap_in_PointerTo_ns1__controlLineOperationResponse(soap, NULL, NULL, "ns1:controlLineOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__controlLineOperation:
		return soap_in_PointerTo_ns1__controlLineOperation(soap, NULL, NULL, "ns1:controlLineOperation");
	case SOAP_TYPE_PointerTo_ns1__controlLcuOperationResponse:
		return soap_in_PointerTo_ns1__controlLcuOperationResponse(soap, NULL, NULL, "ns1:controlLcuOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__controlLcuOperation:
		return soap_in_PointerTo_ns1__controlLcuOperation(soap, NULL, NULL, "ns1:controlLcuOperation");
	case SOAP_TYPE_PointerTo_ns1__removeProgramOperationResponse:
		return soap_in_PointerTo_ns1__removeProgramOperationResponse(soap, NULL, NULL, "ns1:removeProgramOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__removeProgramOperation:
		return soap_in_PointerTo_ns1__removeProgramOperation(soap, NULL, NULL, "ns1:removeProgramOperation");
	case SOAP_TYPE_PointerTo_ns1__addProgramOperationResponse:
		return soap_in_PointerTo_ns1__addProgramOperationResponse(soap, NULL, NULL, "ns1:addProgramOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__addProgramOperation:
		return soap_in_PointerTo_ns1__addProgramOperation(soap, NULL, NULL, "ns1:addProgramOperation");
	case SOAP_TYPE_PointerTo_ns1__editLineOperationResponse:
		return soap_in_PointerTo_ns1__editLineOperationResponse(soap, NULL, NULL, "ns1:editLineOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__editLineOperation:
		return soap_in_PointerTo_ns1__editLineOperation(soap, NULL, NULL, "ns1:editLineOperation");
	case SOAP_TYPE_PointerTo_ns1__removeLineOperationResponse:
		return soap_in_PointerTo_ns1__removeLineOperationResponse(soap, NULL, NULL, "ns1:removeLineOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__removeLineOperation:
		return soap_in_PointerTo_ns1__removeLineOperation(soap, NULL, NULL, "ns1:removeLineOperation");
	case SOAP_TYPE_PointerTo_ns1__addLineOperationResponse:
		return soap_in_PointerTo_ns1__addLineOperationResponse(soap, NULL, NULL, "ns1:addLineOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__addLineOperation:
		return soap_in_PointerTo_ns1__addLineOperation(soap, NULL, NULL, "ns1:addLineOperation");
	case SOAP_TYPE_PointerTo_ns1__editLcuOperationResponse:
		return soap_in_PointerTo_ns1__editLcuOperationResponse(soap, NULL, NULL, "ns1:editLcuOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__editLcuOperation:
		return soap_in_PointerTo_ns1__editLcuOperation(soap, NULL, NULL, "ns1:editLcuOperation");
	case SOAP_TYPE_PointerTo_ns1__removeLcuOperationResponse:
		return soap_in_PointerTo_ns1__removeLcuOperationResponse(soap, NULL, NULL, "ns1:removeLcuOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__removeLcuOperation:
		return soap_in_PointerTo_ns1__removeLcuOperation(soap, NULL, NULL, "ns1:removeLcuOperation");
	case SOAP_TYPE_PointerTo_ns1__addLcuOperationResponse:
		return soap_in_PointerTo_ns1__addLcuOperationResponse(soap, NULL, NULL, "ns1:addLcuOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__addLcuOperation:
		return soap_in_PointerTo_ns1__addLcuOperation(soap, NULL, NULL, "ns1:addLcuOperation");
	case SOAP_TYPE_PointerTo_ns1__editDcuOperationResponse:
		return soap_in_PointerTo_ns1__editDcuOperationResponse(soap, NULL, NULL, "ns1:editDcuOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__editDcuOperation:
		return soap_in_PointerTo_ns1__editDcuOperation(soap, NULL, NULL, "ns1:editDcuOperation");
	case SOAP_TYPE_PointerTo_ns1__removeDcuOperationResponse:
		return soap_in_PointerTo_ns1__removeDcuOperationResponse(soap, NULL, NULL, "ns1:removeDcuOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__removeDcuOperation:
		return soap_in_PointerTo_ns1__removeDcuOperation(soap, NULL, NULL, "ns1:removeDcuOperation");
	case SOAP_TYPE_PointerTo_ns1__addDcuOperationResponse:
		return soap_in_PointerTo_ns1__addDcuOperationResponse(soap, NULL, NULL, "ns1:addDcuOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__addDcuOperation:
		return soap_in_PointerTo_ns1__addDcuOperation(soap, NULL, NULL, "ns1:addDcuOperation");
	case SOAP_TYPE_PointerTo_ns1__getLineListOperationResponse:
		return soap_in_PointerTo_ns1__getLineListOperationResponse(soap, NULL, NULL, "ns1:getLineListOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__getLineListOperation:
		return soap_in_PointerTo_ns1__getLineListOperation(soap, NULL, NULL, "ns1:getLineListOperation");
	case SOAP_TYPE_PointerTo_ns1__updateRuntimeForUserOperationResponse:
		return soap_in_PointerTo_ns1__updateRuntimeForUserOperationResponse(soap, NULL, NULL, "ns1:updateRuntimeForUserOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__updateRuntimeForUserOperation:
		return soap_in_PointerTo_ns1__updateRuntimeForUserOperation(soap, NULL, NULL, "ns1:updateRuntimeForUserOperation");
	case SOAP_TYPE_PointerTo_ns1__getLcuListOperationResponse:
		return soap_in_PointerTo_ns1__getLcuListOperationResponse(soap, NULL, NULL, "ns1:getLcuListOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__getLcuListOperation:
		return soap_in_PointerTo_ns1__getLcuListOperation(soap, NULL, NULL, "ns1:getLcuListOperation");
	case SOAP_TYPE_PointerTo_ns1__getDcuListOperationResponse:
		return soap_in_PointerTo_ns1__getDcuListOperationResponse(soap, NULL, NULL, "ns1:getDcuListOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__getDcuListOperation:
		return soap_in_PointerTo_ns1__getDcuListOperation(soap, NULL, NULL, "ns1:getDcuListOperation");
	case SOAP_TYPE_PointerTo_ns1__LogoutOperationResponse:
		return soap_in_PointerTo_ns1__LogoutOperationResponse(soap, NULL, NULL, "ns1:LogoutOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__LogoutOperation:
		return soap_in_PointerTo_ns1__LogoutOperation(soap, NULL, NULL, "ns1:LogoutOperation");
	case SOAP_TYPE_PointerTo_ns1__LoginPcOperationResponse:
		return soap_in_PointerTo_ns1__LoginPcOperationResponse(soap, NULL, NULL, "ns1:LoginPcOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__LoginPcOperation:
		return soap_in_PointerTo_ns1__LoginPcOperation(soap, NULL, NULL, "ns1:LoginPcOperation");
	case SOAP_TYPE_PointerTo_ns1__LoginOperationResponse:
		return soap_in_PointerTo_ns1__LoginOperationResponse(soap, NULL, NULL, "ns1:LoginOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__LoginOperation:
		return soap_in_PointerTo_ns1__LoginOperation(soap, NULL, NULL, "ns1:LoginOperation");
	case SOAP_TYPE_PointerToPointerTons1__LCULOGINFOType:
		return soap_in_PointerToPointerTons1__LCULOGINFOType(soap, NULL, NULL, "ns1:LCULOGINFOType");
	case SOAP_TYPE_PointerTons1__LCULOGINFOType:
		return soap_in_PointerTons1__LCULOGINFOType(soap, NULL, NULL, "ns1:LCULOGINFOType");
	case SOAP_TYPE_PointerToPointerTons1__LISTSCHEDULE_USCOREINFO_USCOREType:
		return soap_in_PointerToPointerTons1__LISTSCHEDULE_USCOREINFO_USCOREType(soap, NULL, NULL, "ns1:LISTSCHEDULE_INFO_Type");
	case SOAP_TYPE_PointerTons1__LISTSCHEDULE_USCOREINFO_USCOREType:
		return soap_in_PointerTons1__LISTSCHEDULE_USCOREINFO_USCOREType(soap, NULL, NULL, "ns1:LISTSCHEDULE_INFO_Type");
	case SOAP_TYPE_PointerToPointerTons1__DAYSCHEDULE_USCOREINFO_USCOREType:
		return soap_in_PointerToPointerTons1__DAYSCHEDULE_USCOREINFO_USCOREType(soap, NULL, NULL, "ns1:DAYSCHEDULE_INFO_Type");
	case SOAP_TYPE_PointerTons1__DAYSCHEDULE_USCOREINFO_USCOREType:
		return soap_in_PointerTons1__DAYSCHEDULE_USCOREINFO_USCOREType(soap, NULL, NULL, "ns1:DAYSCHEDULE_INFO_Type");
	case SOAP_TYPE_PointerToPointerTons1__PROGRAM_USCOREINFO_USCOREType:
		return soap_in_PointerToPointerTons1__PROGRAM_USCOREINFO_USCOREType(soap, NULL, NULL, "ns1:PROGRAM_INFO_Type");
	case SOAP_TYPE_PointerTons1__PROGRAM_USCOREINFO_USCOREType:
		return soap_in_PointerTons1__PROGRAM_USCOREINFO_USCOREType(soap, NULL, NULL, "ns1:PROGRAM_INFO_Type");
	case SOAP_TYPE_PointerToPointerTons1__USER_USCOREINFO_USCOREType:
		return soap_in_PointerToPointerTons1__USER_USCOREINFO_USCOREType(soap, NULL, NULL, "ns1:USER_INFO_Type");
	case SOAP_TYPE_PointerToPointerTons1__USER_USCORELOG_USCOREINFO_USCOREType:
		return soap_in_PointerToPointerTons1__USER_USCORELOG_USCOREINFO_USCOREType(soap, NULL, NULL, "ns1:USER_LOG_INFO_Type");
	case SOAP_TYPE_PointerTons1__USER_USCORELOG_USCOREINFO_USCOREType:
		return soap_in_PointerTons1__USER_USCORELOG_USCOREINFO_USCOREType(soap, NULL, NULL, "ns1:USER_LOG_INFO_Type");
	case SOAP_TYPE_PointerToPointerTons1__LINE_USCOREINFO_USCOREType:
		return soap_in_PointerToPointerTons1__LINE_USCOREINFO_USCOREType(soap, NULL, NULL, "ns1:LINE_INFO_Type");
	case SOAP_TYPE_PointerTons1__LINE_USCOREINFO_USCOREType:
		return soap_in_PointerTons1__LINE_USCOREINFO_USCOREType(soap, NULL, NULL, "ns1:LINE_INFO_Type");
	case SOAP_TYPE_PointerToPointerTons1__EVENT_USCORELOG_USCOREINFO_USCOREType:
		return soap_in_PointerToPointerTons1__EVENT_USCORELOG_USCOREINFO_USCOREType(soap, NULL, NULL, "ns1:EVENT_LOG_INFO_Type");
	case SOAP_TYPE_PointerTons1__EVENT_USCORELOG_USCOREINFO_USCOREType:
		return soap_in_PointerTons1__EVENT_USCORELOG_USCOREINFO_USCOREType(soap, NULL, NULL, "ns1:EVENT_LOG_INFO_Type");
	case SOAP_TYPE_PointerToPointerTons1__LCU_USCOREINFO_USCOREType:
		return soap_in_PointerToPointerTons1__LCU_USCOREINFO_USCOREType(soap, NULL, NULL, "ns1:LCU_INFO_Type");
	case SOAP_TYPE_PointerTons1__LCU_USCOREINFO_USCOREType:
		return soap_in_PointerTons1__LCU_USCOREINFO_USCOREType(soap, NULL, NULL, "ns1:LCU_INFO_Type");
	case SOAP_TYPE_PointerToPointerTons1__DCU_USCOREINFO_USCOREType:
		return soap_in_PointerToPointerTons1__DCU_USCOREINFO_USCOREType(soap, NULL, NULL, "ns1:DCU_INFO_Type");
	case SOAP_TYPE_PointerTons1__DCU_USCOREINFO_USCOREType:
		return soap_in_PointerTons1__DCU_USCOREINFO_USCOREType(soap, NULL, NULL, "ns1:DCU_INFO_Type");
	case SOAP_TYPE_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType:
		return soap_in_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, NULL, NULL, "ns1:CURR_LOGIN_INFO_Type");
	case SOAP_TYPE_PointerTons1__USER_USCOREINFO_USCOREType:
		return soap_in_PointerTons1__USER_USCOREINFO_USCOREType(soap, NULL, NULL, "ns1:USER_INFO_Type");
	case SOAP_TYPE_PointerToPointerTons1__SCHEDULE_USCOREINFO_USCOREType:
		return soap_in_PointerToPointerTons1__SCHEDULE_USCOREINFO_USCOREType(soap, NULL, NULL, "ns1:SCHEDULE_INFO_Type");
	case SOAP_TYPE_PointerTons1__SCHEDULE_USCOREINFO_USCOREType:
		return soap_in_PointerTons1__SCHEDULE_USCOREINFO_USCOREType(soap, NULL, NULL, "ns1:SCHEDULE_INFO_Type");
	case SOAP_TYPE_PointerToPointerTons1__ZONE_USCOREINFO_USCOREType:
		return soap_in_PointerToPointerTons1__ZONE_USCOREINFO_USCOREType(soap, NULL, NULL, "ns1:ZONE_INFO_Type");
	case SOAP_TYPE_PointerTons1__ZONE_USCOREINFO_USCOREType:
		return soap_in_PointerTons1__ZONE_USCOREINFO_USCOREType(soap, NULL, NULL, "ns1:ZONE_INFO_Type");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:SCHEDULE_INFO_Type"))
		{	*type = SOAP_TYPE_ns1__SCHEDULE_USCOREINFO_USCOREType;
			return soap_in_ns1__SCHEDULE_USCOREINFO_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LISTSCHEDULE_INFO_Type"))
		{	*type = SOAP_TYPE_ns1__LISTSCHEDULE_USCOREINFO_USCOREType;
			return soap_in_ns1__LISTSCHEDULE_USCOREINFO_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DAYSCHEDULE_INFO_Type"))
		{	*type = SOAP_TYPE_ns1__DAYSCHEDULE_USCOREINFO_USCOREType;
			return soap_in_ns1__DAYSCHEDULE_USCOREINFO_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PROGRAM_INFO_Type"))
		{	*type = SOAP_TYPE_ns1__PROGRAM_USCOREINFO_USCOREType;
			return soap_in_ns1__PROGRAM_USCOREINFO_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:USER_INFO_Type"))
		{	*type = SOAP_TYPE_ns1__USER_USCOREINFO_USCOREType;
			return soap_in_ns1__USER_USCOREINFO_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ZONE_INFO_Type"))
		{	*type = SOAP_TYPE_ns1__ZONE_USCOREINFO_USCOREType;
			return soap_in_ns1__ZONE_USCOREINFO_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:USER_LOG_INFO_Type"))
		{	*type = SOAP_TYPE_ns1__USER_USCORELOG_USCOREINFO_USCOREType;
			return soap_in_ns1__USER_USCORELOG_USCOREINFO_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:EVENT_LOG_INFO_Type"))
		{	*type = SOAP_TYPE_ns1__EVENT_USCORELOG_USCOREINFO_USCOREType;
			return soap_in_ns1__EVENT_USCORELOG_USCOREINFO_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LINE_INFO_Type"))
		{	*type = SOAP_TYPE_ns1__LINE_USCOREINFO_USCOREType;
			return soap_in_ns1__LINE_USCOREINFO_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LCULOGINFOType"))
		{	*type = SOAP_TYPE_ns1__LCULOGINFOType;
			return soap_in_ns1__LCULOGINFOType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LCU_INFO_Type"))
		{	*type = SOAP_TYPE_ns1__LCU_USCOREINFO_USCOREType;
			return soap_in_ns1__LCU_USCOREINFO_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DCU_INFO_Type"))
		{	*type = SOAP_TYPE_ns1__DCU_USCOREINFO_USCOREType;
			return soap_in_ns1__DCU_USCOREINFO_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CURR_LOGIN_INFO_Type"))
		{	*type = SOAP_TYPE_ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType;
			return soap_in_ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:EVENTLOG_TYPE_Enum"))
		{	*type = SOAP_TYPE_ns1__EVENTLOG_USCORETYPE_USCOREEnum;
			return soap_in_ns1__EVENTLOG_USCORETYPE_USCOREEnum(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MESSAGE_RESULT_Enum"))
		{	*type = SOAP_TYPE_ns1__MESSAGE_USCORERESULT_USCOREEnum;
			return soap_in_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:getLcuLogOperationResponse"))
		{	*type = SOAP_TYPE__ns1__getLcuLogOperationResponse;
			return soap_in__ns1__getLcuLogOperationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getLcuLogOperation"))
		{	*type = SOAP_TYPE__ns1__getLcuLogOperation;
			return soap_in__ns1__getLcuLogOperation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeScheduleOperationResponse"))
		{	*type = SOAP_TYPE__ns1__removeScheduleOperationResponse;
			return soap_in__ns1__removeScheduleOperationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeScheduleOperation"))
		{	*type = SOAP_TYPE__ns1__removeScheduleOperation;
			return soap_in__ns1__removeScheduleOperation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editScheduleOperationResponse"))
		{	*type = SOAP_TYPE__ns1__editScheduleOperationResponse;
			return soap_in__ns1__editScheduleOperationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editScheduleOperation"))
		{	*type = SOAP_TYPE__ns1__editScheduleOperation;
			return soap_in__ns1__editScheduleOperation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addScheduleOperationResponse"))
		{	*type = SOAP_TYPE__ns1__addScheduleOperationResponse;
			return soap_in__ns1__addScheduleOperationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addScheduleOperation"))
		{	*type = SOAP_TYPE__ns1__addScheduleOperation;
			return soap_in__ns1__addScheduleOperation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getScheduleOperationResponse"))
		{	*type = SOAP_TYPE__ns1__getScheduleOperationResponse;
			return soap_in__ns1__getScheduleOperationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getScheduleOperation"))
		{	*type = SOAP_TYPE__ns1__getScheduleOperation;
			return soap_in__ns1__getScheduleOperation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeListScheduleOperationResponse"))
		{	*type = SOAP_TYPE__ns1__removeListScheduleOperationResponse;
			return soap_in__ns1__removeListScheduleOperationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeListScheduleOperation"))
		{	*type = SOAP_TYPE__ns1__removeListScheduleOperation;
			return soap_in__ns1__removeListScheduleOperation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editListScheduleOperationResponse"))
		{	*type = SOAP_TYPE__ns1__editListScheduleOperationResponse;
			return soap_in__ns1__editListScheduleOperationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editListScheduleOperation"))
		{	*type = SOAP_TYPE__ns1__editListScheduleOperation;
			return soap_in__ns1__editListScheduleOperation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addListScheduleOperationResponse"))
		{	*type = SOAP_TYPE__ns1__addListScheduleOperationResponse;
			return soap_in__ns1__addListScheduleOperationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addListScheduleOperation"))
		{	*type = SOAP_TYPE__ns1__addListScheduleOperation;
			return soap_in__ns1__addListScheduleOperation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getListScheduleOperationResponse"))
		{	*type = SOAP_TYPE__ns1__getListScheduleOperationResponse;
			return soap_in__ns1__getListScheduleOperationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getListScheduleOperation"))
		{	*type = SOAP_TYPE__ns1__getListScheduleOperation;
			return soap_in__ns1__getListScheduleOperation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addDayScheduleOperationResponse"))
		{	*type = SOAP_TYPE__ns1__addDayScheduleOperationResponse;
			return soap_in__ns1__addDayScheduleOperationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addDayScheduleOperation"))
		{	*type = SOAP_TYPE__ns1__addDayScheduleOperation;
			return soap_in__ns1__addDayScheduleOperation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeDayScheduleOperationResponse"))
		{	*type = SOAP_TYPE__ns1__removeDayScheduleOperationResponse;
			return soap_in__ns1__removeDayScheduleOperationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeDayScheduleOperation"))
		{	*type = SOAP_TYPE__ns1__removeDayScheduleOperation;
			return soap_in__ns1__removeDayScheduleOperation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editDayScheduleOperationResponse"))
		{	*type = SOAP_TYPE__ns1__editDayScheduleOperationResponse;
			return soap_in__ns1__editDayScheduleOperationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editDayScheduleOperation"))
		{	*type = SOAP_TYPE__ns1__editDayScheduleOperation;
			return soap_in__ns1__editDayScheduleOperation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDayScheduleOperationResponse"))
		{	*type = SOAP_TYPE__ns1__getDayScheduleOperationResponse;
			return soap_in__ns1__getDayScheduleOperationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDayScheduleOperation"))
		{	*type = SOAP_TYPE__ns1__getDayScheduleOperation;
			return soap_in__ns1__getDayScheduleOperation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editProgramOperationResponse"))
		{	*type = SOAP_TYPE__ns1__editProgramOperationResponse;
			return soap_in__ns1__editProgramOperationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editProgramOperation"))
		{	*type = SOAP_TYPE__ns1__editProgramOperation;
			return soap_in__ns1__editProgramOperation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getProgramOperationResponse"))
		{	*type = SOAP_TYPE__ns1__getProgramOperationResponse;
			return soap_in__ns1__getProgramOperationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getProgramOperation"))
		{	*type = SOAP_TYPE__ns1__getProgramOperation;
			return soap_in__ns1__getProgramOperation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editUserByUserOperationResponse"))
		{	*type = SOAP_TYPE__ns1__editUserByUserOperationResponse;
			return soap_in__ns1__editUserByUserOperationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editUserByUserOperation"))
		{	*type = SOAP_TYPE__ns1__editUserByUserOperation;
			return soap_in__ns1__editUserByUserOperation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeUserOperationResponse"))
		{	*type = SOAP_TYPE__ns1__removeUserOperationResponse;
			return soap_in__ns1__removeUserOperationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeUserOperation"))
		{	*type = SOAP_TYPE__ns1__removeUserOperation;
			return soap_in__ns1__removeUserOperation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editUserOperationResponse"))
		{	*type = SOAP_TYPE__ns1__editUserOperationResponse;
			return soap_in__ns1__editUserOperationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editUserOperation"))
		{	*type = SOAP_TYPE__ns1__editUserOperation;
			return soap_in__ns1__editUserOperation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addUserOperationResponse"))
		{	*type = SOAP_TYPE__ns1__addUserOperationResponse;
			return soap_in__ns1__addUserOperationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addUserOperation"))
		{	*type = SOAP_TYPE__ns1__addUserOperation;
			return soap_in__ns1__addUserOperation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAllUserOperationResponse"))
		{	*type = SOAP_TYPE__ns1__getAllUserOperationResponse;
			return soap_in__ns1__getAllUserOperationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAllUserOperation"))
		{	*type = SOAP_TYPE__ns1__getAllUserOperation;
			return soap_in__ns1__getAllUserOperation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeZoneOperationResponse"))
		{	*type = SOAP_TYPE__ns1__removeZoneOperationResponse;
			return soap_in__ns1__removeZoneOperationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeZoneOperation"))
		{	*type = SOAP_TYPE__ns1__removeZoneOperation;
			return soap_in__ns1__removeZoneOperation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editZoneOperationResponse"))
		{	*type = SOAP_TYPE__ns1__editZoneOperationResponse;
			return soap_in__ns1__editZoneOperationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editZoneOperation"))
		{	*type = SOAP_TYPE__ns1__editZoneOperation;
			return soap_in__ns1__editZoneOperation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addZoneOperationResponse"))
		{	*type = SOAP_TYPE__ns1__addZoneOperationResponse;
			return soap_in__ns1__addZoneOperationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addZoneOperation"))
		{	*type = SOAP_TYPE__ns1__addZoneOperation;
			return soap_in__ns1__addZoneOperation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetDcuToZoneOperationResponse"))
		{	*type = SOAP_TYPE__ns1__SetDcuToZoneOperationResponse;
			return soap_in__ns1__SetDcuToZoneOperationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetDcuToZoneOperation"))
		{	*type = SOAP_TYPE__ns1__SetDcuToZoneOperation;
			return soap_in__ns1__SetDcuToZoneOperation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAllZoneForUserOperationResponse"))
		{	*type = SOAP_TYPE__ns1__getAllZoneForUserOperationResponse;
			return soap_in__ns1__getAllZoneForUserOperationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAllZoneForUserOperation"))
		{	*type = SOAP_TYPE__ns1__getAllZoneForUserOperation;
			return soap_in__ns1__getAllZoneForUserOperation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAllZoneOperationResponse"))
		{	*type = SOAP_TYPE__ns1__getAllZoneOperationResponse;
			return soap_in__ns1__getAllZoneOperationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAllZoneOperation"))
		{	*type = SOAP_TYPE__ns1__getAllZoneOperation;
			return soap_in__ns1__getAllZoneOperation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteUserLogOperationResponse"))
		{	*type = SOAP_TYPE__ns1__deleteUserLogOperationResponse;
			return soap_in__ns1__deleteUserLogOperationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteUserLogOperation"))
		{	*type = SOAP_TYPE__ns1__deleteUserLogOperation;
			return soap_in__ns1__deleteUserLogOperation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getUserLogOperationResponse"))
		{	*type = SOAP_TYPE__ns1__getUserLogOperationResponse;
			return soap_in__ns1__getUserLogOperationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getUserLogOperation"))
		{	*type = SOAP_TYPE__ns1__getUserLogOperation;
			return soap_in__ns1__getUserLogOperation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteEventLogOperationResponse"))
		{	*type = SOAP_TYPE__ns1__deleteEventLogOperationResponse;
			return soap_in__ns1__deleteEventLogOperationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteEventLogOperation"))
		{	*type = SOAP_TYPE__ns1__deleteEventLogOperation;
			return soap_in__ns1__deleteEventLogOperation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:updateReadEventLogOperationResponse"))
		{	*type = SOAP_TYPE__ns1__updateReadEventLogOperationResponse;
			return soap_in__ns1__updateReadEventLogOperationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:updateReadEventLogOperation"))
		{	*type = SOAP_TYPE__ns1__updateReadEventLogOperation;
			return soap_in__ns1__updateReadEventLogOperation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getEventLogOperationResponse"))
		{	*type = SOAP_TYPE__ns1__getEventLogOperationResponse;
			return soap_in__ns1__getEventLogOperationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getEventLogOperation"))
		{	*type = SOAP_TYPE__ns1__getEventLogOperation;
			return soap_in__ns1__getEventLogOperation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setProgramDcuOperationResponse"))
		{	*type = SOAP_TYPE__ns1__setProgramDcuOperationResponse;
			return soap_in__ns1__setProgramDcuOperationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setProgramDcuOperation"))
		{	*type = SOAP_TYPE__ns1__setProgramDcuOperation;
			return soap_in__ns1__setProgramDcuOperation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:controlLineOperationResponse"))
		{	*type = SOAP_TYPE__ns1__controlLineOperationResponse;
			return soap_in__ns1__controlLineOperationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:controlLineOperation"))
		{	*type = SOAP_TYPE__ns1__controlLineOperation;
			return soap_in__ns1__controlLineOperation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:controlLcuOperationResponse"))
		{	*type = SOAP_TYPE__ns1__controlLcuOperationResponse;
			return soap_in__ns1__controlLcuOperationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:controlLcuOperation"))
		{	*type = SOAP_TYPE__ns1__controlLcuOperation;
			return soap_in__ns1__controlLcuOperation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeProgramOperationResponse"))
		{	*type = SOAP_TYPE__ns1__removeProgramOperationResponse;
			return soap_in__ns1__removeProgramOperationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeProgramOperation"))
		{	*type = SOAP_TYPE__ns1__removeProgramOperation;
			return soap_in__ns1__removeProgramOperation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addProgramOperationResponse"))
		{	*type = SOAP_TYPE__ns1__addProgramOperationResponse;
			return soap_in__ns1__addProgramOperationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addProgramOperation"))
		{	*type = SOAP_TYPE__ns1__addProgramOperation;
			return soap_in__ns1__addProgramOperation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editLineOperationResponse"))
		{	*type = SOAP_TYPE__ns1__editLineOperationResponse;
			return soap_in__ns1__editLineOperationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editLineOperation"))
		{	*type = SOAP_TYPE__ns1__editLineOperation;
			return soap_in__ns1__editLineOperation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeLineOperationResponse"))
		{	*type = SOAP_TYPE__ns1__removeLineOperationResponse;
			return soap_in__ns1__removeLineOperationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeLineOperation"))
		{	*type = SOAP_TYPE__ns1__removeLineOperation;
			return soap_in__ns1__removeLineOperation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addLineOperationResponse"))
		{	*type = SOAP_TYPE__ns1__addLineOperationResponse;
			return soap_in__ns1__addLineOperationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addLineOperation"))
		{	*type = SOAP_TYPE__ns1__addLineOperation;
			return soap_in__ns1__addLineOperation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editLcuOperationResponse"))
		{	*type = SOAP_TYPE__ns1__editLcuOperationResponse;
			return soap_in__ns1__editLcuOperationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editLcuOperation"))
		{	*type = SOAP_TYPE__ns1__editLcuOperation;
			return soap_in__ns1__editLcuOperation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeLcuOperationResponse"))
		{	*type = SOAP_TYPE__ns1__removeLcuOperationResponse;
			return soap_in__ns1__removeLcuOperationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeLcuOperation"))
		{	*type = SOAP_TYPE__ns1__removeLcuOperation;
			return soap_in__ns1__removeLcuOperation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addLcuOperationResponse"))
		{	*type = SOAP_TYPE__ns1__addLcuOperationResponse;
			return soap_in__ns1__addLcuOperationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addLcuOperation"))
		{	*type = SOAP_TYPE__ns1__addLcuOperation;
			return soap_in__ns1__addLcuOperation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editDcuOperationResponse"))
		{	*type = SOAP_TYPE__ns1__editDcuOperationResponse;
			return soap_in__ns1__editDcuOperationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editDcuOperation"))
		{	*type = SOAP_TYPE__ns1__editDcuOperation;
			return soap_in__ns1__editDcuOperation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeDcuOperationResponse"))
		{	*type = SOAP_TYPE__ns1__removeDcuOperationResponse;
			return soap_in__ns1__removeDcuOperationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeDcuOperation"))
		{	*type = SOAP_TYPE__ns1__removeDcuOperation;
			return soap_in__ns1__removeDcuOperation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addDcuOperationResponse"))
		{	*type = SOAP_TYPE__ns1__addDcuOperationResponse;
			return soap_in__ns1__addDcuOperationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addDcuOperation"))
		{	*type = SOAP_TYPE__ns1__addDcuOperation;
			return soap_in__ns1__addDcuOperation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getLineListOperationResponse"))
		{	*type = SOAP_TYPE__ns1__getLineListOperationResponse;
			return soap_in__ns1__getLineListOperationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getLineListOperation"))
		{	*type = SOAP_TYPE__ns1__getLineListOperation;
			return soap_in__ns1__getLineListOperation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:updateRuntimeForUserOperationResponse"))
		{	*type = SOAP_TYPE__ns1__updateRuntimeForUserOperationResponse;
			return soap_in__ns1__updateRuntimeForUserOperationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:updateRuntimeForUserOperation"))
		{	*type = SOAP_TYPE__ns1__updateRuntimeForUserOperation;
			return soap_in__ns1__updateRuntimeForUserOperation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getLcuListOperationResponse"))
		{	*type = SOAP_TYPE__ns1__getLcuListOperationResponse;
			return soap_in__ns1__getLcuListOperationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getLcuListOperation"))
		{	*type = SOAP_TYPE__ns1__getLcuListOperation;
			return soap_in__ns1__getLcuListOperation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDcuListOperationResponse"))
		{	*type = SOAP_TYPE__ns1__getDcuListOperationResponse;
			return soap_in__ns1__getDcuListOperationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDcuListOperation"))
		{	*type = SOAP_TYPE__ns1__getDcuListOperation;
			return soap_in__ns1__getDcuListOperation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LogoutOperationResponse"))
		{	*type = SOAP_TYPE__ns1__LogoutOperationResponse;
			return soap_in__ns1__LogoutOperationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LogoutOperation"))
		{	*type = SOAP_TYPE__ns1__LogoutOperation;
			return soap_in__ns1__LogoutOperation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LoginPcOperationResponse"))
		{	*type = SOAP_TYPE__ns1__LoginPcOperationResponse;
			return soap_in__ns1__LoginPcOperationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LoginPcOperation"))
		{	*type = SOAP_TYPE__ns1__LoginPcOperation;
			return soap_in__ns1__LoginPcOperation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LoginOperationResponse"))
		{	*type = SOAP_TYPE__ns1__LoginOperationResponse;
			return soap_in__ns1__LoginOperationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LoginOperation"))
		{	*type = SOAP_TYPE__ns1__LoginOperation;
			return soap_in__ns1__LoginOperation(soap, NULL, NULL, NULL);
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_ns1__EVENTLOG_USCORETYPE_USCOREEnum:
		return soap_out_ns1__EVENTLOG_USCORETYPE_USCOREEnum(soap, tag, id, (const enum ns1__EVENTLOG_USCORETYPE_USCOREEnum *)ptr, "ns1:EVENTLOG_TYPE_Enum");
	case SOAP_TYPE_ns1__MESSAGE_USCORERESULT_USCOREEnum:
		return soap_out_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, tag, id, (const enum ns1__MESSAGE_USCORERESULT_USCOREEnum *)ptr, "ns1:MESSAGE_RESULT_Enum");
	case SOAP_TYPE__ns1__getLcuLogOperationResponse:
		return ((_ns1__getLcuLogOperationResponse *)ptr)->soap_out(soap, "ns1:getLcuLogOperationResponse", id, NULL);
	case SOAP_TYPE__ns1__getLcuLogOperation:
		return ((_ns1__getLcuLogOperation *)ptr)->soap_out(soap, "ns1:getLcuLogOperation", id, NULL);
	case SOAP_TYPE__ns1__removeScheduleOperationResponse:
		return ((_ns1__removeScheduleOperationResponse *)ptr)->soap_out(soap, "ns1:removeScheduleOperationResponse", id, NULL);
	case SOAP_TYPE__ns1__removeScheduleOperation:
		return ((_ns1__removeScheduleOperation *)ptr)->soap_out(soap, "ns1:removeScheduleOperation", id, NULL);
	case SOAP_TYPE__ns1__editScheduleOperationResponse:
		return ((_ns1__editScheduleOperationResponse *)ptr)->soap_out(soap, "ns1:editScheduleOperationResponse", id, NULL);
	case SOAP_TYPE__ns1__editScheduleOperation:
		return ((_ns1__editScheduleOperation *)ptr)->soap_out(soap, "ns1:editScheduleOperation", id, NULL);
	case SOAP_TYPE__ns1__addScheduleOperationResponse:
		return ((_ns1__addScheduleOperationResponse *)ptr)->soap_out(soap, "ns1:addScheduleOperationResponse", id, NULL);
	case SOAP_TYPE__ns1__addScheduleOperation:
		return ((_ns1__addScheduleOperation *)ptr)->soap_out(soap, "ns1:addScheduleOperation", id, NULL);
	case SOAP_TYPE__ns1__getScheduleOperationResponse:
		return ((_ns1__getScheduleOperationResponse *)ptr)->soap_out(soap, "ns1:getScheduleOperationResponse", id, NULL);
	case SOAP_TYPE__ns1__getScheduleOperation:
		return ((_ns1__getScheduleOperation *)ptr)->soap_out(soap, "ns1:getScheduleOperation", id, NULL);
	case SOAP_TYPE__ns1__removeListScheduleOperationResponse:
		return ((_ns1__removeListScheduleOperationResponse *)ptr)->soap_out(soap, "ns1:removeListScheduleOperationResponse", id, NULL);
	case SOAP_TYPE__ns1__removeListScheduleOperation:
		return ((_ns1__removeListScheduleOperation *)ptr)->soap_out(soap, "ns1:removeListScheduleOperation", id, NULL);
	case SOAP_TYPE__ns1__editListScheduleOperationResponse:
		return ((_ns1__editListScheduleOperationResponse *)ptr)->soap_out(soap, "ns1:editListScheduleOperationResponse", id, NULL);
	case SOAP_TYPE__ns1__editListScheduleOperation:
		return ((_ns1__editListScheduleOperation *)ptr)->soap_out(soap, "ns1:editListScheduleOperation", id, NULL);
	case SOAP_TYPE__ns1__addListScheduleOperationResponse:
		return ((_ns1__addListScheduleOperationResponse *)ptr)->soap_out(soap, "ns1:addListScheduleOperationResponse", id, NULL);
	case SOAP_TYPE__ns1__addListScheduleOperation:
		return ((_ns1__addListScheduleOperation *)ptr)->soap_out(soap, "ns1:addListScheduleOperation", id, NULL);
	case SOAP_TYPE__ns1__getListScheduleOperationResponse:
		return ((_ns1__getListScheduleOperationResponse *)ptr)->soap_out(soap, "ns1:getListScheduleOperationResponse", id, NULL);
	case SOAP_TYPE__ns1__getListScheduleOperation:
		return ((_ns1__getListScheduleOperation *)ptr)->soap_out(soap, "ns1:getListScheduleOperation", id, NULL);
	case SOAP_TYPE__ns1__addDayScheduleOperationResponse:
		return ((_ns1__addDayScheduleOperationResponse *)ptr)->soap_out(soap, "ns1:addDayScheduleOperationResponse", id, NULL);
	case SOAP_TYPE__ns1__addDayScheduleOperation:
		return ((_ns1__addDayScheduleOperation *)ptr)->soap_out(soap, "ns1:addDayScheduleOperation", id, NULL);
	case SOAP_TYPE__ns1__removeDayScheduleOperationResponse:
		return ((_ns1__removeDayScheduleOperationResponse *)ptr)->soap_out(soap, "ns1:removeDayScheduleOperationResponse", id, NULL);
	case SOAP_TYPE__ns1__removeDayScheduleOperation:
		return ((_ns1__removeDayScheduleOperation *)ptr)->soap_out(soap, "ns1:removeDayScheduleOperation", id, NULL);
	case SOAP_TYPE__ns1__editDayScheduleOperationResponse:
		return ((_ns1__editDayScheduleOperationResponse *)ptr)->soap_out(soap, "ns1:editDayScheduleOperationResponse", id, NULL);
	case SOAP_TYPE__ns1__editDayScheduleOperation:
		return ((_ns1__editDayScheduleOperation *)ptr)->soap_out(soap, "ns1:editDayScheduleOperation", id, NULL);
	case SOAP_TYPE__ns1__getDayScheduleOperationResponse:
		return ((_ns1__getDayScheduleOperationResponse *)ptr)->soap_out(soap, "ns1:getDayScheduleOperationResponse", id, NULL);
	case SOAP_TYPE__ns1__getDayScheduleOperation:
		return ((_ns1__getDayScheduleOperation *)ptr)->soap_out(soap, "ns1:getDayScheduleOperation", id, NULL);
	case SOAP_TYPE__ns1__editProgramOperationResponse:
		return ((_ns1__editProgramOperationResponse *)ptr)->soap_out(soap, "ns1:editProgramOperationResponse", id, NULL);
	case SOAP_TYPE__ns1__editProgramOperation:
		return ((_ns1__editProgramOperation *)ptr)->soap_out(soap, "ns1:editProgramOperation", id, NULL);
	case SOAP_TYPE__ns1__getProgramOperationResponse:
		return ((_ns1__getProgramOperationResponse *)ptr)->soap_out(soap, "ns1:getProgramOperationResponse", id, NULL);
	case SOAP_TYPE__ns1__getProgramOperation:
		return ((_ns1__getProgramOperation *)ptr)->soap_out(soap, "ns1:getProgramOperation", id, NULL);
	case SOAP_TYPE__ns1__editUserByUserOperationResponse:
		return ((_ns1__editUserByUserOperationResponse *)ptr)->soap_out(soap, "ns1:editUserByUserOperationResponse", id, NULL);
	case SOAP_TYPE__ns1__editUserByUserOperation:
		return ((_ns1__editUserByUserOperation *)ptr)->soap_out(soap, "ns1:editUserByUserOperation", id, NULL);
	case SOAP_TYPE__ns1__removeUserOperationResponse:
		return ((_ns1__removeUserOperationResponse *)ptr)->soap_out(soap, "ns1:removeUserOperationResponse", id, NULL);
	case SOAP_TYPE__ns1__removeUserOperation:
		return ((_ns1__removeUserOperation *)ptr)->soap_out(soap, "ns1:removeUserOperation", id, NULL);
	case SOAP_TYPE__ns1__editUserOperationResponse:
		return ((_ns1__editUserOperationResponse *)ptr)->soap_out(soap, "ns1:editUserOperationResponse", id, NULL);
	case SOAP_TYPE__ns1__editUserOperation:
		return ((_ns1__editUserOperation *)ptr)->soap_out(soap, "ns1:editUserOperation", id, NULL);
	case SOAP_TYPE__ns1__addUserOperationResponse:
		return ((_ns1__addUserOperationResponse *)ptr)->soap_out(soap, "ns1:addUserOperationResponse", id, NULL);
	case SOAP_TYPE__ns1__addUserOperation:
		return ((_ns1__addUserOperation *)ptr)->soap_out(soap, "ns1:addUserOperation", id, NULL);
	case SOAP_TYPE__ns1__getAllUserOperationResponse:
		return ((_ns1__getAllUserOperationResponse *)ptr)->soap_out(soap, "ns1:getAllUserOperationResponse", id, NULL);
	case SOAP_TYPE__ns1__getAllUserOperation:
		return ((_ns1__getAllUserOperation *)ptr)->soap_out(soap, "ns1:getAllUserOperation", id, NULL);
	case SOAP_TYPE__ns1__removeZoneOperationResponse:
		return ((_ns1__removeZoneOperationResponse *)ptr)->soap_out(soap, "ns1:removeZoneOperationResponse", id, NULL);
	case SOAP_TYPE__ns1__removeZoneOperation:
		return ((_ns1__removeZoneOperation *)ptr)->soap_out(soap, "ns1:removeZoneOperation", id, NULL);
	case SOAP_TYPE__ns1__editZoneOperationResponse:
		return ((_ns1__editZoneOperationResponse *)ptr)->soap_out(soap, "ns1:editZoneOperationResponse", id, NULL);
	case SOAP_TYPE__ns1__editZoneOperation:
		return ((_ns1__editZoneOperation *)ptr)->soap_out(soap, "ns1:editZoneOperation", id, NULL);
	case SOAP_TYPE__ns1__addZoneOperationResponse:
		return ((_ns1__addZoneOperationResponse *)ptr)->soap_out(soap, "ns1:addZoneOperationResponse", id, NULL);
	case SOAP_TYPE__ns1__addZoneOperation:
		return ((_ns1__addZoneOperation *)ptr)->soap_out(soap, "ns1:addZoneOperation", id, NULL);
	case SOAP_TYPE__ns1__SetDcuToZoneOperationResponse:
		return ((_ns1__SetDcuToZoneOperationResponse *)ptr)->soap_out(soap, "ns1:SetDcuToZoneOperationResponse", id, NULL);
	case SOAP_TYPE__ns1__SetDcuToZoneOperation:
		return ((_ns1__SetDcuToZoneOperation *)ptr)->soap_out(soap, "ns1:SetDcuToZoneOperation", id, NULL);
	case SOAP_TYPE__ns1__getAllZoneForUserOperationResponse:
		return ((_ns1__getAllZoneForUserOperationResponse *)ptr)->soap_out(soap, "ns1:getAllZoneForUserOperationResponse", id, NULL);
	case SOAP_TYPE__ns1__getAllZoneForUserOperation:
		return ((_ns1__getAllZoneForUserOperation *)ptr)->soap_out(soap, "ns1:getAllZoneForUserOperation", id, NULL);
	case SOAP_TYPE__ns1__getAllZoneOperationResponse:
		return ((_ns1__getAllZoneOperationResponse *)ptr)->soap_out(soap, "ns1:getAllZoneOperationResponse", id, NULL);
	case SOAP_TYPE__ns1__getAllZoneOperation:
		return ((_ns1__getAllZoneOperation *)ptr)->soap_out(soap, "ns1:getAllZoneOperation", id, NULL);
	case SOAP_TYPE__ns1__deleteUserLogOperationResponse:
		return ((_ns1__deleteUserLogOperationResponse *)ptr)->soap_out(soap, "ns1:deleteUserLogOperationResponse", id, NULL);
	case SOAP_TYPE__ns1__deleteUserLogOperation:
		return ((_ns1__deleteUserLogOperation *)ptr)->soap_out(soap, "ns1:deleteUserLogOperation", id, NULL);
	case SOAP_TYPE__ns1__getUserLogOperationResponse:
		return ((_ns1__getUserLogOperationResponse *)ptr)->soap_out(soap, "ns1:getUserLogOperationResponse", id, NULL);
	case SOAP_TYPE__ns1__getUserLogOperation:
		return ((_ns1__getUserLogOperation *)ptr)->soap_out(soap, "ns1:getUserLogOperation", id, NULL);
	case SOAP_TYPE__ns1__deleteEventLogOperationResponse:
		return ((_ns1__deleteEventLogOperationResponse *)ptr)->soap_out(soap, "ns1:deleteEventLogOperationResponse", id, NULL);
	case SOAP_TYPE__ns1__deleteEventLogOperation:
		return ((_ns1__deleteEventLogOperation *)ptr)->soap_out(soap, "ns1:deleteEventLogOperation", id, NULL);
	case SOAP_TYPE__ns1__updateReadEventLogOperationResponse:
		return ((_ns1__updateReadEventLogOperationResponse *)ptr)->soap_out(soap, "ns1:updateReadEventLogOperationResponse", id, NULL);
	case SOAP_TYPE__ns1__updateReadEventLogOperation:
		return ((_ns1__updateReadEventLogOperation *)ptr)->soap_out(soap, "ns1:updateReadEventLogOperation", id, NULL);
	case SOAP_TYPE__ns1__getEventLogOperationResponse:
		return ((_ns1__getEventLogOperationResponse *)ptr)->soap_out(soap, "ns1:getEventLogOperationResponse", id, NULL);
	case SOAP_TYPE__ns1__getEventLogOperation:
		return ((_ns1__getEventLogOperation *)ptr)->soap_out(soap, "ns1:getEventLogOperation", id, NULL);
	case SOAP_TYPE__ns1__setProgramDcuOperationResponse:
		return ((_ns1__setProgramDcuOperationResponse *)ptr)->soap_out(soap, "ns1:setProgramDcuOperationResponse", id, NULL);
	case SOAP_TYPE__ns1__setProgramDcuOperation:
		return ((_ns1__setProgramDcuOperation *)ptr)->soap_out(soap, "ns1:setProgramDcuOperation", id, NULL);
	case SOAP_TYPE__ns1__controlLineOperationResponse:
		return ((_ns1__controlLineOperationResponse *)ptr)->soap_out(soap, "ns1:controlLineOperationResponse", id, NULL);
	case SOAP_TYPE__ns1__controlLineOperation:
		return ((_ns1__controlLineOperation *)ptr)->soap_out(soap, "ns1:controlLineOperation", id, NULL);
	case SOAP_TYPE__ns1__controlLcuOperationResponse:
		return ((_ns1__controlLcuOperationResponse *)ptr)->soap_out(soap, "ns1:controlLcuOperationResponse", id, NULL);
	case SOAP_TYPE__ns1__controlLcuOperation:
		return ((_ns1__controlLcuOperation *)ptr)->soap_out(soap, "ns1:controlLcuOperation", id, NULL);
	case SOAP_TYPE__ns1__removeProgramOperationResponse:
		return ((_ns1__removeProgramOperationResponse *)ptr)->soap_out(soap, "ns1:removeProgramOperationResponse", id, NULL);
	case SOAP_TYPE__ns1__removeProgramOperation:
		return ((_ns1__removeProgramOperation *)ptr)->soap_out(soap, "ns1:removeProgramOperation", id, NULL);
	case SOAP_TYPE__ns1__addProgramOperationResponse:
		return ((_ns1__addProgramOperationResponse *)ptr)->soap_out(soap, "ns1:addProgramOperationResponse", id, NULL);
	case SOAP_TYPE__ns1__addProgramOperation:
		return ((_ns1__addProgramOperation *)ptr)->soap_out(soap, "ns1:addProgramOperation", id, NULL);
	case SOAP_TYPE__ns1__editLineOperationResponse:
		return ((_ns1__editLineOperationResponse *)ptr)->soap_out(soap, "ns1:editLineOperationResponse", id, NULL);
	case SOAP_TYPE__ns1__editLineOperation:
		return ((_ns1__editLineOperation *)ptr)->soap_out(soap, "ns1:editLineOperation", id, NULL);
	case SOAP_TYPE__ns1__removeLineOperationResponse:
		return ((_ns1__removeLineOperationResponse *)ptr)->soap_out(soap, "ns1:removeLineOperationResponse", id, NULL);
	case SOAP_TYPE__ns1__removeLineOperation:
		return ((_ns1__removeLineOperation *)ptr)->soap_out(soap, "ns1:removeLineOperation", id, NULL);
	case SOAP_TYPE__ns1__addLineOperationResponse:
		return ((_ns1__addLineOperationResponse *)ptr)->soap_out(soap, "ns1:addLineOperationResponse", id, NULL);
	case SOAP_TYPE__ns1__addLineOperation:
		return ((_ns1__addLineOperation *)ptr)->soap_out(soap, "ns1:addLineOperation", id, NULL);
	case SOAP_TYPE__ns1__editLcuOperationResponse:
		return ((_ns1__editLcuOperationResponse *)ptr)->soap_out(soap, "ns1:editLcuOperationResponse", id, NULL);
	case SOAP_TYPE__ns1__editLcuOperation:
		return ((_ns1__editLcuOperation *)ptr)->soap_out(soap, "ns1:editLcuOperation", id, NULL);
	case SOAP_TYPE__ns1__removeLcuOperationResponse:
		return ((_ns1__removeLcuOperationResponse *)ptr)->soap_out(soap, "ns1:removeLcuOperationResponse", id, NULL);
	case SOAP_TYPE__ns1__removeLcuOperation:
		return ((_ns1__removeLcuOperation *)ptr)->soap_out(soap, "ns1:removeLcuOperation", id, NULL);
	case SOAP_TYPE__ns1__addLcuOperationResponse:
		return ((_ns1__addLcuOperationResponse *)ptr)->soap_out(soap, "ns1:addLcuOperationResponse", id, NULL);
	case SOAP_TYPE__ns1__addLcuOperation:
		return ((_ns1__addLcuOperation *)ptr)->soap_out(soap, "ns1:addLcuOperation", id, NULL);
	case SOAP_TYPE__ns1__editDcuOperationResponse:
		return ((_ns1__editDcuOperationResponse *)ptr)->soap_out(soap, "ns1:editDcuOperationResponse", id, NULL);
	case SOAP_TYPE__ns1__editDcuOperation:
		return ((_ns1__editDcuOperation *)ptr)->soap_out(soap, "ns1:editDcuOperation", id, NULL);
	case SOAP_TYPE__ns1__removeDcuOperationResponse:
		return ((_ns1__removeDcuOperationResponse *)ptr)->soap_out(soap, "ns1:removeDcuOperationResponse", id, NULL);
	case SOAP_TYPE__ns1__removeDcuOperation:
		return ((_ns1__removeDcuOperation *)ptr)->soap_out(soap, "ns1:removeDcuOperation", id, NULL);
	case SOAP_TYPE__ns1__addDcuOperationResponse:
		return ((_ns1__addDcuOperationResponse *)ptr)->soap_out(soap, "ns1:addDcuOperationResponse", id, NULL);
	case SOAP_TYPE__ns1__addDcuOperation:
		return ((_ns1__addDcuOperation *)ptr)->soap_out(soap, "ns1:addDcuOperation", id, NULL);
	case SOAP_TYPE__ns1__getLineListOperationResponse:
		return ((_ns1__getLineListOperationResponse *)ptr)->soap_out(soap, "ns1:getLineListOperationResponse", id, NULL);
	case SOAP_TYPE__ns1__getLineListOperation:
		return ((_ns1__getLineListOperation *)ptr)->soap_out(soap, "ns1:getLineListOperation", id, NULL);
	case SOAP_TYPE__ns1__updateRuntimeForUserOperationResponse:
		return ((_ns1__updateRuntimeForUserOperationResponse *)ptr)->soap_out(soap, "ns1:updateRuntimeForUserOperationResponse", id, NULL);
	case SOAP_TYPE__ns1__updateRuntimeForUserOperation:
		return ((_ns1__updateRuntimeForUserOperation *)ptr)->soap_out(soap, "ns1:updateRuntimeForUserOperation", id, NULL);
	case SOAP_TYPE__ns1__getLcuListOperationResponse:
		return ((_ns1__getLcuListOperationResponse *)ptr)->soap_out(soap, "ns1:getLcuListOperationResponse", id, NULL);
	case SOAP_TYPE__ns1__getLcuListOperation:
		return ((_ns1__getLcuListOperation *)ptr)->soap_out(soap, "ns1:getLcuListOperation", id, NULL);
	case SOAP_TYPE__ns1__getDcuListOperationResponse:
		return ((_ns1__getDcuListOperationResponse *)ptr)->soap_out(soap, "ns1:getDcuListOperationResponse", id, NULL);
	case SOAP_TYPE__ns1__getDcuListOperation:
		return ((_ns1__getDcuListOperation *)ptr)->soap_out(soap, "ns1:getDcuListOperation", id, NULL);
	case SOAP_TYPE__ns1__LogoutOperationResponse:
		return ((_ns1__LogoutOperationResponse *)ptr)->soap_out(soap, "ns1:LogoutOperationResponse", id, NULL);
	case SOAP_TYPE__ns1__LogoutOperation:
		return ((_ns1__LogoutOperation *)ptr)->soap_out(soap, "ns1:LogoutOperation", id, NULL);
	case SOAP_TYPE__ns1__LoginPcOperationResponse:
		return ((_ns1__LoginPcOperationResponse *)ptr)->soap_out(soap, "ns1:LoginPcOperationResponse", id, NULL);
	case SOAP_TYPE__ns1__LoginPcOperation:
		return ((_ns1__LoginPcOperation *)ptr)->soap_out(soap, "ns1:LoginPcOperation", id, NULL);
	case SOAP_TYPE__ns1__LoginOperationResponse:
		return ((_ns1__LoginOperationResponse *)ptr)->soap_out(soap, "ns1:LoginOperationResponse", id, NULL);
	case SOAP_TYPE__ns1__LoginOperation:
		return ((_ns1__LoginOperation *)ptr)->soap_out(soap, "ns1:LoginOperation", id, NULL);
	case SOAP_TYPE_ns1__SCHEDULE_USCOREINFO_USCOREType:
		return ((ns1__SCHEDULE_USCOREINFO_USCOREType *)ptr)->soap_out(soap, tag, id, "ns1:SCHEDULE_INFO_Type");
	case SOAP_TYPE_ns1__LISTSCHEDULE_USCOREINFO_USCOREType:
		return ((ns1__LISTSCHEDULE_USCOREINFO_USCOREType *)ptr)->soap_out(soap, tag, id, "ns1:LISTSCHEDULE_INFO_Type");
	case SOAP_TYPE_ns1__DAYSCHEDULE_USCOREINFO_USCOREType:
		return ((ns1__DAYSCHEDULE_USCOREINFO_USCOREType *)ptr)->soap_out(soap, tag, id, "ns1:DAYSCHEDULE_INFO_Type");
	case SOAP_TYPE_ns1__PROGRAM_USCOREINFO_USCOREType:
		return ((ns1__PROGRAM_USCOREINFO_USCOREType *)ptr)->soap_out(soap, tag, id, "ns1:PROGRAM_INFO_Type");
	case SOAP_TYPE_ns1__USER_USCOREINFO_USCOREType:
		return ((ns1__USER_USCOREINFO_USCOREType *)ptr)->soap_out(soap, tag, id, "ns1:USER_INFO_Type");
	case SOAP_TYPE_ns1__ZONE_USCOREINFO_USCOREType:
		return ((ns1__ZONE_USCOREINFO_USCOREType *)ptr)->soap_out(soap, tag, id, "ns1:ZONE_INFO_Type");
	case SOAP_TYPE_ns1__USER_USCORELOG_USCOREINFO_USCOREType:
		return ((ns1__USER_USCORELOG_USCOREINFO_USCOREType *)ptr)->soap_out(soap, tag, id, "ns1:USER_LOG_INFO_Type");
	case SOAP_TYPE_ns1__EVENT_USCORELOG_USCOREINFO_USCOREType:
		return ((ns1__EVENT_USCORELOG_USCOREINFO_USCOREType *)ptr)->soap_out(soap, tag, id, "ns1:EVENT_LOG_INFO_Type");
	case SOAP_TYPE_ns1__LINE_USCOREINFO_USCOREType:
		return ((ns1__LINE_USCOREINFO_USCOREType *)ptr)->soap_out(soap, tag, id, "ns1:LINE_INFO_Type");
	case SOAP_TYPE_ns1__LCULOGINFOType:
		return ((ns1__LCULOGINFOType *)ptr)->soap_out(soap, tag, id, "ns1:LCULOGINFOType");
	case SOAP_TYPE_ns1__LCU_USCOREINFO_USCOREType:
		return ((ns1__LCU_USCOREINFO_USCOREType *)ptr)->soap_out(soap, tag, id, "ns1:LCU_INFO_Type");
	case SOAP_TYPE_ns1__DCU_USCOREINFO_USCOREType:
		return ((ns1__DCU_USCOREINFO_USCOREType *)ptr)->soap_out(soap, tag, id, "ns1:DCU_INFO_Type");
	case SOAP_TYPE_ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType:
		return ((ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType *)ptr)->soap_out(soap, tag, id, "ns1:CURR_LOGIN_INFO_Type");
	case SOAP_TYPE_PointerTo_ns1__getLcuLogOperationResponse:
		return soap_out_PointerTo_ns1__getLcuLogOperationResponse(soap, tag, id, (_ns1__getLcuLogOperationResponse *const*)ptr, "ns1:getLcuLogOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__getLcuLogOperation:
		return soap_out_PointerTo_ns1__getLcuLogOperation(soap, tag, id, (_ns1__getLcuLogOperation *const*)ptr, "ns1:getLcuLogOperation");
	case SOAP_TYPE_PointerTo_ns1__removeScheduleOperationResponse:
		return soap_out_PointerTo_ns1__removeScheduleOperationResponse(soap, tag, id, (_ns1__removeScheduleOperationResponse *const*)ptr, "ns1:removeScheduleOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__removeScheduleOperation:
		return soap_out_PointerTo_ns1__removeScheduleOperation(soap, tag, id, (_ns1__removeScheduleOperation *const*)ptr, "ns1:removeScheduleOperation");
	case SOAP_TYPE_PointerTo_ns1__editScheduleOperationResponse:
		return soap_out_PointerTo_ns1__editScheduleOperationResponse(soap, tag, id, (_ns1__editScheduleOperationResponse *const*)ptr, "ns1:editScheduleOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__editScheduleOperation:
		return soap_out_PointerTo_ns1__editScheduleOperation(soap, tag, id, (_ns1__editScheduleOperation *const*)ptr, "ns1:editScheduleOperation");
	case SOAP_TYPE_PointerTo_ns1__addScheduleOperationResponse:
		return soap_out_PointerTo_ns1__addScheduleOperationResponse(soap, tag, id, (_ns1__addScheduleOperationResponse *const*)ptr, "ns1:addScheduleOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__addScheduleOperation:
		return soap_out_PointerTo_ns1__addScheduleOperation(soap, tag, id, (_ns1__addScheduleOperation *const*)ptr, "ns1:addScheduleOperation");
	case SOAP_TYPE_PointerTo_ns1__getScheduleOperationResponse:
		return soap_out_PointerTo_ns1__getScheduleOperationResponse(soap, tag, id, (_ns1__getScheduleOperationResponse *const*)ptr, "ns1:getScheduleOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__getScheduleOperation:
		return soap_out_PointerTo_ns1__getScheduleOperation(soap, tag, id, (_ns1__getScheduleOperation *const*)ptr, "ns1:getScheduleOperation");
	case SOAP_TYPE_PointerTo_ns1__removeListScheduleOperationResponse:
		return soap_out_PointerTo_ns1__removeListScheduleOperationResponse(soap, tag, id, (_ns1__removeListScheduleOperationResponse *const*)ptr, "ns1:removeListScheduleOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__removeListScheduleOperation:
		return soap_out_PointerTo_ns1__removeListScheduleOperation(soap, tag, id, (_ns1__removeListScheduleOperation *const*)ptr, "ns1:removeListScheduleOperation");
	case SOAP_TYPE_PointerTo_ns1__editListScheduleOperationResponse:
		return soap_out_PointerTo_ns1__editListScheduleOperationResponse(soap, tag, id, (_ns1__editListScheduleOperationResponse *const*)ptr, "ns1:editListScheduleOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__editListScheduleOperation:
		return soap_out_PointerTo_ns1__editListScheduleOperation(soap, tag, id, (_ns1__editListScheduleOperation *const*)ptr, "ns1:editListScheduleOperation");
	case SOAP_TYPE_PointerTo_ns1__addListScheduleOperationResponse:
		return soap_out_PointerTo_ns1__addListScheduleOperationResponse(soap, tag, id, (_ns1__addListScheduleOperationResponse *const*)ptr, "ns1:addListScheduleOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__addListScheduleOperation:
		return soap_out_PointerTo_ns1__addListScheduleOperation(soap, tag, id, (_ns1__addListScheduleOperation *const*)ptr, "ns1:addListScheduleOperation");
	case SOAP_TYPE_PointerTo_ns1__getListScheduleOperationResponse:
		return soap_out_PointerTo_ns1__getListScheduleOperationResponse(soap, tag, id, (_ns1__getListScheduleOperationResponse *const*)ptr, "ns1:getListScheduleOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__getListScheduleOperation:
		return soap_out_PointerTo_ns1__getListScheduleOperation(soap, tag, id, (_ns1__getListScheduleOperation *const*)ptr, "ns1:getListScheduleOperation");
	case SOAP_TYPE_PointerTo_ns1__addDayScheduleOperationResponse:
		return soap_out_PointerTo_ns1__addDayScheduleOperationResponse(soap, tag, id, (_ns1__addDayScheduleOperationResponse *const*)ptr, "ns1:addDayScheduleOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__addDayScheduleOperation:
		return soap_out_PointerTo_ns1__addDayScheduleOperation(soap, tag, id, (_ns1__addDayScheduleOperation *const*)ptr, "ns1:addDayScheduleOperation");
	case SOAP_TYPE_PointerTo_ns1__removeDayScheduleOperationResponse:
		return soap_out_PointerTo_ns1__removeDayScheduleOperationResponse(soap, tag, id, (_ns1__removeDayScheduleOperationResponse *const*)ptr, "ns1:removeDayScheduleOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__removeDayScheduleOperation:
		return soap_out_PointerTo_ns1__removeDayScheduleOperation(soap, tag, id, (_ns1__removeDayScheduleOperation *const*)ptr, "ns1:removeDayScheduleOperation");
	case SOAP_TYPE_PointerTo_ns1__editDayScheduleOperationResponse:
		return soap_out_PointerTo_ns1__editDayScheduleOperationResponse(soap, tag, id, (_ns1__editDayScheduleOperationResponse *const*)ptr, "ns1:editDayScheduleOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__editDayScheduleOperation:
		return soap_out_PointerTo_ns1__editDayScheduleOperation(soap, tag, id, (_ns1__editDayScheduleOperation *const*)ptr, "ns1:editDayScheduleOperation");
	case SOAP_TYPE_PointerTo_ns1__getDayScheduleOperationResponse:
		return soap_out_PointerTo_ns1__getDayScheduleOperationResponse(soap, tag, id, (_ns1__getDayScheduleOperationResponse *const*)ptr, "ns1:getDayScheduleOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__getDayScheduleOperation:
		return soap_out_PointerTo_ns1__getDayScheduleOperation(soap, tag, id, (_ns1__getDayScheduleOperation *const*)ptr, "ns1:getDayScheduleOperation");
	case SOAP_TYPE_PointerTo_ns1__editProgramOperationResponse:
		return soap_out_PointerTo_ns1__editProgramOperationResponse(soap, tag, id, (_ns1__editProgramOperationResponse *const*)ptr, "ns1:editProgramOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__editProgramOperation:
		return soap_out_PointerTo_ns1__editProgramOperation(soap, tag, id, (_ns1__editProgramOperation *const*)ptr, "ns1:editProgramOperation");
	case SOAP_TYPE_PointerTo_ns1__getProgramOperationResponse:
		return soap_out_PointerTo_ns1__getProgramOperationResponse(soap, tag, id, (_ns1__getProgramOperationResponse *const*)ptr, "ns1:getProgramOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__getProgramOperation:
		return soap_out_PointerTo_ns1__getProgramOperation(soap, tag, id, (_ns1__getProgramOperation *const*)ptr, "ns1:getProgramOperation");
	case SOAP_TYPE_PointerTo_ns1__editUserByUserOperationResponse:
		return soap_out_PointerTo_ns1__editUserByUserOperationResponse(soap, tag, id, (_ns1__editUserByUserOperationResponse *const*)ptr, "ns1:editUserByUserOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__editUserByUserOperation:
		return soap_out_PointerTo_ns1__editUserByUserOperation(soap, tag, id, (_ns1__editUserByUserOperation *const*)ptr, "ns1:editUserByUserOperation");
	case SOAP_TYPE_PointerTo_ns1__removeUserOperationResponse:
		return soap_out_PointerTo_ns1__removeUserOperationResponse(soap, tag, id, (_ns1__removeUserOperationResponse *const*)ptr, "ns1:removeUserOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__removeUserOperation:
		return soap_out_PointerTo_ns1__removeUserOperation(soap, tag, id, (_ns1__removeUserOperation *const*)ptr, "ns1:removeUserOperation");
	case SOAP_TYPE_PointerTo_ns1__editUserOperationResponse:
		return soap_out_PointerTo_ns1__editUserOperationResponse(soap, tag, id, (_ns1__editUserOperationResponse *const*)ptr, "ns1:editUserOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__editUserOperation:
		return soap_out_PointerTo_ns1__editUserOperation(soap, tag, id, (_ns1__editUserOperation *const*)ptr, "ns1:editUserOperation");
	case SOAP_TYPE_PointerTo_ns1__addUserOperationResponse:
		return soap_out_PointerTo_ns1__addUserOperationResponse(soap, tag, id, (_ns1__addUserOperationResponse *const*)ptr, "ns1:addUserOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__addUserOperation:
		return soap_out_PointerTo_ns1__addUserOperation(soap, tag, id, (_ns1__addUserOperation *const*)ptr, "ns1:addUserOperation");
	case SOAP_TYPE_PointerTo_ns1__getAllUserOperationResponse:
		return soap_out_PointerTo_ns1__getAllUserOperationResponse(soap, tag, id, (_ns1__getAllUserOperationResponse *const*)ptr, "ns1:getAllUserOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__getAllUserOperation:
		return soap_out_PointerTo_ns1__getAllUserOperation(soap, tag, id, (_ns1__getAllUserOperation *const*)ptr, "ns1:getAllUserOperation");
	case SOAP_TYPE_PointerTo_ns1__removeZoneOperationResponse:
		return soap_out_PointerTo_ns1__removeZoneOperationResponse(soap, tag, id, (_ns1__removeZoneOperationResponse *const*)ptr, "ns1:removeZoneOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__removeZoneOperation:
		return soap_out_PointerTo_ns1__removeZoneOperation(soap, tag, id, (_ns1__removeZoneOperation *const*)ptr, "ns1:removeZoneOperation");
	case SOAP_TYPE_PointerTo_ns1__editZoneOperationResponse:
		return soap_out_PointerTo_ns1__editZoneOperationResponse(soap, tag, id, (_ns1__editZoneOperationResponse *const*)ptr, "ns1:editZoneOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__editZoneOperation:
		return soap_out_PointerTo_ns1__editZoneOperation(soap, tag, id, (_ns1__editZoneOperation *const*)ptr, "ns1:editZoneOperation");
	case SOAP_TYPE_PointerTo_ns1__addZoneOperationResponse:
		return soap_out_PointerTo_ns1__addZoneOperationResponse(soap, tag, id, (_ns1__addZoneOperationResponse *const*)ptr, "ns1:addZoneOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__addZoneOperation:
		return soap_out_PointerTo_ns1__addZoneOperation(soap, tag, id, (_ns1__addZoneOperation *const*)ptr, "ns1:addZoneOperation");
	case SOAP_TYPE_PointerTo_ns1__SetDcuToZoneOperationResponse:
		return soap_out_PointerTo_ns1__SetDcuToZoneOperationResponse(soap, tag, id, (_ns1__SetDcuToZoneOperationResponse *const*)ptr, "ns1:SetDcuToZoneOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__SetDcuToZoneOperation:
		return soap_out_PointerTo_ns1__SetDcuToZoneOperation(soap, tag, id, (_ns1__SetDcuToZoneOperation *const*)ptr, "ns1:SetDcuToZoneOperation");
	case SOAP_TYPE_PointerTo_ns1__getAllZoneForUserOperationResponse:
		return soap_out_PointerTo_ns1__getAllZoneForUserOperationResponse(soap, tag, id, (_ns1__getAllZoneForUserOperationResponse *const*)ptr, "ns1:getAllZoneForUserOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__getAllZoneForUserOperation:
		return soap_out_PointerTo_ns1__getAllZoneForUserOperation(soap, tag, id, (_ns1__getAllZoneForUserOperation *const*)ptr, "ns1:getAllZoneForUserOperation");
	case SOAP_TYPE_PointerTo_ns1__getAllZoneOperationResponse:
		return soap_out_PointerTo_ns1__getAllZoneOperationResponse(soap, tag, id, (_ns1__getAllZoneOperationResponse *const*)ptr, "ns1:getAllZoneOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__getAllZoneOperation:
		return soap_out_PointerTo_ns1__getAllZoneOperation(soap, tag, id, (_ns1__getAllZoneOperation *const*)ptr, "ns1:getAllZoneOperation");
	case SOAP_TYPE_PointerTo_ns1__deleteUserLogOperationResponse:
		return soap_out_PointerTo_ns1__deleteUserLogOperationResponse(soap, tag, id, (_ns1__deleteUserLogOperationResponse *const*)ptr, "ns1:deleteUserLogOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__deleteUserLogOperation:
		return soap_out_PointerTo_ns1__deleteUserLogOperation(soap, tag, id, (_ns1__deleteUserLogOperation *const*)ptr, "ns1:deleteUserLogOperation");
	case SOAP_TYPE_PointerTo_ns1__getUserLogOperationResponse:
		return soap_out_PointerTo_ns1__getUserLogOperationResponse(soap, tag, id, (_ns1__getUserLogOperationResponse *const*)ptr, "ns1:getUserLogOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__getUserLogOperation:
		return soap_out_PointerTo_ns1__getUserLogOperation(soap, tag, id, (_ns1__getUserLogOperation *const*)ptr, "ns1:getUserLogOperation");
	case SOAP_TYPE_PointerTo_ns1__deleteEventLogOperationResponse:
		return soap_out_PointerTo_ns1__deleteEventLogOperationResponse(soap, tag, id, (_ns1__deleteEventLogOperationResponse *const*)ptr, "ns1:deleteEventLogOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__deleteEventLogOperation:
		return soap_out_PointerTo_ns1__deleteEventLogOperation(soap, tag, id, (_ns1__deleteEventLogOperation *const*)ptr, "ns1:deleteEventLogOperation");
	case SOAP_TYPE_PointerTo_ns1__updateReadEventLogOperationResponse:
		return soap_out_PointerTo_ns1__updateReadEventLogOperationResponse(soap, tag, id, (_ns1__updateReadEventLogOperationResponse *const*)ptr, "ns1:updateReadEventLogOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__updateReadEventLogOperation:
		return soap_out_PointerTo_ns1__updateReadEventLogOperation(soap, tag, id, (_ns1__updateReadEventLogOperation *const*)ptr, "ns1:updateReadEventLogOperation");
	case SOAP_TYPE_PointerTo_ns1__getEventLogOperationResponse:
		return soap_out_PointerTo_ns1__getEventLogOperationResponse(soap, tag, id, (_ns1__getEventLogOperationResponse *const*)ptr, "ns1:getEventLogOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__getEventLogOperation:
		return soap_out_PointerTo_ns1__getEventLogOperation(soap, tag, id, (_ns1__getEventLogOperation *const*)ptr, "ns1:getEventLogOperation");
	case SOAP_TYPE_PointerTo_ns1__setProgramDcuOperationResponse:
		return soap_out_PointerTo_ns1__setProgramDcuOperationResponse(soap, tag, id, (_ns1__setProgramDcuOperationResponse *const*)ptr, "ns1:setProgramDcuOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__setProgramDcuOperation:
		return soap_out_PointerTo_ns1__setProgramDcuOperation(soap, tag, id, (_ns1__setProgramDcuOperation *const*)ptr, "ns1:setProgramDcuOperation");
	case SOAP_TYPE_PointerTo_ns1__controlLineOperationResponse:
		return soap_out_PointerTo_ns1__controlLineOperationResponse(soap, tag, id, (_ns1__controlLineOperationResponse *const*)ptr, "ns1:controlLineOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__controlLineOperation:
		return soap_out_PointerTo_ns1__controlLineOperation(soap, tag, id, (_ns1__controlLineOperation *const*)ptr, "ns1:controlLineOperation");
	case SOAP_TYPE_PointerTo_ns1__controlLcuOperationResponse:
		return soap_out_PointerTo_ns1__controlLcuOperationResponse(soap, tag, id, (_ns1__controlLcuOperationResponse *const*)ptr, "ns1:controlLcuOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__controlLcuOperation:
		return soap_out_PointerTo_ns1__controlLcuOperation(soap, tag, id, (_ns1__controlLcuOperation *const*)ptr, "ns1:controlLcuOperation");
	case SOAP_TYPE_PointerTo_ns1__removeProgramOperationResponse:
		return soap_out_PointerTo_ns1__removeProgramOperationResponse(soap, tag, id, (_ns1__removeProgramOperationResponse *const*)ptr, "ns1:removeProgramOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__removeProgramOperation:
		return soap_out_PointerTo_ns1__removeProgramOperation(soap, tag, id, (_ns1__removeProgramOperation *const*)ptr, "ns1:removeProgramOperation");
	case SOAP_TYPE_PointerTo_ns1__addProgramOperationResponse:
		return soap_out_PointerTo_ns1__addProgramOperationResponse(soap, tag, id, (_ns1__addProgramOperationResponse *const*)ptr, "ns1:addProgramOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__addProgramOperation:
		return soap_out_PointerTo_ns1__addProgramOperation(soap, tag, id, (_ns1__addProgramOperation *const*)ptr, "ns1:addProgramOperation");
	case SOAP_TYPE_PointerTo_ns1__editLineOperationResponse:
		return soap_out_PointerTo_ns1__editLineOperationResponse(soap, tag, id, (_ns1__editLineOperationResponse *const*)ptr, "ns1:editLineOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__editLineOperation:
		return soap_out_PointerTo_ns1__editLineOperation(soap, tag, id, (_ns1__editLineOperation *const*)ptr, "ns1:editLineOperation");
	case SOAP_TYPE_PointerTo_ns1__removeLineOperationResponse:
		return soap_out_PointerTo_ns1__removeLineOperationResponse(soap, tag, id, (_ns1__removeLineOperationResponse *const*)ptr, "ns1:removeLineOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__removeLineOperation:
		return soap_out_PointerTo_ns1__removeLineOperation(soap, tag, id, (_ns1__removeLineOperation *const*)ptr, "ns1:removeLineOperation");
	case SOAP_TYPE_PointerTo_ns1__addLineOperationResponse:
		return soap_out_PointerTo_ns1__addLineOperationResponse(soap, tag, id, (_ns1__addLineOperationResponse *const*)ptr, "ns1:addLineOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__addLineOperation:
		return soap_out_PointerTo_ns1__addLineOperation(soap, tag, id, (_ns1__addLineOperation *const*)ptr, "ns1:addLineOperation");
	case SOAP_TYPE_PointerTo_ns1__editLcuOperationResponse:
		return soap_out_PointerTo_ns1__editLcuOperationResponse(soap, tag, id, (_ns1__editLcuOperationResponse *const*)ptr, "ns1:editLcuOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__editLcuOperation:
		return soap_out_PointerTo_ns1__editLcuOperation(soap, tag, id, (_ns1__editLcuOperation *const*)ptr, "ns1:editLcuOperation");
	case SOAP_TYPE_PointerTo_ns1__removeLcuOperationResponse:
		return soap_out_PointerTo_ns1__removeLcuOperationResponse(soap, tag, id, (_ns1__removeLcuOperationResponse *const*)ptr, "ns1:removeLcuOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__removeLcuOperation:
		return soap_out_PointerTo_ns1__removeLcuOperation(soap, tag, id, (_ns1__removeLcuOperation *const*)ptr, "ns1:removeLcuOperation");
	case SOAP_TYPE_PointerTo_ns1__addLcuOperationResponse:
		return soap_out_PointerTo_ns1__addLcuOperationResponse(soap, tag, id, (_ns1__addLcuOperationResponse *const*)ptr, "ns1:addLcuOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__addLcuOperation:
		return soap_out_PointerTo_ns1__addLcuOperation(soap, tag, id, (_ns1__addLcuOperation *const*)ptr, "ns1:addLcuOperation");
	case SOAP_TYPE_PointerTo_ns1__editDcuOperationResponse:
		return soap_out_PointerTo_ns1__editDcuOperationResponse(soap, tag, id, (_ns1__editDcuOperationResponse *const*)ptr, "ns1:editDcuOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__editDcuOperation:
		return soap_out_PointerTo_ns1__editDcuOperation(soap, tag, id, (_ns1__editDcuOperation *const*)ptr, "ns1:editDcuOperation");
	case SOAP_TYPE_PointerTo_ns1__removeDcuOperationResponse:
		return soap_out_PointerTo_ns1__removeDcuOperationResponse(soap, tag, id, (_ns1__removeDcuOperationResponse *const*)ptr, "ns1:removeDcuOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__removeDcuOperation:
		return soap_out_PointerTo_ns1__removeDcuOperation(soap, tag, id, (_ns1__removeDcuOperation *const*)ptr, "ns1:removeDcuOperation");
	case SOAP_TYPE_PointerTo_ns1__addDcuOperationResponse:
		return soap_out_PointerTo_ns1__addDcuOperationResponse(soap, tag, id, (_ns1__addDcuOperationResponse *const*)ptr, "ns1:addDcuOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__addDcuOperation:
		return soap_out_PointerTo_ns1__addDcuOperation(soap, tag, id, (_ns1__addDcuOperation *const*)ptr, "ns1:addDcuOperation");
	case SOAP_TYPE_PointerTo_ns1__getLineListOperationResponse:
		return soap_out_PointerTo_ns1__getLineListOperationResponse(soap, tag, id, (_ns1__getLineListOperationResponse *const*)ptr, "ns1:getLineListOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__getLineListOperation:
		return soap_out_PointerTo_ns1__getLineListOperation(soap, tag, id, (_ns1__getLineListOperation *const*)ptr, "ns1:getLineListOperation");
	case SOAP_TYPE_PointerTo_ns1__updateRuntimeForUserOperationResponse:
		return soap_out_PointerTo_ns1__updateRuntimeForUserOperationResponse(soap, tag, id, (_ns1__updateRuntimeForUserOperationResponse *const*)ptr, "ns1:updateRuntimeForUserOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__updateRuntimeForUserOperation:
		return soap_out_PointerTo_ns1__updateRuntimeForUserOperation(soap, tag, id, (_ns1__updateRuntimeForUserOperation *const*)ptr, "ns1:updateRuntimeForUserOperation");
	case SOAP_TYPE_PointerTo_ns1__getLcuListOperationResponse:
		return soap_out_PointerTo_ns1__getLcuListOperationResponse(soap, tag, id, (_ns1__getLcuListOperationResponse *const*)ptr, "ns1:getLcuListOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__getLcuListOperation:
		return soap_out_PointerTo_ns1__getLcuListOperation(soap, tag, id, (_ns1__getLcuListOperation *const*)ptr, "ns1:getLcuListOperation");
	case SOAP_TYPE_PointerTo_ns1__getDcuListOperationResponse:
		return soap_out_PointerTo_ns1__getDcuListOperationResponse(soap, tag, id, (_ns1__getDcuListOperationResponse *const*)ptr, "ns1:getDcuListOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__getDcuListOperation:
		return soap_out_PointerTo_ns1__getDcuListOperation(soap, tag, id, (_ns1__getDcuListOperation *const*)ptr, "ns1:getDcuListOperation");
	case SOAP_TYPE_PointerTo_ns1__LogoutOperationResponse:
		return soap_out_PointerTo_ns1__LogoutOperationResponse(soap, tag, id, (_ns1__LogoutOperationResponse *const*)ptr, "ns1:LogoutOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__LogoutOperation:
		return soap_out_PointerTo_ns1__LogoutOperation(soap, tag, id, (_ns1__LogoutOperation *const*)ptr, "ns1:LogoutOperation");
	case SOAP_TYPE_PointerTo_ns1__LoginPcOperationResponse:
		return soap_out_PointerTo_ns1__LoginPcOperationResponse(soap, tag, id, (_ns1__LoginPcOperationResponse *const*)ptr, "ns1:LoginPcOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__LoginPcOperation:
		return soap_out_PointerTo_ns1__LoginPcOperation(soap, tag, id, (_ns1__LoginPcOperation *const*)ptr, "ns1:LoginPcOperation");
	case SOAP_TYPE_PointerTo_ns1__LoginOperationResponse:
		return soap_out_PointerTo_ns1__LoginOperationResponse(soap, tag, id, (_ns1__LoginOperationResponse *const*)ptr, "ns1:LoginOperationResponse");
	case SOAP_TYPE_PointerTo_ns1__LoginOperation:
		return soap_out_PointerTo_ns1__LoginOperation(soap, tag, id, (_ns1__LoginOperation *const*)ptr, "ns1:LoginOperation");
	case SOAP_TYPE_PointerToPointerTons1__LCULOGINFOType:
		return soap_out_PointerToPointerTons1__LCULOGINFOType(soap, tag, id, (ns1__LCULOGINFOType **const*)ptr, "ns1:LCULOGINFOType");
	case SOAP_TYPE_PointerTons1__LCULOGINFOType:
		return soap_out_PointerTons1__LCULOGINFOType(soap, tag, id, (ns1__LCULOGINFOType *const*)ptr, "ns1:LCULOGINFOType");
	case SOAP_TYPE_PointerToPointerTons1__LISTSCHEDULE_USCOREINFO_USCOREType:
		return soap_out_PointerToPointerTons1__LISTSCHEDULE_USCOREINFO_USCOREType(soap, tag, id, (ns1__LISTSCHEDULE_USCOREINFO_USCOREType **const*)ptr, "ns1:LISTSCHEDULE_INFO_Type");
	case SOAP_TYPE_PointerTons1__LISTSCHEDULE_USCOREINFO_USCOREType:
		return soap_out_PointerTons1__LISTSCHEDULE_USCOREINFO_USCOREType(soap, tag, id, (ns1__LISTSCHEDULE_USCOREINFO_USCOREType *const*)ptr, "ns1:LISTSCHEDULE_INFO_Type");
	case SOAP_TYPE_PointerToPointerTons1__DAYSCHEDULE_USCOREINFO_USCOREType:
		return soap_out_PointerToPointerTons1__DAYSCHEDULE_USCOREINFO_USCOREType(soap, tag, id, (ns1__DAYSCHEDULE_USCOREINFO_USCOREType **const*)ptr, "ns1:DAYSCHEDULE_INFO_Type");
	case SOAP_TYPE_PointerTons1__DAYSCHEDULE_USCOREINFO_USCOREType:
		return soap_out_PointerTons1__DAYSCHEDULE_USCOREINFO_USCOREType(soap, tag, id, (ns1__DAYSCHEDULE_USCOREINFO_USCOREType *const*)ptr, "ns1:DAYSCHEDULE_INFO_Type");
	case SOAP_TYPE_PointerToPointerTons1__PROGRAM_USCOREINFO_USCOREType:
		return soap_out_PointerToPointerTons1__PROGRAM_USCOREINFO_USCOREType(soap, tag, id, (ns1__PROGRAM_USCOREINFO_USCOREType **const*)ptr, "ns1:PROGRAM_INFO_Type");
	case SOAP_TYPE_PointerTons1__PROGRAM_USCOREINFO_USCOREType:
		return soap_out_PointerTons1__PROGRAM_USCOREINFO_USCOREType(soap, tag, id, (ns1__PROGRAM_USCOREINFO_USCOREType *const*)ptr, "ns1:PROGRAM_INFO_Type");
	case SOAP_TYPE_PointerToPointerTons1__USER_USCOREINFO_USCOREType:
		return soap_out_PointerToPointerTons1__USER_USCOREINFO_USCOREType(soap, tag, id, (ns1__USER_USCOREINFO_USCOREType **const*)ptr, "ns1:USER_INFO_Type");
	case SOAP_TYPE_PointerToPointerTons1__USER_USCORELOG_USCOREINFO_USCOREType:
		return soap_out_PointerToPointerTons1__USER_USCORELOG_USCOREINFO_USCOREType(soap, tag, id, (ns1__USER_USCORELOG_USCOREINFO_USCOREType **const*)ptr, "ns1:USER_LOG_INFO_Type");
	case SOAP_TYPE_PointerTons1__USER_USCORELOG_USCOREINFO_USCOREType:
		return soap_out_PointerTons1__USER_USCORELOG_USCOREINFO_USCOREType(soap, tag, id, (ns1__USER_USCORELOG_USCOREINFO_USCOREType *const*)ptr, "ns1:USER_LOG_INFO_Type");
	case SOAP_TYPE_PointerToPointerTons1__LINE_USCOREINFO_USCOREType:
		return soap_out_PointerToPointerTons1__LINE_USCOREINFO_USCOREType(soap, tag, id, (ns1__LINE_USCOREINFO_USCOREType **const*)ptr, "ns1:LINE_INFO_Type");
	case SOAP_TYPE_PointerTons1__LINE_USCOREINFO_USCOREType:
		return soap_out_PointerTons1__LINE_USCOREINFO_USCOREType(soap, tag, id, (ns1__LINE_USCOREINFO_USCOREType *const*)ptr, "ns1:LINE_INFO_Type");
	case SOAP_TYPE_PointerToPointerTons1__EVENT_USCORELOG_USCOREINFO_USCOREType:
		return soap_out_PointerToPointerTons1__EVENT_USCORELOG_USCOREINFO_USCOREType(soap, tag, id, (ns1__EVENT_USCORELOG_USCOREINFO_USCOREType **const*)ptr, "ns1:EVENT_LOG_INFO_Type");
	case SOAP_TYPE_PointerTons1__EVENT_USCORELOG_USCOREINFO_USCOREType:
		return soap_out_PointerTons1__EVENT_USCORELOG_USCOREINFO_USCOREType(soap, tag, id, (ns1__EVENT_USCORELOG_USCOREINFO_USCOREType *const*)ptr, "ns1:EVENT_LOG_INFO_Type");
	case SOAP_TYPE_PointerToPointerTons1__LCU_USCOREINFO_USCOREType:
		return soap_out_PointerToPointerTons1__LCU_USCOREINFO_USCOREType(soap, tag, id, (ns1__LCU_USCOREINFO_USCOREType **const*)ptr, "ns1:LCU_INFO_Type");
	case SOAP_TYPE_PointerTons1__LCU_USCOREINFO_USCOREType:
		return soap_out_PointerTons1__LCU_USCOREINFO_USCOREType(soap, tag, id, (ns1__LCU_USCOREINFO_USCOREType *const*)ptr, "ns1:LCU_INFO_Type");
	case SOAP_TYPE_PointerToPointerTons1__DCU_USCOREINFO_USCOREType:
		return soap_out_PointerToPointerTons1__DCU_USCOREINFO_USCOREType(soap, tag, id, (ns1__DCU_USCOREINFO_USCOREType **const*)ptr, "ns1:DCU_INFO_Type");
	case SOAP_TYPE_PointerTons1__DCU_USCOREINFO_USCOREType:
		return soap_out_PointerTons1__DCU_USCOREINFO_USCOREType(soap, tag, id, (ns1__DCU_USCOREINFO_USCOREType *const*)ptr, "ns1:DCU_INFO_Type");
	case SOAP_TYPE_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType:
		return soap_out_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, tag, id, (ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType *const*)ptr, "ns1:CURR_LOGIN_INFO_Type");
	case SOAP_TYPE_PointerTons1__USER_USCOREINFO_USCOREType:
		return soap_out_PointerTons1__USER_USCOREINFO_USCOREType(soap, tag, id, (ns1__USER_USCOREINFO_USCOREType *const*)ptr, "ns1:USER_INFO_Type");
	case SOAP_TYPE_PointerToPointerTons1__SCHEDULE_USCOREINFO_USCOREType:
		return soap_out_PointerToPointerTons1__SCHEDULE_USCOREINFO_USCOREType(soap, tag, id, (ns1__SCHEDULE_USCOREINFO_USCOREType **const*)ptr, "ns1:SCHEDULE_INFO_Type");
	case SOAP_TYPE_PointerTons1__SCHEDULE_USCOREINFO_USCOREType:
		return soap_out_PointerTons1__SCHEDULE_USCOREINFO_USCOREType(soap, tag, id, (ns1__SCHEDULE_USCOREINFO_USCOREType *const*)ptr, "ns1:SCHEDULE_INFO_Type");
	case SOAP_TYPE_PointerToPointerTons1__ZONE_USCOREINFO_USCOREType:
		return soap_out_PointerToPointerTons1__ZONE_USCOREINFO_USCOREType(soap, tag, id, (ns1__ZONE_USCOREINFO_USCOREType **const*)ptr, "ns1:ZONE_INFO_Type");
	case SOAP_TYPE_PointerTons1__ZONE_USCOREINFO_USCOREType:
		return soap_out_PointerTons1__ZONE_USCOREINFO_USCOREType(soap, tag, id, (ns1__ZONE_USCOREINFO_USCOREType *const*)ptr, "ns1:ZONE_INFO_Type");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE__ns1__getLcuLogOperationResponse:
		((_ns1__getLcuLogOperationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getLcuLogOperation:
		((_ns1__getLcuLogOperation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__removeScheduleOperationResponse:
		((_ns1__removeScheduleOperationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__removeScheduleOperation:
		((_ns1__removeScheduleOperation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__editScheduleOperationResponse:
		((_ns1__editScheduleOperationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__editScheduleOperation:
		((_ns1__editScheduleOperation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__addScheduleOperationResponse:
		((_ns1__addScheduleOperationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__addScheduleOperation:
		((_ns1__addScheduleOperation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getScheduleOperationResponse:
		((_ns1__getScheduleOperationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getScheduleOperation:
		((_ns1__getScheduleOperation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__removeListScheduleOperationResponse:
		((_ns1__removeListScheduleOperationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__removeListScheduleOperation:
		((_ns1__removeListScheduleOperation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__editListScheduleOperationResponse:
		((_ns1__editListScheduleOperationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__editListScheduleOperation:
		((_ns1__editListScheduleOperation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__addListScheduleOperationResponse:
		((_ns1__addListScheduleOperationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__addListScheduleOperation:
		((_ns1__addListScheduleOperation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getListScheduleOperationResponse:
		((_ns1__getListScheduleOperationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getListScheduleOperation:
		((_ns1__getListScheduleOperation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__addDayScheduleOperationResponse:
		((_ns1__addDayScheduleOperationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__addDayScheduleOperation:
		((_ns1__addDayScheduleOperation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__removeDayScheduleOperationResponse:
		((_ns1__removeDayScheduleOperationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__removeDayScheduleOperation:
		((_ns1__removeDayScheduleOperation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__editDayScheduleOperationResponse:
		((_ns1__editDayScheduleOperationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__editDayScheduleOperation:
		((_ns1__editDayScheduleOperation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getDayScheduleOperationResponse:
		((_ns1__getDayScheduleOperationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getDayScheduleOperation:
		((_ns1__getDayScheduleOperation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__editProgramOperationResponse:
		((_ns1__editProgramOperationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__editProgramOperation:
		((_ns1__editProgramOperation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getProgramOperationResponse:
		((_ns1__getProgramOperationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getProgramOperation:
		((_ns1__getProgramOperation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__editUserByUserOperationResponse:
		((_ns1__editUserByUserOperationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__editUserByUserOperation:
		((_ns1__editUserByUserOperation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__removeUserOperationResponse:
		((_ns1__removeUserOperationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__removeUserOperation:
		((_ns1__removeUserOperation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__editUserOperationResponse:
		((_ns1__editUserOperationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__editUserOperation:
		((_ns1__editUserOperation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__addUserOperationResponse:
		((_ns1__addUserOperationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__addUserOperation:
		((_ns1__addUserOperation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getAllUserOperationResponse:
		((_ns1__getAllUserOperationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getAllUserOperation:
		((_ns1__getAllUserOperation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__removeZoneOperationResponse:
		((_ns1__removeZoneOperationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__removeZoneOperation:
		((_ns1__removeZoneOperation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__editZoneOperationResponse:
		((_ns1__editZoneOperationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__editZoneOperation:
		((_ns1__editZoneOperation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__addZoneOperationResponse:
		((_ns1__addZoneOperationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__addZoneOperation:
		((_ns1__addZoneOperation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SetDcuToZoneOperationResponse:
		((_ns1__SetDcuToZoneOperationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SetDcuToZoneOperation:
		((_ns1__SetDcuToZoneOperation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getAllZoneForUserOperationResponse:
		((_ns1__getAllZoneForUserOperationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getAllZoneForUserOperation:
		((_ns1__getAllZoneForUserOperation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getAllZoneOperationResponse:
		((_ns1__getAllZoneOperationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getAllZoneOperation:
		((_ns1__getAllZoneOperation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__deleteUserLogOperationResponse:
		((_ns1__deleteUserLogOperationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__deleteUserLogOperation:
		((_ns1__deleteUserLogOperation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getUserLogOperationResponse:
		((_ns1__getUserLogOperationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getUserLogOperation:
		((_ns1__getUserLogOperation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__deleteEventLogOperationResponse:
		((_ns1__deleteEventLogOperationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__deleteEventLogOperation:
		((_ns1__deleteEventLogOperation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__updateReadEventLogOperationResponse:
		((_ns1__updateReadEventLogOperationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__updateReadEventLogOperation:
		((_ns1__updateReadEventLogOperation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getEventLogOperationResponse:
		((_ns1__getEventLogOperationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getEventLogOperation:
		((_ns1__getEventLogOperation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__setProgramDcuOperationResponse:
		((_ns1__setProgramDcuOperationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__setProgramDcuOperation:
		((_ns1__setProgramDcuOperation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__controlLineOperationResponse:
		((_ns1__controlLineOperationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__controlLineOperation:
		((_ns1__controlLineOperation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__controlLcuOperationResponse:
		((_ns1__controlLcuOperationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__controlLcuOperation:
		((_ns1__controlLcuOperation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__removeProgramOperationResponse:
		((_ns1__removeProgramOperationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__removeProgramOperation:
		((_ns1__removeProgramOperation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__addProgramOperationResponse:
		((_ns1__addProgramOperationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__addProgramOperation:
		((_ns1__addProgramOperation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__editLineOperationResponse:
		((_ns1__editLineOperationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__editLineOperation:
		((_ns1__editLineOperation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__removeLineOperationResponse:
		((_ns1__removeLineOperationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__removeLineOperation:
		((_ns1__removeLineOperation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__addLineOperationResponse:
		((_ns1__addLineOperationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__addLineOperation:
		((_ns1__addLineOperation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__editLcuOperationResponse:
		((_ns1__editLcuOperationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__editLcuOperation:
		((_ns1__editLcuOperation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__removeLcuOperationResponse:
		((_ns1__removeLcuOperationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__removeLcuOperation:
		((_ns1__removeLcuOperation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__addLcuOperationResponse:
		((_ns1__addLcuOperationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__addLcuOperation:
		((_ns1__addLcuOperation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__editDcuOperationResponse:
		((_ns1__editDcuOperationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__editDcuOperation:
		((_ns1__editDcuOperation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__removeDcuOperationResponse:
		((_ns1__removeDcuOperationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__removeDcuOperation:
		((_ns1__removeDcuOperation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__addDcuOperationResponse:
		((_ns1__addDcuOperationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__addDcuOperation:
		((_ns1__addDcuOperation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getLineListOperationResponse:
		((_ns1__getLineListOperationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getLineListOperation:
		((_ns1__getLineListOperation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__updateRuntimeForUserOperationResponse:
		((_ns1__updateRuntimeForUserOperationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__updateRuntimeForUserOperation:
		((_ns1__updateRuntimeForUserOperation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getLcuListOperationResponse:
		((_ns1__getLcuListOperationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getLcuListOperation:
		((_ns1__getLcuListOperation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getDcuListOperationResponse:
		((_ns1__getDcuListOperationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getDcuListOperation:
		((_ns1__getDcuListOperation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__LogoutOperationResponse:
		((_ns1__LogoutOperationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__LogoutOperation:
		((_ns1__LogoutOperation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__LoginPcOperationResponse:
		((_ns1__LoginPcOperationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__LoginPcOperation:
		((_ns1__LoginPcOperation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__LoginOperationResponse:
		((_ns1__LoginOperationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__LoginOperation:
		((_ns1__LoginOperation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SCHEDULE_USCOREINFO_USCOREType:
		((ns1__SCHEDULE_USCOREINFO_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__LISTSCHEDULE_USCOREINFO_USCOREType:
		((ns1__LISTSCHEDULE_USCOREINFO_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__DAYSCHEDULE_USCOREINFO_USCOREType:
		((ns1__DAYSCHEDULE_USCOREINFO_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__PROGRAM_USCOREINFO_USCOREType:
		((ns1__PROGRAM_USCOREINFO_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__USER_USCOREINFO_USCOREType:
		((ns1__USER_USCOREINFO_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ZONE_USCOREINFO_USCOREType:
		((ns1__ZONE_USCOREINFO_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__USER_USCORELOG_USCOREINFO_USCOREType:
		((ns1__USER_USCORELOG_USCOREINFO_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__EVENT_USCORELOG_USCOREINFO_USCOREType:
		((ns1__EVENT_USCORELOG_USCOREINFO_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__LINE_USCOREINFO_USCOREType:
		((ns1__LINE_USCOREINFO_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__LCULOGINFOType:
		((ns1__LCULOGINFOType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__LCU_USCOREINFO_USCOREType:
		((ns1__LCU_USCOREINFO_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__DCU_USCOREINFO_USCOREType:
		((ns1__DCU_USCOREINFO_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType:
		((ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns1__getLcuLogOperation:
		soap_serialize___ns1__getLcuLogOperation(soap, (const struct __ns1__getLcuLogOperation *)ptr);
		break;
	case SOAP_TYPE___ns1__removeScheduleOperation:
		soap_serialize___ns1__removeScheduleOperation(soap, (const struct __ns1__removeScheduleOperation *)ptr);
		break;
	case SOAP_TYPE___ns1__editScheduleOperation:
		soap_serialize___ns1__editScheduleOperation(soap, (const struct __ns1__editScheduleOperation *)ptr);
		break;
	case SOAP_TYPE___ns1__addScheduleOperation:
		soap_serialize___ns1__addScheduleOperation(soap, (const struct __ns1__addScheduleOperation *)ptr);
		break;
	case SOAP_TYPE___ns1__getScheduleOperation:
		soap_serialize___ns1__getScheduleOperation(soap, (const struct __ns1__getScheduleOperation *)ptr);
		break;
	case SOAP_TYPE___ns1__removeListScheduleOperation:
		soap_serialize___ns1__removeListScheduleOperation(soap, (const struct __ns1__removeListScheduleOperation *)ptr);
		break;
	case SOAP_TYPE___ns1__editListScheduleOperation:
		soap_serialize___ns1__editListScheduleOperation(soap, (const struct __ns1__editListScheduleOperation *)ptr);
		break;
	case SOAP_TYPE___ns1__addListScheduleOperation:
		soap_serialize___ns1__addListScheduleOperation(soap, (const struct __ns1__addListScheduleOperation *)ptr);
		break;
	case SOAP_TYPE___ns1__getListScheduleOperation:
		soap_serialize___ns1__getListScheduleOperation(soap, (const struct __ns1__getListScheduleOperation *)ptr);
		break;
	case SOAP_TYPE___ns1__addDayScheduleOperation:
		soap_serialize___ns1__addDayScheduleOperation(soap, (const struct __ns1__addDayScheduleOperation *)ptr);
		break;
	case SOAP_TYPE___ns1__removeDayScheduleOperation:
		soap_serialize___ns1__removeDayScheduleOperation(soap, (const struct __ns1__removeDayScheduleOperation *)ptr);
		break;
	case SOAP_TYPE___ns1__editDayScheduleOperation:
		soap_serialize___ns1__editDayScheduleOperation(soap, (const struct __ns1__editDayScheduleOperation *)ptr);
		break;
	case SOAP_TYPE___ns1__getDayScheduleOperation:
		soap_serialize___ns1__getDayScheduleOperation(soap, (const struct __ns1__getDayScheduleOperation *)ptr);
		break;
	case SOAP_TYPE___ns1__editProgramOperation:
		soap_serialize___ns1__editProgramOperation(soap, (const struct __ns1__editProgramOperation *)ptr);
		break;
	case SOAP_TYPE___ns1__getProgramOperation:
		soap_serialize___ns1__getProgramOperation(soap, (const struct __ns1__getProgramOperation *)ptr);
		break;
	case SOAP_TYPE___ns1__editUserByUserOperation:
		soap_serialize___ns1__editUserByUserOperation(soap, (const struct __ns1__editUserByUserOperation *)ptr);
		break;
	case SOAP_TYPE___ns1__removeUserOperation:
		soap_serialize___ns1__removeUserOperation(soap, (const struct __ns1__removeUserOperation *)ptr);
		break;
	case SOAP_TYPE___ns1__editUserOperation:
		soap_serialize___ns1__editUserOperation(soap, (const struct __ns1__editUserOperation *)ptr);
		break;
	case SOAP_TYPE___ns1__addUserOperation:
		soap_serialize___ns1__addUserOperation(soap, (const struct __ns1__addUserOperation *)ptr);
		break;
	case SOAP_TYPE___ns1__getAllUserOperation:
		soap_serialize___ns1__getAllUserOperation(soap, (const struct __ns1__getAllUserOperation *)ptr);
		break;
	case SOAP_TYPE___ns1__removeZoneOperation:
		soap_serialize___ns1__removeZoneOperation(soap, (const struct __ns1__removeZoneOperation *)ptr);
		break;
	case SOAP_TYPE___ns1__editZoneOperation:
		soap_serialize___ns1__editZoneOperation(soap, (const struct __ns1__editZoneOperation *)ptr);
		break;
	case SOAP_TYPE___ns1__addZoneOperation:
		soap_serialize___ns1__addZoneOperation(soap, (const struct __ns1__addZoneOperation *)ptr);
		break;
	case SOAP_TYPE___ns1__SetDcuToZoneOperation:
		soap_serialize___ns1__SetDcuToZoneOperation(soap, (const struct __ns1__SetDcuToZoneOperation *)ptr);
		break;
	case SOAP_TYPE___ns1__getAllZoneForUserOperation:
		soap_serialize___ns1__getAllZoneForUserOperation(soap, (const struct __ns1__getAllZoneForUserOperation *)ptr);
		break;
	case SOAP_TYPE___ns1__getAllZoneOperation:
		soap_serialize___ns1__getAllZoneOperation(soap, (const struct __ns1__getAllZoneOperation *)ptr);
		break;
	case SOAP_TYPE___ns1__deleteUserLogOperation:
		soap_serialize___ns1__deleteUserLogOperation(soap, (const struct __ns1__deleteUserLogOperation *)ptr);
		break;
	case SOAP_TYPE___ns1__getUserLogOperation:
		soap_serialize___ns1__getUserLogOperation(soap, (const struct __ns1__getUserLogOperation *)ptr);
		break;
	case SOAP_TYPE___ns1__deleteEventLogOperation:
		soap_serialize___ns1__deleteEventLogOperation(soap, (const struct __ns1__deleteEventLogOperation *)ptr);
		break;
	case SOAP_TYPE___ns1__updateReadEventLogOperation:
		soap_serialize___ns1__updateReadEventLogOperation(soap, (const struct __ns1__updateReadEventLogOperation *)ptr);
		break;
	case SOAP_TYPE___ns1__getEventLogOperation:
		soap_serialize___ns1__getEventLogOperation(soap, (const struct __ns1__getEventLogOperation *)ptr);
		break;
	case SOAP_TYPE___ns1__setProgramDcuOperation:
		soap_serialize___ns1__setProgramDcuOperation(soap, (const struct __ns1__setProgramDcuOperation *)ptr);
		break;
	case SOAP_TYPE___ns1__controlLineOperation:
		soap_serialize___ns1__controlLineOperation(soap, (const struct __ns1__controlLineOperation *)ptr);
		break;
	case SOAP_TYPE___ns1__controlLcuOperation:
		soap_serialize___ns1__controlLcuOperation(soap, (const struct __ns1__controlLcuOperation *)ptr);
		break;
	case SOAP_TYPE___ns1__removeProgramOperation:
		soap_serialize___ns1__removeProgramOperation(soap, (const struct __ns1__removeProgramOperation *)ptr);
		break;
	case SOAP_TYPE___ns1__addProgramOperation:
		soap_serialize___ns1__addProgramOperation(soap, (const struct __ns1__addProgramOperation *)ptr);
		break;
	case SOAP_TYPE___ns1__editLineOperation:
		soap_serialize___ns1__editLineOperation(soap, (const struct __ns1__editLineOperation *)ptr);
		break;
	case SOAP_TYPE___ns1__removeLineOperation:
		soap_serialize___ns1__removeLineOperation(soap, (const struct __ns1__removeLineOperation *)ptr);
		break;
	case SOAP_TYPE___ns1__addLineOperation:
		soap_serialize___ns1__addLineOperation(soap, (const struct __ns1__addLineOperation *)ptr);
		break;
	case SOAP_TYPE___ns1__editLcuOperation:
		soap_serialize___ns1__editLcuOperation(soap, (const struct __ns1__editLcuOperation *)ptr);
		break;
	case SOAP_TYPE___ns1__removeLcuOperation:
		soap_serialize___ns1__removeLcuOperation(soap, (const struct __ns1__removeLcuOperation *)ptr);
		break;
	case SOAP_TYPE___ns1__addLcuOperation:
		soap_serialize___ns1__addLcuOperation(soap, (const struct __ns1__addLcuOperation *)ptr);
		break;
	case SOAP_TYPE___ns1__editDcuOperation:
		soap_serialize___ns1__editDcuOperation(soap, (const struct __ns1__editDcuOperation *)ptr);
		break;
	case SOAP_TYPE___ns1__removeDcuOperation:
		soap_serialize___ns1__removeDcuOperation(soap, (const struct __ns1__removeDcuOperation *)ptr);
		break;
	case SOAP_TYPE___ns1__addDcuOperation:
		soap_serialize___ns1__addDcuOperation(soap, (const struct __ns1__addDcuOperation *)ptr);
		break;
	case SOAP_TYPE___ns1__getLineListOperation:
		soap_serialize___ns1__getLineListOperation(soap, (const struct __ns1__getLineListOperation *)ptr);
		break;
	case SOAP_TYPE___ns1__updateRuntimeForUserOperation:
		soap_serialize___ns1__updateRuntimeForUserOperation(soap, (const struct __ns1__updateRuntimeForUserOperation *)ptr);
		break;
	case SOAP_TYPE___ns1__getLcuListOperation:
		soap_serialize___ns1__getLcuListOperation(soap, (const struct __ns1__getLcuListOperation *)ptr);
		break;
	case SOAP_TYPE___ns1__getDcuListOperation:
		soap_serialize___ns1__getDcuListOperation(soap, (const struct __ns1__getDcuListOperation *)ptr);
		break;
	case SOAP_TYPE___ns1__LogoutOperation:
		soap_serialize___ns1__LogoutOperation(soap, (const struct __ns1__LogoutOperation *)ptr);
		break;
	case SOAP_TYPE___ns1__LoginPcOperation:
		soap_serialize___ns1__LoginPcOperation(soap, (const struct __ns1__LoginPcOperation *)ptr);
		break;
	case SOAP_TYPE___ns1__LoginOperation:
		soap_serialize___ns1__LoginOperation(soap, (const struct __ns1__LoginOperation *)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getLcuLogOperationResponse:
		soap_serialize_PointerTo_ns1__getLcuLogOperationResponse(soap, (_ns1__getLcuLogOperationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getLcuLogOperation:
		soap_serialize_PointerTo_ns1__getLcuLogOperation(soap, (_ns1__getLcuLogOperation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__removeScheduleOperationResponse:
		soap_serialize_PointerTo_ns1__removeScheduleOperationResponse(soap, (_ns1__removeScheduleOperationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__removeScheduleOperation:
		soap_serialize_PointerTo_ns1__removeScheduleOperation(soap, (_ns1__removeScheduleOperation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__editScheduleOperationResponse:
		soap_serialize_PointerTo_ns1__editScheduleOperationResponse(soap, (_ns1__editScheduleOperationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__editScheduleOperation:
		soap_serialize_PointerTo_ns1__editScheduleOperation(soap, (_ns1__editScheduleOperation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__addScheduleOperationResponse:
		soap_serialize_PointerTo_ns1__addScheduleOperationResponse(soap, (_ns1__addScheduleOperationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__addScheduleOperation:
		soap_serialize_PointerTo_ns1__addScheduleOperation(soap, (_ns1__addScheduleOperation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getScheduleOperationResponse:
		soap_serialize_PointerTo_ns1__getScheduleOperationResponse(soap, (_ns1__getScheduleOperationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getScheduleOperation:
		soap_serialize_PointerTo_ns1__getScheduleOperation(soap, (_ns1__getScheduleOperation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__removeListScheduleOperationResponse:
		soap_serialize_PointerTo_ns1__removeListScheduleOperationResponse(soap, (_ns1__removeListScheduleOperationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__removeListScheduleOperation:
		soap_serialize_PointerTo_ns1__removeListScheduleOperation(soap, (_ns1__removeListScheduleOperation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__editListScheduleOperationResponse:
		soap_serialize_PointerTo_ns1__editListScheduleOperationResponse(soap, (_ns1__editListScheduleOperationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__editListScheduleOperation:
		soap_serialize_PointerTo_ns1__editListScheduleOperation(soap, (_ns1__editListScheduleOperation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__addListScheduleOperationResponse:
		soap_serialize_PointerTo_ns1__addListScheduleOperationResponse(soap, (_ns1__addListScheduleOperationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__addListScheduleOperation:
		soap_serialize_PointerTo_ns1__addListScheduleOperation(soap, (_ns1__addListScheduleOperation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getListScheduleOperationResponse:
		soap_serialize_PointerTo_ns1__getListScheduleOperationResponse(soap, (_ns1__getListScheduleOperationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getListScheduleOperation:
		soap_serialize_PointerTo_ns1__getListScheduleOperation(soap, (_ns1__getListScheduleOperation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__addDayScheduleOperationResponse:
		soap_serialize_PointerTo_ns1__addDayScheduleOperationResponse(soap, (_ns1__addDayScheduleOperationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__addDayScheduleOperation:
		soap_serialize_PointerTo_ns1__addDayScheduleOperation(soap, (_ns1__addDayScheduleOperation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__removeDayScheduleOperationResponse:
		soap_serialize_PointerTo_ns1__removeDayScheduleOperationResponse(soap, (_ns1__removeDayScheduleOperationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__removeDayScheduleOperation:
		soap_serialize_PointerTo_ns1__removeDayScheduleOperation(soap, (_ns1__removeDayScheduleOperation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__editDayScheduleOperationResponse:
		soap_serialize_PointerTo_ns1__editDayScheduleOperationResponse(soap, (_ns1__editDayScheduleOperationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__editDayScheduleOperation:
		soap_serialize_PointerTo_ns1__editDayScheduleOperation(soap, (_ns1__editDayScheduleOperation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getDayScheduleOperationResponse:
		soap_serialize_PointerTo_ns1__getDayScheduleOperationResponse(soap, (_ns1__getDayScheduleOperationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getDayScheduleOperation:
		soap_serialize_PointerTo_ns1__getDayScheduleOperation(soap, (_ns1__getDayScheduleOperation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__editProgramOperationResponse:
		soap_serialize_PointerTo_ns1__editProgramOperationResponse(soap, (_ns1__editProgramOperationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__editProgramOperation:
		soap_serialize_PointerTo_ns1__editProgramOperation(soap, (_ns1__editProgramOperation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getProgramOperationResponse:
		soap_serialize_PointerTo_ns1__getProgramOperationResponse(soap, (_ns1__getProgramOperationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getProgramOperation:
		soap_serialize_PointerTo_ns1__getProgramOperation(soap, (_ns1__getProgramOperation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__editUserByUserOperationResponse:
		soap_serialize_PointerTo_ns1__editUserByUserOperationResponse(soap, (_ns1__editUserByUserOperationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__editUserByUserOperation:
		soap_serialize_PointerTo_ns1__editUserByUserOperation(soap, (_ns1__editUserByUserOperation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__removeUserOperationResponse:
		soap_serialize_PointerTo_ns1__removeUserOperationResponse(soap, (_ns1__removeUserOperationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__removeUserOperation:
		soap_serialize_PointerTo_ns1__removeUserOperation(soap, (_ns1__removeUserOperation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__editUserOperationResponse:
		soap_serialize_PointerTo_ns1__editUserOperationResponse(soap, (_ns1__editUserOperationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__editUserOperation:
		soap_serialize_PointerTo_ns1__editUserOperation(soap, (_ns1__editUserOperation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__addUserOperationResponse:
		soap_serialize_PointerTo_ns1__addUserOperationResponse(soap, (_ns1__addUserOperationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__addUserOperation:
		soap_serialize_PointerTo_ns1__addUserOperation(soap, (_ns1__addUserOperation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getAllUserOperationResponse:
		soap_serialize_PointerTo_ns1__getAllUserOperationResponse(soap, (_ns1__getAllUserOperationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getAllUserOperation:
		soap_serialize_PointerTo_ns1__getAllUserOperation(soap, (_ns1__getAllUserOperation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__removeZoneOperationResponse:
		soap_serialize_PointerTo_ns1__removeZoneOperationResponse(soap, (_ns1__removeZoneOperationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__removeZoneOperation:
		soap_serialize_PointerTo_ns1__removeZoneOperation(soap, (_ns1__removeZoneOperation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__editZoneOperationResponse:
		soap_serialize_PointerTo_ns1__editZoneOperationResponse(soap, (_ns1__editZoneOperationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__editZoneOperation:
		soap_serialize_PointerTo_ns1__editZoneOperation(soap, (_ns1__editZoneOperation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__addZoneOperationResponse:
		soap_serialize_PointerTo_ns1__addZoneOperationResponse(soap, (_ns1__addZoneOperationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__addZoneOperation:
		soap_serialize_PointerTo_ns1__addZoneOperation(soap, (_ns1__addZoneOperation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SetDcuToZoneOperationResponse:
		soap_serialize_PointerTo_ns1__SetDcuToZoneOperationResponse(soap, (_ns1__SetDcuToZoneOperationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SetDcuToZoneOperation:
		soap_serialize_PointerTo_ns1__SetDcuToZoneOperation(soap, (_ns1__SetDcuToZoneOperation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getAllZoneForUserOperationResponse:
		soap_serialize_PointerTo_ns1__getAllZoneForUserOperationResponse(soap, (_ns1__getAllZoneForUserOperationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getAllZoneForUserOperation:
		soap_serialize_PointerTo_ns1__getAllZoneForUserOperation(soap, (_ns1__getAllZoneForUserOperation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getAllZoneOperationResponse:
		soap_serialize_PointerTo_ns1__getAllZoneOperationResponse(soap, (_ns1__getAllZoneOperationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getAllZoneOperation:
		soap_serialize_PointerTo_ns1__getAllZoneOperation(soap, (_ns1__getAllZoneOperation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__deleteUserLogOperationResponse:
		soap_serialize_PointerTo_ns1__deleteUserLogOperationResponse(soap, (_ns1__deleteUserLogOperationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__deleteUserLogOperation:
		soap_serialize_PointerTo_ns1__deleteUserLogOperation(soap, (_ns1__deleteUserLogOperation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getUserLogOperationResponse:
		soap_serialize_PointerTo_ns1__getUserLogOperationResponse(soap, (_ns1__getUserLogOperationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getUserLogOperation:
		soap_serialize_PointerTo_ns1__getUserLogOperation(soap, (_ns1__getUserLogOperation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__deleteEventLogOperationResponse:
		soap_serialize_PointerTo_ns1__deleteEventLogOperationResponse(soap, (_ns1__deleteEventLogOperationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__deleteEventLogOperation:
		soap_serialize_PointerTo_ns1__deleteEventLogOperation(soap, (_ns1__deleteEventLogOperation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__updateReadEventLogOperationResponse:
		soap_serialize_PointerTo_ns1__updateReadEventLogOperationResponse(soap, (_ns1__updateReadEventLogOperationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__updateReadEventLogOperation:
		soap_serialize_PointerTo_ns1__updateReadEventLogOperation(soap, (_ns1__updateReadEventLogOperation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getEventLogOperationResponse:
		soap_serialize_PointerTo_ns1__getEventLogOperationResponse(soap, (_ns1__getEventLogOperationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getEventLogOperation:
		soap_serialize_PointerTo_ns1__getEventLogOperation(soap, (_ns1__getEventLogOperation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__setProgramDcuOperationResponse:
		soap_serialize_PointerTo_ns1__setProgramDcuOperationResponse(soap, (_ns1__setProgramDcuOperationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__setProgramDcuOperation:
		soap_serialize_PointerTo_ns1__setProgramDcuOperation(soap, (_ns1__setProgramDcuOperation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__controlLineOperationResponse:
		soap_serialize_PointerTo_ns1__controlLineOperationResponse(soap, (_ns1__controlLineOperationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__controlLineOperation:
		soap_serialize_PointerTo_ns1__controlLineOperation(soap, (_ns1__controlLineOperation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__controlLcuOperationResponse:
		soap_serialize_PointerTo_ns1__controlLcuOperationResponse(soap, (_ns1__controlLcuOperationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__controlLcuOperation:
		soap_serialize_PointerTo_ns1__controlLcuOperation(soap, (_ns1__controlLcuOperation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__removeProgramOperationResponse:
		soap_serialize_PointerTo_ns1__removeProgramOperationResponse(soap, (_ns1__removeProgramOperationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__removeProgramOperation:
		soap_serialize_PointerTo_ns1__removeProgramOperation(soap, (_ns1__removeProgramOperation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__addProgramOperationResponse:
		soap_serialize_PointerTo_ns1__addProgramOperationResponse(soap, (_ns1__addProgramOperationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__addProgramOperation:
		soap_serialize_PointerTo_ns1__addProgramOperation(soap, (_ns1__addProgramOperation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__editLineOperationResponse:
		soap_serialize_PointerTo_ns1__editLineOperationResponse(soap, (_ns1__editLineOperationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__editLineOperation:
		soap_serialize_PointerTo_ns1__editLineOperation(soap, (_ns1__editLineOperation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__removeLineOperationResponse:
		soap_serialize_PointerTo_ns1__removeLineOperationResponse(soap, (_ns1__removeLineOperationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__removeLineOperation:
		soap_serialize_PointerTo_ns1__removeLineOperation(soap, (_ns1__removeLineOperation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__addLineOperationResponse:
		soap_serialize_PointerTo_ns1__addLineOperationResponse(soap, (_ns1__addLineOperationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__addLineOperation:
		soap_serialize_PointerTo_ns1__addLineOperation(soap, (_ns1__addLineOperation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__editLcuOperationResponse:
		soap_serialize_PointerTo_ns1__editLcuOperationResponse(soap, (_ns1__editLcuOperationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__editLcuOperation:
		soap_serialize_PointerTo_ns1__editLcuOperation(soap, (_ns1__editLcuOperation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__removeLcuOperationResponse:
		soap_serialize_PointerTo_ns1__removeLcuOperationResponse(soap, (_ns1__removeLcuOperationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__removeLcuOperation:
		soap_serialize_PointerTo_ns1__removeLcuOperation(soap, (_ns1__removeLcuOperation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__addLcuOperationResponse:
		soap_serialize_PointerTo_ns1__addLcuOperationResponse(soap, (_ns1__addLcuOperationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__addLcuOperation:
		soap_serialize_PointerTo_ns1__addLcuOperation(soap, (_ns1__addLcuOperation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__editDcuOperationResponse:
		soap_serialize_PointerTo_ns1__editDcuOperationResponse(soap, (_ns1__editDcuOperationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__editDcuOperation:
		soap_serialize_PointerTo_ns1__editDcuOperation(soap, (_ns1__editDcuOperation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__removeDcuOperationResponse:
		soap_serialize_PointerTo_ns1__removeDcuOperationResponse(soap, (_ns1__removeDcuOperationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__removeDcuOperation:
		soap_serialize_PointerTo_ns1__removeDcuOperation(soap, (_ns1__removeDcuOperation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__addDcuOperationResponse:
		soap_serialize_PointerTo_ns1__addDcuOperationResponse(soap, (_ns1__addDcuOperationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__addDcuOperation:
		soap_serialize_PointerTo_ns1__addDcuOperation(soap, (_ns1__addDcuOperation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getLineListOperationResponse:
		soap_serialize_PointerTo_ns1__getLineListOperationResponse(soap, (_ns1__getLineListOperationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getLineListOperation:
		soap_serialize_PointerTo_ns1__getLineListOperation(soap, (_ns1__getLineListOperation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__updateRuntimeForUserOperationResponse:
		soap_serialize_PointerTo_ns1__updateRuntimeForUserOperationResponse(soap, (_ns1__updateRuntimeForUserOperationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__updateRuntimeForUserOperation:
		soap_serialize_PointerTo_ns1__updateRuntimeForUserOperation(soap, (_ns1__updateRuntimeForUserOperation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getLcuListOperationResponse:
		soap_serialize_PointerTo_ns1__getLcuListOperationResponse(soap, (_ns1__getLcuListOperationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getLcuListOperation:
		soap_serialize_PointerTo_ns1__getLcuListOperation(soap, (_ns1__getLcuListOperation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getDcuListOperationResponse:
		soap_serialize_PointerTo_ns1__getDcuListOperationResponse(soap, (_ns1__getDcuListOperationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getDcuListOperation:
		soap_serialize_PointerTo_ns1__getDcuListOperation(soap, (_ns1__getDcuListOperation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__LogoutOperationResponse:
		soap_serialize_PointerTo_ns1__LogoutOperationResponse(soap, (_ns1__LogoutOperationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__LogoutOperation:
		soap_serialize_PointerTo_ns1__LogoutOperation(soap, (_ns1__LogoutOperation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__LoginPcOperationResponse:
		soap_serialize_PointerTo_ns1__LoginPcOperationResponse(soap, (_ns1__LoginPcOperationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__LoginPcOperation:
		soap_serialize_PointerTo_ns1__LoginPcOperation(soap, (_ns1__LoginPcOperation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__LoginOperationResponse:
		soap_serialize_PointerTo_ns1__LoginOperationResponse(soap, (_ns1__LoginOperationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__LoginOperation:
		soap_serialize_PointerTo_ns1__LoginOperation(soap, (_ns1__LoginOperation *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__LCULOGINFOType:
		soap_serialize_PointerToPointerTons1__LCULOGINFOType(soap, (ns1__LCULOGINFOType **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__LCULOGINFOType:
		soap_serialize_PointerTons1__LCULOGINFOType(soap, (ns1__LCULOGINFOType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__LISTSCHEDULE_USCOREINFO_USCOREType:
		soap_serialize_PointerToPointerTons1__LISTSCHEDULE_USCOREINFO_USCOREType(soap, (ns1__LISTSCHEDULE_USCOREINFO_USCOREType **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__LISTSCHEDULE_USCOREINFO_USCOREType:
		soap_serialize_PointerTons1__LISTSCHEDULE_USCOREINFO_USCOREType(soap, (ns1__LISTSCHEDULE_USCOREINFO_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__DAYSCHEDULE_USCOREINFO_USCOREType:
		soap_serialize_PointerToPointerTons1__DAYSCHEDULE_USCOREINFO_USCOREType(soap, (ns1__DAYSCHEDULE_USCOREINFO_USCOREType **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__DAYSCHEDULE_USCOREINFO_USCOREType:
		soap_serialize_PointerTons1__DAYSCHEDULE_USCOREINFO_USCOREType(soap, (ns1__DAYSCHEDULE_USCOREINFO_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__PROGRAM_USCOREINFO_USCOREType:
		soap_serialize_PointerToPointerTons1__PROGRAM_USCOREINFO_USCOREType(soap, (ns1__PROGRAM_USCOREINFO_USCOREType **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__PROGRAM_USCOREINFO_USCOREType:
		soap_serialize_PointerTons1__PROGRAM_USCOREINFO_USCOREType(soap, (ns1__PROGRAM_USCOREINFO_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__USER_USCOREINFO_USCOREType:
		soap_serialize_PointerToPointerTons1__USER_USCOREINFO_USCOREType(soap, (ns1__USER_USCOREINFO_USCOREType **const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__USER_USCORELOG_USCOREINFO_USCOREType:
		soap_serialize_PointerToPointerTons1__USER_USCORELOG_USCOREINFO_USCOREType(soap, (ns1__USER_USCORELOG_USCOREINFO_USCOREType **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__USER_USCORELOG_USCOREINFO_USCOREType:
		soap_serialize_PointerTons1__USER_USCORELOG_USCOREINFO_USCOREType(soap, (ns1__USER_USCORELOG_USCOREINFO_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__LINE_USCOREINFO_USCOREType:
		soap_serialize_PointerToPointerTons1__LINE_USCOREINFO_USCOREType(soap, (ns1__LINE_USCOREINFO_USCOREType **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__LINE_USCOREINFO_USCOREType:
		soap_serialize_PointerTons1__LINE_USCOREINFO_USCOREType(soap, (ns1__LINE_USCOREINFO_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__EVENT_USCORELOG_USCOREINFO_USCOREType:
		soap_serialize_PointerToPointerTons1__EVENT_USCORELOG_USCOREINFO_USCOREType(soap, (ns1__EVENT_USCORELOG_USCOREINFO_USCOREType **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__EVENT_USCORELOG_USCOREINFO_USCOREType:
		soap_serialize_PointerTons1__EVENT_USCORELOG_USCOREINFO_USCOREType(soap, (ns1__EVENT_USCORELOG_USCOREINFO_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__LCU_USCOREINFO_USCOREType:
		soap_serialize_PointerToPointerTons1__LCU_USCOREINFO_USCOREType(soap, (ns1__LCU_USCOREINFO_USCOREType **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__LCU_USCOREINFO_USCOREType:
		soap_serialize_PointerTons1__LCU_USCOREINFO_USCOREType(soap, (ns1__LCU_USCOREINFO_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__DCU_USCOREINFO_USCOREType:
		soap_serialize_PointerToPointerTons1__DCU_USCOREINFO_USCOREType(soap, (ns1__DCU_USCOREINFO_USCOREType **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__DCU_USCOREINFO_USCOREType:
		soap_serialize_PointerTons1__DCU_USCOREINFO_USCOREType(soap, (ns1__DCU_USCOREINFO_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType:
		soap_serialize_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, (ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__USER_USCOREINFO_USCOREType:
		soap_serialize_PointerTons1__USER_USCOREINFO_USCOREType(soap, (ns1__USER_USCOREINFO_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__SCHEDULE_USCOREINFO_USCOREType:
		soap_serialize_PointerToPointerTons1__SCHEDULE_USCOREINFO_USCOREType(soap, (ns1__SCHEDULE_USCOREINFO_USCOREType **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SCHEDULE_USCOREINFO_USCOREType:
		soap_serialize_PointerTons1__SCHEDULE_USCOREINFO_USCOREType(soap, (ns1__SCHEDULE_USCOREINFO_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__ZONE_USCOREINFO_USCOREType:
		soap_serialize_PointerToPointerTons1__ZONE_USCOREINFO_USCOREType(soap, (ns1__ZONE_USCOREINFO_USCOREType **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ZONE_USCOREINFO_USCOREType:
		soap_serialize_PointerTons1__ZONE_USCOREINFO_USCOREType(soap, (ns1__ZONE_USCOREINFO_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType:
		return (void*)soap_instantiate_ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DCU_USCOREINFO_USCOREType:
		return (void*)soap_instantiate_ns1__DCU_USCOREINFO_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__LCU_USCOREINFO_USCOREType:
		return (void*)soap_instantiate_ns1__LCU_USCOREINFO_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__LCULOGINFOType:
		return (void*)soap_instantiate_ns1__LCULOGINFOType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__LINE_USCOREINFO_USCOREType:
		return (void*)soap_instantiate_ns1__LINE_USCOREINFO_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__EVENT_USCORELOG_USCOREINFO_USCOREType:
		return (void*)soap_instantiate_ns1__EVENT_USCORELOG_USCOREINFO_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__USER_USCORELOG_USCOREINFO_USCOREType:
		return (void*)soap_instantiate_ns1__USER_USCORELOG_USCOREINFO_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ZONE_USCOREINFO_USCOREType:
		return (void*)soap_instantiate_ns1__ZONE_USCOREINFO_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__USER_USCOREINFO_USCOREType:
		return (void*)soap_instantiate_ns1__USER_USCOREINFO_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__PROGRAM_USCOREINFO_USCOREType:
		return (void*)soap_instantiate_ns1__PROGRAM_USCOREINFO_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DAYSCHEDULE_USCOREINFO_USCOREType:
		return (void*)soap_instantiate_ns1__DAYSCHEDULE_USCOREINFO_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__LISTSCHEDULE_USCOREINFO_USCOREType:
		return (void*)soap_instantiate_ns1__LISTSCHEDULE_USCOREINFO_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SCHEDULE_USCOREINFO_USCOREType:
		return (void*)soap_instantiate_ns1__SCHEDULE_USCOREINFO_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__LoginOperation:
		return (void*)soap_instantiate__ns1__LoginOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__LoginOperationResponse:
		return (void*)soap_instantiate__ns1__LoginOperationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__LoginPcOperation:
		return (void*)soap_instantiate__ns1__LoginPcOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__LoginPcOperationResponse:
		return (void*)soap_instantiate__ns1__LoginPcOperationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__LogoutOperation:
		return (void*)soap_instantiate__ns1__LogoutOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__LogoutOperationResponse:
		return (void*)soap_instantiate__ns1__LogoutOperationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getDcuListOperation:
		return (void*)soap_instantiate__ns1__getDcuListOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getDcuListOperationResponse:
		return (void*)soap_instantiate__ns1__getDcuListOperationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getLcuListOperation:
		return (void*)soap_instantiate__ns1__getLcuListOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getLcuListOperationResponse:
		return (void*)soap_instantiate__ns1__getLcuListOperationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__updateRuntimeForUserOperation:
		return (void*)soap_instantiate__ns1__updateRuntimeForUserOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__updateRuntimeForUserOperationResponse:
		return (void*)soap_instantiate__ns1__updateRuntimeForUserOperationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getLineListOperation:
		return (void*)soap_instantiate__ns1__getLineListOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getLineListOperationResponse:
		return (void*)soap_instantiate__ns1__getLineListOperationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__addDcuOperation:
		return (void*)soap_instantiate__ns1__addDcuOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__addDcuOperationResponse:
		return (void*)soap_instantiate__ns1__addDcuOperationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__removeDcuOperation:
		return (void*)soap_instantiate__ns1__removeDcuOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__removeDcuOperationResponse:
		return (void*)soap_instantiate__ns1__removeDcuOperationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__editDcuOperation:
		return (void*)soap_instantiate__ns1__editDcuOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__editDcuOperationResponse:
		return (void*)soap_instantiate__ns1__editDcuOperationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__addLcuOperation:
		return (void*)soap_instantiate__ns1__addLcuOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__addLcuOperationResponse:
		return (void*)soap_instantiate__ns1__addLcuOperationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__removeLcuOperation:
		return (void*)soap_instantiate__ns1__removeLcuOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__removeLcuOperationResponse:
		return (void*)soap_instantiate__ns1__removeLcuOperationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__editLcuOperation:
		return (void*)soap_instantiate__ns1__editLcuOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__editLcuOperationResponse:
		return (void*)soap_instantiate__ns1__editLcuOperationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__addLineOperation:
		return (void*)soap_instantiate__ns1__addLineOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__addLineOperationResponse:
		return (void*)soap_instantiate__ns1__addLineOperationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__removeLineOperation:
		return (void*)soap_instantiate__ns1__removeLineOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__removeLineOperationResponse:
		return (void*)soap_instantiate__ns1__removeLineOperationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__editLineOperation:
		return (void*)soap_instantiate__ns1__editLineOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__editLineOperationResponse:
		return (void*)soap_instantiate__ns1__editLineOperationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__addProgramOperation:
		return (void*)soap_instantiate__ns1__addProgramOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__addProgramOperationResponse:
		return (void*)soap_instantiate__ns1__addProgramOperationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__removeProgramOperation:
		return (void*)soap_instantiate__ns1__removeProgramOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__removeProgramOperationResponse:
		return (void*)soap_instantiate__ns1__removeProgramOperationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__controlLcuOperation:
		return (void*)soap_instantiate__ns1__controlLcuOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__controlLcuOperationResponse:
		return (void*)soap_instantiate__ns1__controlLcuOperationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__controlLineOperation:
		return (void*)soap_instantiate__ns1__controlLineOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__controlLineOperationResponse:
		return (void*)soap_instantiate__ns1__controlLineOperationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__setProgramDcuOperation:
		return (void*)soap_instantiate__ns1__setProgramDcuOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__setProgramDcuOperationResponse:
		return (void*)soap_instantiate__ns1__setProgramDcuOperationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getEventLogOperation:
		return (void*)soap_instantiate__ns1__getEventLogOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getEventLogOperationResponse:
		return (void*)soap_instantiate__ns1__getEventLogOperationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__updateReadEventLogOperation:
		return (void*)soap_instantiate__ns1__updateReadEventLogOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__updateReadEventLogOperationResponse:
		return (void*)soap_instantiate__ns1__updateReadEventLogOperationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__deleteEventLogOperation:
		return (void*)soap_instantiate__ns1__deleteEventLogOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__deleteEventLogOperationResponse:
		return (void*)soap_instantiate__ns1__deleteEventLogOperationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getUserLogOperation:
		return (void*)soap_instantiate__ns1__getUserLogOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getUserLogOperationResponse:
		return (void*)soap_instantiate__ns1__getUserLogOperationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__deleteUserLogOperation:
		return (void*)soap_instantiate__ns1__deleteUserLogOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__deleteUserLogOperationResponse:
		return (void*)soap_instantiate__ns1__deleteUserLogOperationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getAllZoneOperation:
		return (void*)soap_instantiate__ns1__getAllZoneOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getAllZoneOperationResponse:
		return (void*)soap_instantiate__ns1__getAllZoneOperationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getAllZoneForUserOperation:
		return (void*)soap_instantiate__ns1__getAllZoneForUserOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getAllZoneForUserOperationResponse:
		return (void*)soap_instantiate__ns1__getAllZoneForUserOperationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SetDcuToZoneOperation:
		return (void*)soap_instantiate__ns1__SetDcuToZoneOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SetDcuToZoneOperationResponse:
		return (void*)soap_instantiate__ns1__SetDcuToZoneOperationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__addZoneOperation:
		return (void*)soap_instantiate__ns1__addZoneOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__addZoneOperationResponse:
		return (void*)soap_instantiate__ns1__addZoneOperationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__editZoneOperation:
		return (void*)soap_instantiate__ns1__editZoneOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__editZoneOperationResponse:
		return (void*)soap_instantiate__ns1__editZoneOperationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__removeZoneOperation:
		return (void*)soap_instantiate__ns1__removeZoneOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__removeZoneOperationResponse:
		return (void*)soap_instantiate__ns1__removeZoneOperationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getAllUserOperation:
		return (void*)soap_instantiate__ns1__getAllUserOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getAllUserOperationResponse:
		return (void*)soap_instantiate__ns1__getAllUserOperationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__addUserOperation:
		return (void*)soap_instantiate__ns1__addUserOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__addUserOperationResponse:
		return (void*)soap_instantiate__ns1__addUserOperationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__editUserOperation:
		return (void*)soap_instantiate__ns1__editUserOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__editUserOperationResponse:
		return (void*)soap_instantiate__ns1__editUserOperationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__removeUserOperation:
		return (void*)soap_instantiate__ns1__removeUserOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__removeUserOperationResponse:
		return (void*)soap_instantiate__ns1__removeUserOperationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__editUserByUserOperation:
		return (void*)soap_instantiate__ns1__editUserByUserOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__editUserByUserOperationResponse:
		return (void*)soap_instantiate__ns1__editUserByUserOperationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getProgramOperation:
		return (void*)soap_instantiate__ns1__getProgramOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getProgramOperationResponse:
		return (void*)soap_instantiate__ns1__getProgramOperationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__editProgramOperation:
		return (void*)soap_instantiate__ns1__editProgramOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__editProgramOperationResponse:
		return (void*)soap_instantiate__ns1__editProgramOperationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getDayScheduleOperation:
		return (void*)soap_instantiate__ns1__getDayScheduleOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getDayScheduleOperationResponse:
		return (void*)soap_instantiate__ns1__getDayScheduleOperationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__editDayScheduleOperation:
		return (void*)soap_instantiate__ns1__editDayScheduleOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__editDayScheduleOperationResponse:
		return (void*)soap_instantiate__ns1__editDayScheduleOperationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__removeDayScheduleOperation:
		return (void*)soap_instantiate__ns1__removeDayScheduleOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__removeDayScheduleOperationResponse:
		return (void*)soap_instantiate__ns1__removeDayScheduleOperationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__addDayScheduleOperation:
		return (void*)soap_instantiate__ns1__addDayScheduleOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__addDayScheduleOperationResponse:
		return (void*)soap_instantiate__ns1__addDayScheduleOperationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getListScheduleOperation:
		return (void*)soap_instantiate__ns1__getListScheduleOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getListScheduleOperationResponse:
		return (void*)soap_instantiate__ns1__getListScheduleOperationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__addListScheduleOperation:
		return (void*)soap_instantiate__ns1__addListScheduleOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__addListScheduleOperationResponse:
		return (void*)soap_instantiate__ns1__addListScheduleOperationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__editListScheduleOperation:
		return (void*)soap_instantiate__ns1__editListScheduleOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__editListScheduleOperationResponse:
		return (void*)soap_instantiate__ns1__editListScheduleOperationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__removeListScheduleOperation:
		return (void*)soap_instantiate__ns1__removeListScheduleOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__removeListScheduleOperationResponse:
		return (void*)soap_instantiate__ns1__removeListScheduleOperationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getScheduleOperation:
		return (void*)soap_instantiate__ns1__getScheduleOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getScheduleOperationResponse:
		return (void*)soap_instantiate__ns1__getScheduleOperationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__addScheduleOperation:
		return (void*)soap_instantiate__ns1__addScheduleOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__addScheduleOperationResponse:
		return (void*)soap_instantiate__ns1__addScheduleOperationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__editScheduleOperation:
		return (void*)soap_instantiate__ns1__editScheduleOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__editScheduleOperationResponse:
		return (void*)soap_instantiate__ns1__editScheduleOperationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__removeScheduleOperation:
		return (void*)soap_instantiate__ns1__removeScheduleOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__removeScheduleOperationResponse:
		return (void*)soap_instantiate__ns1__removeScheduleOperationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getLcuLogOperation:
		return (void*)soap_instantiate__ns1__getLcuLogOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getLcuLogOperationResponse:
		return (void*)soap_instantiate__ns1__getLcuLogOperationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__LoginOperation:
		return (void*)soap_instantiate___ns1__LoginOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__LoginPcOperation:
		return (void*)soap_instantiate___ns1__LoginPcOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__LogoutOperation:
		return (void*)soap_instantiate___ns1__LogoutOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getDcuListOperation:
		return (void*)soap_instantiate___ns1__getDcuListOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getLcuListOperation:
		return (void*)soap_instantiate___ns1__getLcuListOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__updateRuntimeForUserOperation:
		return (void*)soap_instantiate___ns1__updateRuntimeForUserOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getLineListOperation:
		return (void*)soap_instantiate___ns1__getLineListOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__addDcuOperation:
		return (void*)soap_instantiate___ns1__addDcuOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__removeDcuOperation:
		return (void*)soap_instantiate___ns1__removeDcuOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__editDcuOperation:
		return (void*)soap_instantiate___ns1__editDcuOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__addLcuOperation:
		return (void*)soap_instantiate___ns1__addLcuOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__removeLcuOperation:
		return (void*)soap_instantiate___ns1__removeLcuOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__editLcuOperation:
		return (void*)soap_instantiate___ns1__editLcuOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__addLineOperation:
		return (void*)soap_instantiate___ns1__addLineOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__removeLineOperation:
		return (void*)soap_instantiate___ns1__removeLineOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__editLineOperation:
		return (void*)soap_instantiate___ns1__editLineOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__addProgramOperation:
		return (void*)soap_instantiate___ns1__addProgramOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__removeProgramOperation:
		return (void*)soap_instantiate___ns1__removeProgramOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__controlLcuOperation:
		return (void*)soap_instantiate___ns1__controlLcuOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__controlLineOperation:
		return (void*)soap_instantiate___ns1__controlLineOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__setProgramDcuOperation:
		return (void*)soap_instantiate___ns1__setProgramDcuOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getEventLogOperation:
		return (void*)soap_instantiate___ns1__getEventLogOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__updateReadEventLogOperation:
		return (void*)soap_instantiate___ns1__updateReadEventLogOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__deleteEventLogOperation:
		return (void*)soap_instantiate___ns1__deleteEventLogOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getUserLogOperation:
		return (void*)soap_instantiate___ns1__getUserLogOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__deleteUserLogOperation:
		return (void*)soap_instantiate___ns1__deleteUserLogOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getAllZoneOperation:
		return (void*)soap_instantiate___ns1__getAllZoneOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getAllZoneForUserOperation:
		return (void*)soap_instantiate___ns1__getAllZoneForUserOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SetDcuToZoneOperation:
		return (void*)soap_instantiate___ns1__SetDcuToZoneOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__addZoneOperation:
		return (void*)soap_instantiate___ns1__addZoneOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__editZoneOperation:
		return (void*)soap_instantiate___ns1__editZoneOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__removeZoneOperation:
		return (void*)soap_instantiate___ns1__removeZoneOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getAllUserOperation:
		return (void*)soap_instantiate___ns1__getAllUserOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__addUserOperation:
		return (void*)soap_instantiate___ns1__addUserOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__editUserOperation:
		return (void*)soap_instantiate___ns1__editUserOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__removeUserOperation:
		return (void*)soap_instantiate___ns1__removeUserOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__editUserByUserOperation:
		return (void*)soap_instantiate___ns1__editUserByUserOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getProgramOperation:
		return (void*)soap_instantiate___ns1__getProgramOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__editProgramOperation:
		return (void*)soap_instantiate___ns1__editProgramOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getDayScheduleOperation:
		return (void*)soap_instantiate___ns1__getDayScheduleOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__editDayScheduleOperation:
		return (void*)soap_instantiate___ns1__editDayScheduleOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__removeDayScheduleOperation:
		return (void*)soap_instantiate___ns1__removeDayScheduleOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__addDayScheduleOperation:
		return (void*)soap_instantiate___ns1__addDayScheduleOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getListScheduleOperation:
		return (void*)soap_instantiate___ns1__getListScheduleOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__addListScheduleOperation:
		return (void*)soap_instantiate___ns1__addListScheduleOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__editListScheduleOperation:
		return (void*)soap_instantiate___ns1__editListScheduleOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__removeListScheduleOperation:
		return (void*)soap_instantiate___ns1__removeListScheduleOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getScheduleOperation:
		return (void*)soap_instantiate___ns1__getScheduleOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__addScheduleOperation:
		return (void*)soap_instantiate___ns1__addScheduleOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__editScheduleOperation:
		return (void*)soap_instantiate___ns1__editScheduleOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__removeScheduleOperation:
		return (void*)soap_instantiate___ns1__removeScheduleOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getLcuLogOperation:
		return (void*)soap_instantiate___ns1__getLcuLogOperation(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType:
		if (p->size < 0)
			SOAP_DELETE((ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType*)p->ptr);
		break;
	case SOAP_TYPE_ns1__DCU_USCOREINFO_USCOREType:
		if (p->size < 0)
			SOAP_DELETE((ns1__DCU_USCOREINFO_USCOREType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__DCU_USCOREINFO_USCOREType*)p->ptr);
		break;
	case SOAP_TYPE_ns1__LCU_USCOREINFO_USCOREType:
		if (p->size < 0)
			SOAP_DELETE((ns1__LCU_USCOREINFO_USCOREType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__LCU_USCOREINFO_USCOREType*)p->ptr);
		break;
	case SOAP_TYPE_ns1__LCULOGINFOType:
		if (p->size < 0)
			SOAP_DELETE((ns1__LCULOGINFOType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__LCULOGINFOType*)p->ptr);
		break;
	case SOAP_TYPE_ns1__LINE_USCOREINFO_USCOREType:
		if (p->size < 0)
			SOAP_DELETE((ns1__LINE_USCOREINFO_USCOREType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__LINE_USCOREINFO_USCOREType*)p->ptr);
		break;
	case SOAP_TYPE_ns1__EVENT_USCORELOG_USCOREINFO_USCOREType:
		if (p->size < 0)
			SOAP_DELETE((ns1__EVENT_USCORELOG_USCOREINFO_USCOREType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__EVENT_USCORELOG_USCOREINFO_USCOREType*)p->ptr);
		break;
	case SOAP_TYPE_ns1__USER_USCORELOG_USCOREINFO_USCOREType:
		if (p->size < 0)
			SOAP_DELETE((ns1__USER_USCORELOG_USCOREINFO_USCOREType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__USER_USCORELOG_USCOREINFO_USCOREType*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ZONE_USCOREINFO_USCOREType:
		if (p->size < 0)
			SOAP_DELETE((ns1__ZONE_USCOREINFO_USCOREType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ZONE_USCOREINFO_USCOREType*)p->ptr);
		break;
	case SOAP_TYPE_ns1__USER_USCOREINFO_USCOREType:
		if (p->size < 0)
			SOAP_DELETE((ns1__USER_USCOREINFO_USCOREType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__USER_USCOREINFO_USCOREType*)p->ptr);
		break;
	case SOAP_TYPE_ns1__PROGRAM_USCOREINFO_USCOREType:
		if (p->size < 0)
			SOAP_DELETE((ns1__PROGRAM_USCOREINFO_USCOREType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__PROGRAM_USCOREINFO_USCOREType*)p->ptr);
		break;
	case SOAP_TYPE_ns1__DAYSCHEDULE_USCOREINFO_USCOREType:
		if (p->size < 0)
			SOAP_DELETE((ns1__DAYSCHEDULE_USCOREINFO_USCOREType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__DAYSCHEDULE_USCOREINFO_USCOREType*)p->ptr);
		break;
	case SOAP_TYPE_ns1__LISTSCHEDULE_USCOREINFO_USCOREType:
		if (p->size < 0)
			SOAP_DELETE((ns1__LISTSCHEDULE_USCOREINFO_USCOREType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__LISTSCHEDULE_USCOREINFO_USCOREType*)p->ptr);
		break;
	case SOAP_TYPE_ns1__SCHEDULE_USCOREINFO_USCOREType:
		if (p->size < 0)
			SOAP_DELETE((ns1__SCHEDULE_USCOREINFO_USCOREType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__SCHEDULE_USCOREINFO_USCOREType*)p->ptr);
		break;
	case SOAP_TYPE__ns1__LoginOperation:
		if (p->size < 0)
			SOAP_DELETE((_ns1__LoginOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__LoginOperation*)p->ptr);
		break;
	case SOAP_TYPE__ns1__LoginOperationResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__LoginOperationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__LoginOperationResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__LoginPcOperation:
		if (p->size < 0)
			SOAP_DELETE((_ns1__LoginPcOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__LoginPcOperation*)p->ptr);
		break;
	case SOAP_TYPE__ns1__LoginPcOperationResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__LoginPcOperationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__LoginPcOperationResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__LogoutOperation:
		if (p->size < 0)
			SOAP_DELETE((_ns1__LogoutOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__LogoutOperation*)p->ptr);
		break;
	case SOAP_TYPE__ns1__LogoutOperationResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__LogoutOperationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__LogoutOperationResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getDcuListOperation:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getDcuListOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getDcuListOperation*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getDcuListOperationResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getDcuListOperationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getDcuListOperationResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getLcuListOperation:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getLcuListOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getLcuListOperation*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getLcuListOperationResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getLcuListOperationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getLcuListOperationResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__updateRuntimeForUserOperation:
		if (p->size < 0)
			SOAP_DELETE((_ns1__updateRuntimeForUserOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__updateRuntimeForUserOperation*)p->ptr);
		break;
	case SOAP_TYPE__ns1__updateRuntimeForUserOperationResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__updateRuntimeForUserOperationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__updateRuntimeForUserOperationResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getLineListOperation:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getLineListOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getLineListOperation*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getLineListOperationResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getLineListOperationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getLineListOperationResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__addDcuOperation:
		if (p->size < 0)
			SOAP_DELETE((_ns1__addDcuOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__addDcuOperation*)p->ptr);
		break;
	case SOAP_TYPE__ns1__addDcuOperationResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__addDcuOperationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__addDcuOperationResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__removeDcuOperation:
		if (p->size < 0)
			SOAP_DELETE((_ns1__removeDcuOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__removeDcuOperation*)p->ptr);
		break;
	case SOAP_TYPE__ns1__removeDcuOperationResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__removeDcuOperationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__removeDcuOperationResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__editDcuOperation:
		if (p->size < 0)
			SOAP_DELETE((_ns1__editDcuOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__editDcuOperation*)p->ptr);
		break;
	case SOAP_TYPE__ns1__editDcuOperationResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__editDcuOperationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__editDcuOperationResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__addLcuOperation:
		if (p->size < 0)
			SOAP_DELETE((_ns1__addLcuOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__addLcuOperation*)p->ptr);
		break;
	case SOAP_TYPE__ns1__addLcuOperationResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__addLcuOperationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__addLcuOperationResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__removeLcuOperation:
		if (p->size < 0)
			SOAP_DELETE((_ns1__removeLcuOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__removeLcuOperation*)p->ptr);
		break;
	case SOAP_TYPE__ns1__removeLcuOperationResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__removeLcuOperationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__removeLcuOperationResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__editLcuOperation:
		if (p->size < 0)
			SOAP_DELETE((_ns1__editLcuOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__editLcuOperation*)p->ptr);
		break;
	case SOAP_TYPE__ns1__editLcuOperationResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__editLcuOperationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__editLcuOperationResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__addLineOperation:
		if (p->size < 0)
			SOAP_DELETE((_ns1__addLineOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__addLineOperation*)p->ptr);
		break;
	case SOAP_TYPE__ns1__addLineOperationResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__addLineOperationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__addLineOperationResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__removeLineOperation:
		if (p->size < 0)
			SOAP_DELETE((_ns1__removeLineOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__removeLineOperation*)p->ptr);
		break;
	case SOAP_TYPE__ns1__removeLineOperationResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__removeLineOperationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__removeLineOperationResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__editLineOperation:
		if (p->size < 0)
			SOAP_DELETE((_ns1__editLineOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__editLineOperation*)p->ptr);
		break;
	case SOAP_TYPE__ns1__editLineOperationResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__editLineOperationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__editLineOperationResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__addProgramOperation:
		if (p->size < 0)
			SOAP_DELETE((_ns1__addProgramOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__addProgramOperation*)p->ptr);
		break;
	case SOAP_TYPE__ns1__addProgramOperationResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__addProgramOperationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__addProgramOperationResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__removeProgramOperation:
		if (p->size < 0)
			SOAP_DELETE((_ns1__removeProgramOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__removeProgramOperation*)p->ptr);
		break;
	case SOAP_TYPE__ns1__removeProgramOperationResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__removeProgramOperationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__removeProgramOperationResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__controlLcuOperation:
		if (p->size < 0)
			SOAP_DELETE((_ns1__controlLcuOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__controlLcuOperation*)p->ptr);
		break;
	case SOAP_TYPE__ns1__controlLcuOperationResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__controlLcuOperationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__controlLcuOperationResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__controlLineOperation:
		if (p->size < 0)
			SOAP_DELETE((_ns1__controlLineOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__controlLineOperation*)p->ptr);
		break;
	case SOAP_TYPE__ns1__controlLineOperationResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__controlLineOperationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__controlLineOperationResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__setProgramDcuOperation:
		if (p->size < 0)
			SOAP_DELETE((_ns1__setProgramDcuOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__setProgramDcuOperation*)p->ptr);
		break;
	case SOAP_TYPE__ns1__setProgramDcuOperationResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__setProgramDcuOperationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__setProgramDcuOperationResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getEventLogOperation:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getEventLogOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getEventLogOperation*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getEventLogOperationResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getEventLogOperationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getEventLogOperationResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__updateReadEventLogOperation:
		if (p->size < 0)
			SOAP_DELETE((_ns1__updateReadEventLogOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__updateReadEventLogOperation*)p->ptr);
		break;
	case SOAP_TYPE__ns1__updateReadEventLogOperationResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__updateReadEventLogOperationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__updateReadEventLogOperationResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__deleteEventLogOperation:
		if (p->size < 0)
			SOAP_DELETE((_ns1__deleteEventLogOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__deleteEventLogOperation*)p->ptr);
		break;
	case SOAP_TYPE__ns1__deleteEventLogOperationResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__deleteEventLogOperationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__deleteEventLogOperationResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getUserLogOperation:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getUserLogOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getUserLogOperation*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getUserLogOperationResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getUserLogOperationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getUserLogOperationResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__deleteUserLogOperation:
		if (p->size < 0)
			SOAP_DELETE((_ns1__deleteUserLogOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__deleteUserLogOperation*)p->ptr);
		break;
	case SOAP_TYPE__ns1__deleteUserLogOperationResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__deleteUserLogOperationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__deleteUserLogOperationResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getAllZoneOperation:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getAllZoneOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getAllZoneOperation*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getAllZoneOperationResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getAllZoneOperationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getAllZoneOperationResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getAllZoneForUserOperation:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getAllZoneForUserOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getAllZoneForUserOperation*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getAllZoneForUserOperationResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getAllZoneForUserOperationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getAllZoneForUserOperationResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__SetDcuToZoneOperation:
		if (p->size < 0)
			SOAP_DELETE((_ns1__SetDcuToZoneOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__SetDcuToZoneOperation*)p->ptr);
		break;
	case SOAP_TYPE__ns1__SetDcuToZoneOperationResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__SetDcuToZoneOperationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__SetDcuToZoneOperationResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__addZoneOperation:
		if (p->size < 0)
			SOAP_DELETE((_ns1__addZoneOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__addZoneOperation*)p->ptr);
		break;
	case SOAP_TYPE__ns1__addZoneOperationResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__addZoneOperationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__addZoneOperationResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__editZoneOperation:
		if (p->size < 0)
			SOAP_DELETE((_ns1__editZoneOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__editZoneOperation*)p->ptr);
		break;
	case SOAP_TYPE__ns1__editZoneOperationResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__editZoneOperationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__editZoneOperationResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__removeZoneOperation:
		if (p->size < 0)
			SOAP_DELETE((_ns1__removeZoneOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__removeZoneOperation*)p->ptr);
		break;
	case SOAP_TYPE__ns1__removeZoneOperationResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__removeZoneOperationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__removeZoneOperationResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getAllUserOperation:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getAllUserOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getAllUserOperation*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getAllUserOperationResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getAllUserOperationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getAllUserOperationResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__addUserOperation:
		if (p->size < 0)
			SOAP_DELETE((_ns1__addUserOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__addUserOperation*)p->ptr);
		break;
	case SOAP_TYPE__ns1__addUserOperationResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__addUserOperationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__addUserOperationResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__editUserOperation:
		if (p->size < 0)
			SOAP_DELETE((_ns1__editUserOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__editUserOperation*)p->ptr);
		break;
	case SOAP_TYPE__ns1__editUserOperationResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__editUserOperationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__editUserOperationResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__removeUserOperation:
		if (p->size < 0)
			SOAP_DELETE((_ns1__removeUserOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__removeUserOperation*)p->ptr);
		break;
	case SOAP_TYPE__ns1__removeUserOperationResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__removeUserOperationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__removeUserOperationResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__editUserByUserOperation:
		if (p->size < 0)
			SOAP_DELETE((_ns1__editUserByUserOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__editUserByUserOperation*)p->ptr);
		break;
	case SOAP_TYPE__ns1__editUserByUserOperationResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__editUserByUserOperationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__editUserByUserOperationResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getProgramOperation:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getProgramOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getProgramOperation*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getProgramOperationResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getProgramOperationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getProgramOperationResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__editProgramOperation:
		if (p->size < 0)
			SOAP_DELETE((_ns1__editProgramOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__editProgramOperation*)p->ptr);
		break;
	case SOAP_TYPE__ns1__editProgramOperationResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__editProgramOperationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__editProgramOperationResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getDayScheduleOperation:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getDayScheduleOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getDayScheduleOperation*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getDayScheduleOperationResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getDayScheduleOperationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getDayScheduleOperationResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__editDayScheduleOperation:
		if (p->size < 0)
			SOAP_DELETE((_ns1__editDayScheduleOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__editDayScheduleOperation*)p->ptr);
		break;
	case SOAP_TYPE__ns1__editDayScheduleOperationResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__editDayScheduleOperationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__editDayScheduleOperationResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__removeDayScheduleOperation:
		if (p->size < 0)
			SOAP_DELETE((_ns1__removeDayScheduleOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__removeDayScheduleOperation*)p->ptr);
		break;
	case SOAP_TYPE__ns1__removeDayScheduleOperationResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__removeDayScheduleOperationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__removeDayScheduleOperationResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__addDayScheduleOperation:
		if (p->size < 0)
			SOAP_DELETE((_ns1__addDayScheduleOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__addDayScheduleOperation*)p->ptr);
		break;
	case SOAP_TYPE__ns1__addDayScheduleOperationResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__addDayScheduleOperationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__addDayScheduleOperationResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getListScheduleOperation:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getListScheduleOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getListScheduleOperation*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getListScheduleOperationResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getListScheduleOperationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getListScheduleOperationResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__addListScheduleOperation:
		if (p->size < 0)
			SOAP_DELETE((_ns1__addListScheduleOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__addListScheduleOperation*)p->ptr);
		break;
	case SOAP_TYPE__ns1__addListScheduleOperationResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__addListScheduleOperationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__addListScheduleOperationResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__editListScheduleOperation:
		if (p->size < 0)
			SOAP_DELETE((_ns1__editListScheduleOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__editListScheduleOperation*)p->ptr);
		break;
	case SOAP_TYPE__ns1__editListScheduleOperationResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__editListScheduleOperationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__editListScheduleOperationResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__removeListScheduleOperation:
		if (p->size < 0)
			SOAP_DELETE((_ns1__removeListScheduleOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__removeListScheduleOperation*)p->ptr);
		break;
	case SOAP_TYPE__ns1__removeListScheduleOperationResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__removeListScheduleOperationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__removeListScheduleOperationResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getScheduleOperation:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getScheduleOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getScheduleOperation*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getScheduleOperationResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getScheduleOperationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getScheduleOperationResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__addScheduleOperation:
		if (p->size < 0)
			SOAP_DELETE((_ns1__addScheduleOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__addScheduleOperation*)p->ptr);
		break;
	case SOAP_TYPE__ns1__addScheduleOperationResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__addScheduleOperationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__addScheduleOperationResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__editScheduleOperation:
		if (p->size < 0)
			SOAP_DELETE((_ns1__editScheduleOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__editScheduleOperation*)p->ptr);
		break;
	case SOAP_TYPE__ns1__editScheduleOperationResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__editScheduleOperationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__editScheduleOperationResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__removeScheduleOperation:
		if (p->size < 0)
			SOAP_DELETE((_ns1__removeScheduleOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__removeScheduleOperation*)p->ptr);
		break;
	case SOAP_TYPE__ns1__removeScheduleOperationResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__removeScheduleOperationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__removeScheduleOperationResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getLcuLogOperation:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getLcuLogOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getLcuLogOperation*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getLcuLogOperationResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getLcuLogOperationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getLcuLogOperationResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1__LoginOperation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__LoginOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__LoginOperation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__LoginPcOperation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__LoginPcOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__LoginPcOperation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__LogoutOperation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__LogoutOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__LogoutOperation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getDcuListOperation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getDcuListOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getDcuListOperation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getLcuListOperation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getLcuListOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getLcuListOperation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__updateRuntimeForUserOperation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__updateRuntimeForUserOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__updateRuntimeForUserOperation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getLineListOperation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getLineListOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getLineListOperation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__addDcuOperation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__addDcuOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__addDcuOperation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__removeDcuOperation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__removeDcuOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__removeDcuOperation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__editDcuOperation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__editDcuOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__editDcuOperation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__addLcuOperation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__addLcuOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__addLcuOperation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__removeLcuOperation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__removeLcuOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__removeLcuOperation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__editLcuOperation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__editLcuOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__editLcuOperation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__addLineOperation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__addLineOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__addLineOperation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__removeLineOperation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__removeLineOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__removeLineOperation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__editLineOperation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__editLineOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__editLineOperation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__addProgramOperation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__addProgramOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__addProgramOperation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__removeProgramOperation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__removeProgramOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__removeProgramOperation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__controlLcuOperation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__controlLcuOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__controlLcuOperation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__controlLineOperation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__controlLineOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__controlLineOperation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__setProgramDcuOperation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__setProgramDcuOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__setProgramDcuOperation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getEventLogOperation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getEventLogOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getEventLogOperation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__updateReadEventLogOperation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__updateReadEventLogOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__updateReadEventLogOperation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__deleteEventLogOperation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__deleteEventLogOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__deleteEventLogOperation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getUserLogOperation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getUserLogOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getUserLogOperation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__deleteUserLogOperation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__deleteUserLogOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__deleteUserLogOperation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getAllZoneOperation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getAllZoneOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getAllZoneOperation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getAllZoneForUserOperation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getAllZoneForUserOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getAllZoneForUserOperation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__SetDcuToZoneOperation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__SetDcuToZoneOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__SetDcuToZoneOperation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__addZoneOperation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__addZoneOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__addZoneOperation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__editZoneOperation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__editZoneOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__editZoneOperation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__removeZoneOperation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__removeZoneOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__removeZoneOperation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getAllUserOperation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getAllUserOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getAllUserOperation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__addUserOperation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__addUserOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__addUserOperation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__editUserOperation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__editUserOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__editUserOperation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__removeUserOperation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__removeUserOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__removeUserOperation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__editUserByUserOperation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__editUserByUserOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__editUserByUserOperation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getProgramOperation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getProgramOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getProgramOperation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__editProgramOperation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__editProgramOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__editProgramOperation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getDayScheduleOperation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getDayScheduleOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getDayScheduleOperation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__editDayScheduleOperation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__editDayScheduleOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__editDayScheduleOperation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__removeDayScheduleOperation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__removeDayScheduleOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__removeDayScheduleOperation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__addDayScheduleOperation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__addDayScheduleOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__addDayScheduleOperation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getListScheduleOperation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getListScheduleOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getListScheduleOperation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__addListScheduleOperation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__addListScheduleOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__addListScheduleOperation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__editListScheduleOperation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__editListScheduleOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__editListScheduleOperation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__removeListScheduleOperation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__removeListScheduleOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__removeListScheduleOperation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getScheduleOperation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getScheduleOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getScheduleOperation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__addScheduleOperation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__addScheduleOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__addScheduleOperation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__editScheduleOperation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__editScheduleOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__editScheduleOperation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__removeScheduleOperation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__removeScheduleOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__removeScheduleOperation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getLcuLogOperation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getLcuLogOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getLcuLogOperation*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
#endif
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag?tag:"boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__EVENTLOG_USCORETYPE_USCOREEnum(struct soap *soap, enum ns1__EVENTLOG_USCORETYPE_USCOREEnum *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__EVENTLOG_USCORETYPE_USCOREEnum
	*a = SOAP_DEFAULT_ns1__EVENTLOG_USCORETYPE_USCOREEnum;
#else
	*a = (enum ns1__EVENTLOG_USCORETYPE_USCOREEnum)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__EVENTLOG_USCORETYPE_USCOREEnum[] =
{	{ (long)ns1__EVENTLOG_USCORETYPE_USCOREEnum__CONNECT_USCOREDCU_USCORELOG, "CONNECT_DCU_LOG" },
	{ (long)ns1__EVENTLOG_USCORETYPE_USCOREEnum__LIFECYCLE_USCORESERVER_USCORELOG, "LIFECYCLE_SERVER_LOG" },
	{ (long)ns1__EVENTLOG_USCORETYPE_USCOREEnum__DCU_USCOREERR_USCORELOG, "DCU_ERR_LOG" },
	{ (long)ns1__EVENTLOG_USCORETYPE_USCOREEnum__LCU_USCOREERR_USCORELOG, "LCU_ERR_LOG" },
	{ (long)ns1__EVENTLOG_USCORETYPE_USCOREEnum__LINE_USCOREERR_USCORELOG, "LINE_ERR_LOG" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__EVENTLOG_USCORETYPE_USCOREEnum2s(struct soap *soap, enum ns1__EVENTLOG_USCORETYPE_USCOREEnum n)
{	const char *s = soap_code_str(soap_codes_ns1__EVENTLOG_USCORETYPE_USCOREEnum, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__EVENTLOG_USCORETYPE_USCOREEnum(struct soap *soap, const char *tag, int id, const enum ns1__EVENTLOG_USCORETYPE_USCOREEnum *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__EVENTLOG_USCORETYPE_USCOREEnum), type) || soap_send(soap, soap_ns1__EVENTLOG_USCORETYPE_USCOREEnum2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__EVENTLOG_USCORETYPE_USCOREEnum(struct soap *soap, const char *s, enum ns1__EVENTLOG_USCORETYPE_USCOREEnum *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__EVENTLOG_USCORETYPE_USCOREEnum, s);
	if (map)
		*a = (enum ns1__EVENTLOG_USCORETYPE_USCOREEnum)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 4)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__EVENTLOG_USCORETYPE_USCOREEnum)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__EVENTLOG_USCORETYPE_USCOREEnum * SOAP_FMAC4 soap_in_ns1__EVENTLOG_USCORETYPE_USCOREEnum(struct soap *soap, const char *tag, enum ns1__EVENTLOG_USCORETYPE_USCOREEnum *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__EVENTLOG_USCORETYPE_USCOREEnum *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__EVENTLOG_USCORETYPE_USCOREEnum, sizeof(enum ns1__EVENTLOG_USCORETYPE_USCOREEnum), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__EVENTLOG_USCORETYPE_USCOREEnum(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__EVENTLOG_USCORETYPE_USCOREEnum *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__EVENTLOG_USCORETYPE_USCOREEnum, 0, sizeof(enum ns1__EVENTLOG_USCORETYPE_USCOREEnum), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__EVENTLOG_USCORETYPE_USCOREEnum(struct soap *soap, const enum ns1__EVENTLOG_USCORETYPE_USCOREEnum *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__EVENTLOG_USCORETYPE_USCOREEnum);
	if (soap_out_ns1__EVENTLOG_USCORETYPE_USCOREEnum(soap, tag?tag:"ns1:EVENTLOG_TYPE_Enum", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__EVENTLOG_USCORETYPE_USCOREEnum * SOAP_FMAC4 soap_get_ns1__EVENTLOG_USCORETYPE_USCOREEnum(struct soap *soap, enum ns1__EVENTLOG_USCORETYPE_USCOREEnum *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__EVENTLOG_USCORETYPE_USCOREEnum(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__MESSAGE_USCORERESULT_USCOREEnum(struct soap *soap, enum ns1__MESSAGE_USCORERESULT_USCOREEnum *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__MESSAGE_USCORERESULT_USCOREEnum
	*a = SOAP_DEFAULT_ns1__MESSAGE_USCORERESULT_USCOREEnum;
#else
	*a = (enum ns1__MESSAGE_USCORERESULT_USCOREEnum)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__MESSAGE_USCORERESULT_USCOREEnum[] =
{	{ (long)ns1__MESSAGE_USCORERESULT_USCOREEnum__NON_USCOREERR, "NON_ERR" },
	{ (long)ns1__MESSAGE_USCORERESULT_USCOREEnum__MYSQL_USCOREERR, "MYSQL_ERR" },
	{ (long)ns1__MESSAGE_USCORERESULT_USCOREEnum__USER_USCOREPASS_USCOREERR, "USER_PASS_ERR" },
	{ (long)ns1__MESSAGE_USCORERESULT_USCOREEnum__INVALID_USCORELOGIN_USCOREERR, "INVALID_LOGIN_ERR" },
	{ (long)ns1__MESSAGE_USCORERESULT_USCOREEnum__INTERNAL_USCOREERR, "INTERNAL_ERR" },
	{ (long)ns1__MESSAGE_USCORERESULT_USCOREEnum__UNKNOW_USCOREERR, "UNKNOW_ERR" },
	{ (long)ns1__MESSAGE_USCORERESULT_USCOREEnum__TIMEOUT_USCOREERR, "TIMEOUT_ERR" },
	{ (long)ns1__MESSAGE_USCORERESULT_USCOREEnum__OFFLINE_USCOREERR, "OFFLINE_ERR" },
	{ (long)ns1__MESSAGE_USCORERESULT_USCOREEnum__MODE_USCOREERR, "MODE_ERR" },
	{ (long)ns1__MESSAGE_USCORERESULT_USCOREEnum__LIGHTNUM_USCOREERR, "LIGHTNUM_ERR" },
	{ (long)ns1__MESSAGE_USCORERESULT_USCOREEnum__LINENUM_USCOREERR, "LINENUM_ERR" },
	{ (long)ns1__MESSAGE_USCORERESULT_USCOREEnum__CLOCK_USCOREERR, "CLOCK_ERR" },
	{ (long)ns1__MESSAGE_USCORERESULT_USCOREEnum__EXIST_USCOREDCU_USCOREERR, "EXIST_DCU_ERR" },
	{ (long)ns1__MESSAGE_USCORERESULT_USCOREEnum__NOEXIST_USCOREDCU_USCOREERR, "NOEXIST_DCU_ERR" },
	{ (long)ns1__MESSAGE_USCORERESULT_USCOREEnum__EXIST_USCORELCU_USCOREERR, "EXIST_LCU_ERR" },
	{ (long)ns1__MESSAGE_USCORERESULT_USCOREEnum__NOEXIST_USCORELCU_USCOREERR, "NOEXIST_LCU_ERR" },
	{ (long)ns1__MESSAGE_USCORERESULT_USCOREEnum__MEM_USCOREERR, "MEM_ERR" },
	{ (long)ns1__MESSAGE_USCORERESULT_USCOREEnum__GET_USCOREPRO_USCOREFROM_USCOREDB_USCOREERR, "GET_PRO_FROM_DB_ERR" },
	{ (long)ns1__MESSAGE_USCORERESULT_USCOREEnum__USER_USCOREPASSWD_USCOREERR, "USER_PASSWD_ERR" },
	{ (long)ns1__MESSAGE_USCORERESULT_USCOREEnum__ADD_USCORELCU_USCOREERR, "ADD_LCU_ERR" },
	{ (long)ns1__MESSAGE_USCORERESULT_USCOREEnum__REMOVE_USCORELCU_USCOREERR, "REMOVE_LCU_ERR" },
	{ (long)ns1__MESSAGE_USCORERESULT_USCOREEnum__LIMIT_USCORELCU_USCOREERR, "LIMIT_LCU_ERR" },
	{ (long)ns1__MESSAGE_USCORERESULT_USCOREEnum__SET_USCORESCHEDULE_USCORELCU_USCOREERR, "SET_SCHEDULE_LCU_ERR" },
	{ (long)ns1__MESSAGE_USCORERESULT_USCOREEnum__GET_USCORESCHEDULE_USCORELCU_USCOREERR, "GET_SCHEDULE_LCU_ERR" },
	{ (long)ns1__MESSAGE_USCORERESULT_USCOREEnum__VERIFY_USCORESCHEDULE_USCORELCU_USCOREERR, "VERIFY_SCHEDULE_LCU_ERR" },
	{ (long)ns1__MESSAGE_USCORERESULT_USCOREEnum__GET_USCORELCU_USCOREERR, "GET_LCU_ERR" },
	{ (long)ns1__MESSAGE_USCORERESULT_USCOREEnum__ADD_USCORELINE_USCOREERR, "ADD_LINE_ERR" },
	{ (long)ns1__MESSAGE_USCORERESULT_USCOREEnum__REMOVE_USCORELINE_USCOREERR, "REMOVE_LINE_ERR" },
	{ (long)ns1__MESSAGE_USCORERESULT_USCOREEnum__LIMIT_USCORELINE_USCOREERR, "LIMIT_LINE_ERR" },
	{ (long)ns1__MESSAGE_USCORERESULT_USCOREEnum__SET_USCORESCHEDULE_USCORELINE_USCOREERR, "SET_SCHEDULE_LINE_ERR" },
	{ (long)ns1__MESSAGE_USCORERESULT_USCOREEnum__GET_USCORESCHEDULE_USCORELINE_USCOREERR, "GET_SCHEDULE_LINE_ERR" },
	{ (long)ns1__MESSAGE_USCORERESULT_USCOREEnum__VERIFY_USCORESCHEDULE_USCORELINE_USCOREERR, "VERIFY_SCHEDULE_LINE_ERR" },
	{ (long)ns1__MESSAGE_USCORERESULT_USCOREEnum__GET_USCORELINE_USCOREERR, "GET_LINE_ERR" },
	{ (long)ns1__MESSAGE_USCORERESULT_USCOREEnum__EXIST_USCOREPROGRAM_USCOREERR, "EXIST_PROGRAM_ERR" },
	{ (long)ns1__MESSAGE_USCORERESULT_USCOREEnum__NOEXIST_USCOREPROGRAM_USCOREERR, "NOEXIST_PROGRAM_ERR" },
	{ (long)ns1__MESSAGE_USCORERESULT_USCOREEnum__ISUSE_USCOREPROGRAM_USCOREERR, "ISUSE_PROGRAM_ERR" },
	{ (long)ns1__MESSAGE_USCORERESULT_USCOREEnum__MANAGE_USCOREDCU_USCOREPRIVILEGE_USCOREERR, "MANAGE_DCU_PRIVILEGE_ERR" },
	{ (long)ns1__MESSAGE_USCORERESULT_USCOREEnum__MANAGE_USCORELINE_USCORELCU_USCOREPRIVILEGE_USCOREERR, "MANAGE_LINE_LCU_PRIVILEGE_ERR" },
	{ (long)ns1__MESSAGE_USCORERESULT_USCOREEnum__CONTROL_USCORELINE_USCORELCU_USCOREPRIVILEGE_USCOREERR, "CONTROL_LINE_LCU_PRIVILEGE_ERR" },
	{ (long)ns1__MESSAGE_USCORERESULT_USCOREEnum__SETUP_USCOREDEVICE_USCOREPRIVILEGE_USCOREERR, "SETUP_DEVICE_PRIVILEGE_ERR" },
	{ (long)ns1__MESSAGE_USCORERESULT_USCOREEnum__PROGRAM_USCOREPRIVILEGE_USCOREERR, "PROGRAM_PRIVILEGE_ERR" },
	{ (long)ns1__MESSAGE_USCORERESULT_USCOREEnum__ADMINISTRATOR_USCOREPRIVILEGE_USCOREERR, "ADMINISTRATOR_PRIVILEGE_ERR" },
	{ (long)ns1__MESSAGE_USCORERESULT_USCOREEnum__EXIST_USCOREUSER_USCOREERR, "EXIST_USER_ERR" },
	{ (long)ns1__MESSAGE_USCORERESULT_USCOREEnum__NOEXIST_USCOREUSER_USCOREERR, "NOEXIST_USER_ERR" },
	{ (long)ns1__MESSAGE_USCORERESULT_USCOREEnum__INVALID_USCOREMONTH_USCOREDAYSCHEDULE_USCOREERR, "INVALID_MONTH_DAYSCHEDULE_ERR" },
	{ (long)ns1__MESSAGE_USCORERESULT_USCOREEnum__EXIST_USCOREDAYSCHEDULE_USCOREERR, "EXIST_DAYSCHEDULE_ERR" },
	{ (long)ns1__MESSAGE_USCORERESULT_USCOREEnum__NOEXIST_USCOREDAYSCHEDULE_USCOREERR, "NOEXIST_DAYSCHEDULE_ERR" },
	{ (long)ns1__MESSAGE_USCORERESULT_USCOREEnum__EXIST_USCORESCHEDULE_USCOREERR, "EXIST_SCHEDULE_ERR" },
	{ (long)ns1__MESSAGE_USCORERESULT_USCOREEnum__NOEXIST_USCORESCHEDULE_USCOREERR, "NOEXIST_SCHEDULE_ERR" },
	{ (long)ns1__MESSAGE_USCORERESULT_USCOREEnum__CONTROL_USCORELCU_USCOREERR, "CONTROL_LCU_ERR" },
	{ (long)ns1__MESSAGE_USCORERESULT_USCOREEnum__OTHER_USCOREUSER_USCORECONTROL_USCORETEMP_USCORELCU_USCOREERR, "OTHER_USER_CONTROL_TEMP_LCU_ERR" },
	{ (long)ns1__MESSAGE_USCORERESULT_USCOREEnum__LOGIN_USCOREWITH_USCOREOTHER_USCOREDEV_USCOREERR, "LOGIN_WITH_OTHER_DEV_ERR" },
	{ (long)ns1__MESSAGE_USCORERESULT_USCOREEnum__DCU_USCOREBUSY_USCOREERR, "DCU_BUSY_ERR" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__MESSAGE_USCORERESULT_USCOREEnum2s(struct soap *soap, enum ns1__MESSAGE_USCORERESULT_USCOREEnum n)
{	const char *s = soap_code_str(soap_codes_ns1__MESSAGE_USCORERESULT_USCOREEnum, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MESSAGE_USCORERESULT_USCOREEnum(struct soap *soap, const char *tag, int id, const enum ns1__MESSAGE_USCORERESULT_USCOREEnum *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MESSAGE_USCORERESULT_USCOREEnum), type) || soap_send(soap, soap_ns1__MESSAGE_USCORERESULT_USCOREEnum2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__MESSAGE_USCORERESULT_USCOREEnum(struct soap *soap, const char *s, enum ns1__MESSAGE_USCORERESULT_USCOREEnum *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__MESSAGE_USCORERESULT_USCOREEnum, s);
	if (map)
		*a = (enum ns1__MESSAGE_USCORERESULT_USCOREEnum)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 52)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__MESSAGE_USCORERESULT_USCOREEnum)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__MESSAGE_USCORERESULT_USCOREEnum * SOAP_FMAC4 soap_in_ns1__MESSAGE_USCORERESULT_USCOREEnum(struct soap *soap, const char *tag, enum ns1__MESSAGE_USCORERESULT_USCOREEnum *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__MESSAGE_USCORERESULT_USCOREEnum *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MESSAGE_USCORERESULT_USCOREEnum, sizeof(enum ns1__MESSAGE_USCORERESULT_USCOREEnum), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__MESSAGE_USCORERESULT_USCOREEnum *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__MESSAGE_USCORERESULT_USCOREEnum, 0, sizeof(enum ns1__MESSAGE_USCORERESULT_USCOREEnum), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__MESSAGE_USCORERESULT_USCOREEnum(struct soap *soap, const enum ns1__MESSAGE_USCORERESULT_USCOREEnum *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__MESSAGE_USCORERESULT_USCOREEnum);
	if (soap_out_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, tag?tag:"ns1:MESSAGE_RESULT_Enum", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__MESSAGE_USCORERESULT_USCOREEnum * SOAP_FMAC4 soap_get_ns1__MESSAGE_USCORERESULT_USCOREEnum(struct soap *soap, enum ns1__MESSAGE_USCORERESULT_USCOREEnum *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__getLcuLogOperationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, &this->_ns1__getLcuLogOperationResponse::message_USCOREresult);
	this->_ns1__getLcuLogOperationResponse::__sizelcuLoglist = 0;
	this->_ns1__getLcuLogOperationResponse::lcuLoglist = NULL;
	/* transient soap skipped */
}

void _ns1__getLcuLogOperationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->_ns1__getLcuLogOperationResponse::lcuLoglist)
	{	int i;
		for (i = 0; i < this->_ns1__getLcuLogOperationResponse::__sizelcuLoglist; i++)
		{
			soap_serialize_PointerTons1__LCULOGINFOType(soap, this->_ns1__getLcuLogOperationResponse::lcuLoglist + i);
		}
	}
	/* transient soap skipped */
}

int _ns1__getLcuLogOperationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getLcuLogOperationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getLcuLogOperationResponse(struct soap *soap, const char *tag, int id, const _ns1__getLcuLogOperationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getLcuLogOperationResponse), type))
		return soap->error;
	if (soap_out_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", -1, &(a->_ns1__getLcuLogOperationResponse::message_USCOREresult), ""))
		return soap->error;
	if (a->_ns1__getLcuLogOperationResponse::lcuLoglist)
	{	int i;
		for (i = 0; i < a->_ns1__getLcuLogOperationResponse::__sizelcuLoglist; i++)
			if (soap_out_PointerTons1__LCULOGINFOType(soap, "lcuLoglist", -1, a->_ns1__getLcuLogOperationResponse::lcuLoglist + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getLcuLogOperationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getLcuLogOperationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getLcuLogOperationResponse * SOAP_FMAC4 soap_in__ns1__getLcuLogOperationResponse(struct soap *soap, const char *tag, _ns1__getLcuLogOperationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getLcuLogOperationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getLcuLogOperationResponse, sizeof(_ns1__getLcuLogOperationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getLcuLogOperationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getLcuLogOperationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message_USCOREresult1 = 1;
	struct soap_blist *soap_blist_lcuLoglist1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message_USCOREresult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", &(a->_ns1__getLcuLogOperationResponse::message_USCOREresult), "ns1:MESSAGE_RESULT_Enum"))
				{	soap_flag_message_USCOREresult1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "lcuLoglist", 1, NULL))
			{	if (a->_ns1__getLcuLogOperationResponse::lcuLoglist == NULL)
				{	if (soap_blist_lcuLoglist1 == NULL)
						soap_blist_lcuLoglist1 = soap_new_block(soap);
					a->_ns1__getLcuLogOperationResponse::lcuLoglist = (ns1__LCULOGINFOType **)soap_push_block(soap, soap_blist_lcuLoglist1, sizeof(ns1__LCULOGINFOType *));
					if (a->_ns1__getLcuLogOperationResponse::lcuLoglist == NULL)
						return NULL;
					*a->_ns1__getLcuLogOperationResponse::lcuLoglist = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__LCULOGINFOType(soap, "lcuLoglist", a->_ns1__getLcuLogOperationResponse::lcuLoglist, "ns1:LCULOGINFOType"))
				{	a->_ns1__getLcuLogOperationResponse::__sizelcuLoglist++;
					a->_ns1__getLcuLogOperationResponse::lcuLoglist = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_ns1__getLcuLogOperationResponse::lcuLoglist)
			soap_pop_block(soap, soap_blist_lcuLoglist1);
		if (a->_ns1__getLcuLogOperationResponse::__sizelcuLoglist)
			a->_ns1__getLcuLogOperationResponse::lcuLoglist = (ns1__LCULOGINFOType **)soap_save_block(soap, soap_blist_lcuLoglist1, NULL, 1);
		else
		{	a->_ns1__getLcuLogOperationResponse::lcuLoglist = NULL;
			if (soap_blist_lcuLoglist1)
				soap_end_block(soap, soap_blist_lcuLoglist1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getLcuLogOperationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getLcuLogOperationResponse, 0, sizeof(_ns1__getLcuLogOperationResponse), 0, soap_copy__ns1__getLcuLogOperationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_message_USCOREresult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getLcuLogOperationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getLcuLogOperationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getLcuLogOperationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getLcuLogOperationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getLcuLogOperationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getLcuLogOperationResponse * SOAP_FMAC4 soap_get__ns1__getLcuLogOperationResponse(struct soap *soap, _ns1__getLcuLogOperationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getLcuLogOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getLcuLogOperationResponse * SOAP_FMAC2 soap_instantiate__ns1__getLcuLogOperationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getLcuLogOperationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getLcuLogOperationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getLcuLogOperationResponse);
		if (size)
			*size = sizeof(_ns1__getLcuLogOperationResponse);
		((_ns1__getLcuLogOperationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getLcuLogOperationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getLcuLogOperationResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getLcuLogOperationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getLcuLogOperationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getLcuLogOperationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getLcuLogOperationResponse %p -> %p\n", q, p));
	*(_ns1__getLcuLogOperationResponse*)p = *(_ns1__getLcuLogOperationResponse*)q;
}

void _ns1__getLcuLogOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getLcuLogOperation::current_USCORElogin_USCOREinfo = NULL;
	soap_default_string(soap, &this->_ns1__getLcuLogOperation::lcuId);
	soap_default_string(soap, &this->_ns1__getLcuLogOperation::timeForm);
	soap_default_string(soap, &this->_ns1__getLcuLogOperation::timeTo);
	/* transient soap skipped */
}

void _ns1__getLcuLogOperation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, &this->_ns1__getLcuLogOperation::current_USCORElogin_USCOREinfo);
	soap_serialize_string(soap, &this->_ns1__getLcuLogOperation::lcuId);
	soap_serialize_string(soap, &this->_ns1__getLcuLogOperation::timeForm);
	soap_serialize_string(soap, &this->_ns1__getLcuLogOperation::timeTo);
	/* transient soap skipped */
}

int _ns1__getLcuLogOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getLcuLogOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getLcuLogOperation(struct soap *soap, const char *tag, int id, const _ns1__getLcuLogOperation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getLcuLogOperation), type))
		return soap->error;
	if (a->_ns1__getLcuLogOperation::current_USCORElogin_USCOREinfo)
	{	if (soap_out_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", -1, &a->_ns1__getLcuLogOperation::current_USCORElogin_USCOREinfo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "current_login_info"))
		return soap->error;
	if (a->_ns1__getLcuLogOperation::lcuId)
	{	if (soap_out_string(soap, "lcuId", -1, &a->_ns1__getLcuLogOperation::lcuId, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "lcuId"))
		return soap->error;
	if (a->_ns1__getLcuLogOperation::timeForm)
	{	if (soap_out_string(soap, "timeForm", -1, &a->_ns1__getLcuLogOperation::timeForm, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "timeForm"))
		return soap->error;
	if (a->_ns1__getLcuLogOperation::timeTo)
	{	if (soap_out_string(soap, "timeTo", -1, &a->_ns1__getLcuLogOperation::timeTo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "timeTo"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getLcuLogOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getLcuLogOperation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getLcuLogOperation * SOAP_FMAC4 soap_in__ns1__getLcuLogOperation(struct soap *soap, const char *tag, _ns1__getLcuLogOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getLcuLogOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getLcuLogOperation, sizeof(_ns1__getLcuLogOperation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getLcuLogOperation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getLcuLogOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_current_USCORElogin_USCOREinfo1 = 1;
	size_t soap_flag_lcuId1 = 1;
	size_t soap_flag_timeForm1 = 1;
	size_t soap_flag_timeTo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_current_USCORElogin_USCOREinfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", &(a->_ns1__getLcuLogOperation::current_USCORElogin_USCOREinfo), "ns1:CURR_LOGIN_INFO_Type"))
				{	soap_flag_current_USCORElogin_USCOREinfo1--;
					continue;
				}
			if (soap_flag_lcuId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "lcuId", &(a->_ns1__getLcuLogOperation::lcuId), "xsd:string"))
				{	soap_flag_lcuId1--;
					continue;
				}
			if (soap_flag_timeForm1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "timeForm", &(a->_ns1__getLcuLogOperation::timeForm), "xsd:string"))
				{	soap_flag_timeForm1--;
					continue;
				}
			if (soap_flag_timeTo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "timeTo", &(a->_ns1__getLcuLogOperation::timeTo), "xsd:string"))
				{	soap_flag_timeTo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getLcuLogOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getLcuLogOperation, 0, sizeof(_ns1__getLcuLogOperation), 0, soap_copy__ns1__getLcuLogOperation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_current_USCORElogin_USCOREinfo1 > 0 || soap_flag_lcuId1 > 0 || soap_flag_timeForm1 > 0 || soap_flag_timeTo1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getLcuLogOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getLcuLogOperation);
	if (this->soap_out(soap, tag?tag:"ns1:getLcuLogOperation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getLcuLogOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getLcuLogOperation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getLcuLogOperation * SOAP_FMAC4 soap_get__ns1__getLcuLogOperation(struct soap *soap, _ns1__getLcuLogOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getLcuLogOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getLcuLogOperation * SOAP_FMAC2 soap_instantiate__ns1__getLcuLogOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getLcuLogOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getLcuLogOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getLcuLogOperation);
		if (size)
			*size = sizeof(_ns1__getLcuLogOperation);
		((_ns1__getLcuLogOperation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getLcuLogOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getLcuLogOperation);
		for (int i = 0; i < n; i++)
			((_ns1__getLcuLogOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getLcuLogOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getLcuLogOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getLcuLogOperation %p -> %p\n", q, p));
	*(_ns1__getLcuLogOperation*)p = *(_ns1__getLcuLogOperation*)q;
}

void _ns1__removeScheduleOperationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, &this->_ns1__removeScheduleOperationResponse::message_USCOREresult);
	/* transient soap skipped */
}

void _ns1__removeScheduleOperationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__removeScheduleOperationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__removeScheduleOperationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__removeScheduleOperationResponse(struct soap *soap, const char *tag, int id, const _ns1__removeScheduleOperationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__removeScheduleOperationResponse), type))
		return soap->error;
	if (soap_out_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", -1, &(a->_ns1__removeScheduleOperationResponse::message_USCOREresult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__removeScheduleOperationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__removeScheduleOperationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__removeScheduleOperationResponse * SOAP_FMAC4 soap_in__ns1__removeScheduleOperationResponse(struct soap *soap, const char *tag, _ns1__removeScheduleOperationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__removeScheduleOperationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__removeScheduleOperationResponse, sizeof(_ns1__removeScheduleOperationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__removeScheduleOperationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__removeScheduleOperationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message_USCOREresult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message_USCOREresult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", &(a->_ns1__removeScheduleOperationResponse::message_USCOREresult), "ns1:MESSAGE_RESULT_Enum"))
				{	soap_flag_message_USCOREresult1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__removeScheduleOperationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__removeScheduleOperationResponse, 0, sizeof(_ns1__removeScheduleOperationResponse), 0, soap_copy__ns1__removeScheduleOperationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_message_USCOREresult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__removeScheduleOperationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__removeScheduleOperationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:removeScheduleOperationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__removeScheduleOperationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__removeScheduleOperationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__removeScheduleOperationResponse * SOAP_FMAC4 soap_get__ns1__removeScheduleOperationResponse(struct soap *soap, _ns1__removeScheduleOperationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__removeScheduleOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__removeScheduleOperationResponse * SOAP_FMAC2 soap_instantiate__ns1__removeScheduleOperationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__removeScheduleOperationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__removeScheduleOperationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__removeScheduleOperationResponse);
		if (size)
			*size = sizeof(_ns1__removeScheduleOperationResponse);
		((_ns1__removeScheduleOperationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__removeScheduleOperationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__removeScheduleOperationResponse);
		for (int i = 0; i < n; i++)
			((_ns1__removeScheduleOperationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__removeScheduleOperationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__removeScheduleOperationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__removeScheduleOperationResponse %p -> %p\n", q, p));
	*(_ns1__removeScheduleOperationResponse*)p = *(_ns1__removeScheduleOperationResponse*)q;
}

void _ns1__removeScheduleOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__removeScheduleOperation::current_USCORElogin_USCOREinfo = NULL;
	soap_default_int(soap, &this->_ns1__removeScheduleOperation::schedule_USCOREid);
	/* transient soap skipped */
}

void _ns1__removeScheduleOperation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, &this->_ns1__removeScheduleOperation::current_USCORElogin_USCOREinfo);
	/* transient soap skipped */
}

int _ns1__removeScheduleOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__removeScheduleOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__removeScheduleOperation(struct soap *soap, const char *tag, int id, const _ns1__removeScheduleOperation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__removeScheduleOperation), type))
		return soap->error;
	if (a->_ns1__removeScheduleOperation::current_USCORElogin_USCOREinfo)
	{	if (soap_out_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", -1, &a->_ns1__removeScheduleOperation::current_USCORElogin_USCOREinfo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "current_login_info"))
		return soap->error;
	if (soap_out_int(soap, "schedule_id", -1, &(a->_ns1__removeScheduleOperation::schedule_USCOREid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__removeScheduleOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__removeScheduleOperation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__removeScheduleOperation * SOAP_FMAC4 soap_in__ns1__removeScheduleOperation(struct soap *soap, const char *tag, _ns1__removeScheduleOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__removeScheduleOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__removeScheduleOperation, sizeof(_ns1__removeScheduleOperation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__removeScheduleOperation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__removeScheduleOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_current_USCORElogin_USCOREinfo1 = 1;
	size_t soap_flag_schedule_USCOREid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_current_USCORElogin_USCOREinfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", &(a->_ns1__removeScheduleOperation::current_USCORElogin_USCOREinfo), "ns1:CURR_LOGIN_INFO_Type"))
				{	soap_flag_current_USCORElogin_USCOREinfo1--;
					continue;
				}
			if (soap_flag_schedule_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "schedule_id", &(a->_ns1__removeScheduleOperation::schedule_USCOREid), "xsd:int"))
				{	soap_flag_schedule_USCOREid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__removeScheduleOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__removeScheduleOperation, 0, sizeof(_ns1__removeScheduleOperation), 0, soap_copy__ns1__removeScheduleOperation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_current_USCORElogin_USCOREinfo1 > 0 || soap_flag_schedule_USCOREid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__removeScheduleOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__removeScheduleOperation);
	if (this->soap_out(soap, tag?tag:"ns1:removeScheduleOperation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__removeScheduleOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__removeScheduleOperation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__removeScheduleOperation * SOAP_FMAC4 soap_get__ns1__removeScheduleOperation(struct soap *soap, _ns1__removeScheduleOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__removeScheduleOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__removeScheduleOperation * SOAP_FMAC2 soap_instantiate__ns1__removeScheduleOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__removeScheduleOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__removeScheduleOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__removeScheduleOperation);
		if (size)
			*size = sizeof(_ns1__removeScheduleOperation);
		((_ns1__removeScheduleOperation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__removeScheduleOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__removeScheduleOperation);
		for (int i = 0; i < n; i++)
			((_ns1__removeScheduleOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__removeScheduleOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__removeScheduleOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__removeScheduleOperation %p -> %p\n", q, p));
	*(_ns1__removeScheduleOperation*)p = *(_ns1__removeScheduleOperation*)q;
}

void _ns1__editScheduleOperationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, &this->_ns1__editScheduleOperationResponse::message_USCOREresult);
	/* transient soap skipped */
}

void _ns1__editScheduleOperationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__editScheduleOperationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__editScheduleOperationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__editScheduleOperationResponse(struct soap *soap, const char *tag, int id, const _ns1__editScheduleOperationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__editScheduleOperationResponse), type))
		return soap->error;
	if (soap_out_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", -1, &(a->_ns1__editScheduleOperationResponse::message_USCOREresult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__editScheduleOperationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__editScheduleOperationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__editScheduleOperationResponse * SOAP_FMAC4 soap_in__ns1__editScheduleOperationResponse(struct soap *soap, const char *tag, _ns1__editScheduleOperationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__editScheduleOperationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__editScheduleOperationResponse, sizeof(_ns1__editScheduleOperationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__editScheduleOperationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__editScheduleOperationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message_USCOREresult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message_USCOREresult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", &(a->_ns1__editScheduleOperationResponse::message_USCOREresult), "ns1:MESSAGE_RESULT_Enum"))
				{	soap_flag_message_USCOREresult1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__editScheduleOperationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__editScheduleOperationResponse, 0, sizeof(_ns1__editScheduleOperationResponse), 0, soap_copy__ns1__editScheduleOperationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_message_USCOREresult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__editScheduleOperationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__editScheduleOperationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:editScheduleOperationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__editScheduleOperationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__editScheduleOperationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__editScheduleOperationResponse * SOAP_FMAC4 soap_get__ns1__editScheduleOperationResponse(struct soap *soap, _ns1__editScheduleOperationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__editScheduleOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__editScheduleOperationResponse * SOAP_FMAC2 soap_instantiate__ns1__editScheduleOperationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__editScheduleOperationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__editScheduleOperationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__editScheduleOperationResponse);
		if (size)
			*size = sizeof(_ns1__editScheduleOperationResponse);
		((_ns1__editScheduleOperationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__editScheduleOperationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__editScheduleOperationResponse);
		for (int i = 0; i < n; i++)
			((_ns1__editScheduleOperationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__editScheduleOperationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__editScheduleOperationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__editScheduleOperationResponse %p -> %p\n", q, p));
	*(_ns1__editScheduleOperationResponse*)p = *(_ns1__editScheduleOperationResponse*)q;
}

void _ns1__editScheduleOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__editScheduleOperation::current_USCORElogin_USCOREinfo = NULL;
	this->_ns1__editScheduleOperation::schedule = NULL;
	/* transient soap skipped */
}

void _ns1__editScheduleOperation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, &this->_ns1__editScheduleOperation::current_USCORElogin_USCOREinfo);
	soap_serialize_PointerTons1__SCHEDULE_USCOREINFO_USCOREType(soap, &this->_ns1__editScheduleOperation::schedule);
	/* transient soap skipped */
}

int _ns1__editScheduleOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__editScheduleOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__editScheduleOperation(struct soap *soap, const char *tag, int id, const _ns1__editScheduleOperation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__editScheduleOperation), type))
		return soap->error;
	if (a->_ns1__editScheduleOperation::current_USCORElogin_USCOREinfo)
	{	if (soap_out_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", -1, &a->_ns1__editScheduleOperation::current_USCORElogin_USCOREinfo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "current_login_info"))
		return soap->error;
	if (a->_ns1__editScheduleOperation::schedule)
	{	if (soap_out_PointerTons1__SCHEDULE_USCOREINFO_USCOREType(soap, "schedule", -1, &a->_ns1__editScheduleOperation::schedule, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "schedule"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__editScheduleOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__editScheduleOperation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__editScheduleOperation * SOAP_FMAC4 soap_in__ns1__editScheduleOperation(struct soap *soap, const char *tag, _ns1__editScheduleOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__editScheduleOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__editScheduleOperation, sizeof(_ns1__editScheduleOperation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__editScheduleOperation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__editScheduleOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_current_USCORElogin_USCOREinfo1 = 1;
	size_t soap_flag_schedule1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_current_USCORElogin_USCOREinfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", &(a->_ns1__editScheduleOperation::current_USCORElogin_USCOREinfo), "ns1:CURR_LOGIN_INFO_Type"))
				{	soap_flag_current_USCORElogin_USCOREinfo1--;
					continue;
				}
			if (soap_flag_schedule1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SCHEDULE_USCOREINFO_USCOREType(soap, "schedule", &(a->_ns1__editScheduleOperation::schedule), "ns1:SCHEDULE_INFO_Type"))
				{	soap_flag_schedule1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__editScheduleOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__editScheduleOperation, 0, sizeof(_ns1__editScheduleOperation), 0, soap_copy__ns1__editScheduleOperation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_current_USCORElogin_USCOREinfo1 > 0 || soap_flag_schedule1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__editScheduleOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__editScheduleOperation);
	if (this->soap_out(soap, tag?tag:"ns1:editScheduleOperation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__editScheduleOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__editScheduleOperation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__editScheduleOperation * SOAP_FMAC4 soap_get__ns1__editScheduleOperation(struct soap *soap, _ns1__editScheduleOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__editScheduleOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__editScheduleOperation * SOAP_FMAC2 soap_instantiate__ns1__editScheduleOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__editScheduleOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__editScheduleOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__editScheduleOperation);
		if (size)
			*size = sizeof(_ns1__editScheduleOperation);
		((_ns1__editScheduleOperation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__editScheduleOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__editScheduleOperation);
		for (int i = 0; i < n; i++)
			((_ns1__editScheduleOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__editScheduleOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__editScheduleOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__editScheduleOperation %p -> %p\n", q, p));
	*(_ns1__editScheduleOperation*)p = *(_ns1__editScheduleOperation*)q;
}

void _ns1__addScheduleOperationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, &this->_ns1__addScheduleOperationResponse::message_USCOREresult);
	soap_default_int(soap, &this->_ns1__addScheduleOperationResponse::schedule_USCOREid);
	/* transient soap skipped */
}

void _ns1__addScheduleOperationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__addScheduleOperationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__addScheduleOperationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__addScheduleOperationResponse(struct soap *soap, const char *tag, int id, const _ns1__addScheduleOperationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__addScheduleOperationResponse), type))
		return soap->error;
	if (soap_out_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", -1, &(a->_ns1__addScheduleOperationResponse::message_USCOREresult), ""))
		return soap->error;
	if (soap_out_int(soap, "schedule_id", -1, &(a->_ns1__addScheduleOperationResponse::schedule_USCOREid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__addScheduleOperationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__addScheduleOperationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__addScheduleOperationResponse * SOAP_FMAC4 soap_in__ns1__addScheduleOperationResponse(struct soap *soap, const char *tag, _ns1__addScheduleOperationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__addScheduleOperationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__addScheduleOperationResponse, sizeof(_ns1__addScheduleOperationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__addScheduleOperationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__addScheduleOperationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message_USCOREresult1 = 1;
	size_t soap_flag_schedule_USCOREid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message_USCOREresult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", &(a->_ns1__addScheduleOperationResponse::message_USCOREresult), "ns1:MESSAGE_RESULT_Enum"))
				{	soap_flag_message_USCOREresult1--;
					continue;
				}
			if (soap_flag_schedule_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "schedule_id", &(a->_ns1__addScheduleOperationResponse::schedule_USCOREid), "xsd:int"))
				{	soap_flag_schedule_USCOREid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__addScheduleOperationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__addScheduleOperationResponse, 0, sizeof(_ns1__addScheduleOperationResponse), 0, soap_copy__ns1__addScheduleOperationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_message_USCOREresult1 > 0 || soap_flag_schedule_USCOREid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__addScheduleOperationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__addScheduleOperationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:addScheduleOperationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__addScheduleOperationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__addScheduleOperationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__addScheduleOperationResponse * SOAP_FMAC4 soap_get__ns1__addScheduleOperationResponse(struct soap *soap, _ns1__addScheduleOperationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__addScheduleOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__addScheduleOperationResponse * SOAP_FMAC2 soap_instantiate__ns1__addScheduleOperationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__addScheduleOperationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__addScheduleOperationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__addScheduleOperationResponse);
		if (size)
			*size = sizeof(_ns1__addScheduleOperationResponse);
		((_ns1__addScheduleOperationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__addScheduleOperationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__addScheduleOperationResponse);
		for (int i = 0; i < n; i++)
			((_ns1__addScheduleOperationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__addScheduleOperationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__addScheduleOperationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__addScheduleOperationResponse %p -> %p\n", q, p));
	*(_ns1__addScheduleOperationResponse*)p = *(_ns1__addScheduleOperationResponse*)q;
}

void _ns1__addScheduleOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__addScheduleOperation::current_USCORElogin_USCOREinfo = NULL;
	this->_ns1__addScheduleOperation::schedule = NULL;
	/* transient soap skipped */
}

void _ns1__addScheduleOperation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, &this->_ns1__addScheduleOperation::current_USCORElogin_USCOREinfo);
	soap_serialize_PointerTons1__SCHEDULE_USCOREINFO_USCOREType(soap, &this->_ns1__addScheduleOperation::schedule);
	/* transient soap skipped */
}

int _ns1__addScheduleOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__addScheduleOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__addScheduleOperation(struct soap *soap, const char *tag, int id, const _ns1__addScheduleOperation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__addScheduleOperation), type))
		return soap->error;
	if (a->_ns1__addScheduleOperation::current_USCORElogin_USCOREinfo)
	{	if (soap_out_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", -1, &a->_ns1__addScheduleOperation::current_USCORElogin_USCOREinfo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "current_login_info"))
		return soap->error;
	if (a->_ns1__addScheduleOperation::schedule)
	{	if (soap_out_PointerTons1__SCHEDULE_USCOREINFO_USCOREType(soap, "schedule", -1, &a->_ns1__addScheduleOperation::schedule, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "schedule"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__addScheduleOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__addScheduleOperation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__addScheduleOperation * SOAP_FMAC4 soap_in__ns1__addScheduleOperation(struct soap *soap, const char *tag, _ns1__addScheduleOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__addScheduleOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__addScheduleOperation, sizeof(_ns1__addScheduleOperation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__addScheduleOperation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__addScheduleOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_current_USCORElogin_USCOREinfo1 = 1;
	size_t soap_flag_schedule1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_current_USCORElogin_USCOREinfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", &(a->_ns1__addScheduleOperation::current_USCORElogin_USCOREinfo), "ns1:CURR_LOGIN_INFO_Type"))
				{	soap_flag_current_USCORElogin_USCOREinfo1--;
					continue;
				}
			if (soap_flag_schedule1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SCHEDULE_USCOREINFO_USCOREType(soap, "schedule", &(a->_ns1__addScheduleOperation::schedule), "ns1:SCHEDULE_INFO_Type"))
				{	soap_flag_schedule1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__addScheduleOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__addScheduleOperation, 0, sizeof(_ns1__addScheduleOperation), 0, soap_copy__ns1__addScheduleOperation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_current_USCORElogin_USCOREinfo1 > 0 || soap_flag_schedule1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__addScheduleOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__addScheduleOperation);
	if (this->soap_out(soap, tag?tag:"ns1:addScheduleOperation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__addScheduleOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__addScheduleOperation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__addScheduleOperation * SOAP_FMAC4 soap_get__ns1__addScheduleOperation(struct soap *soap, _ns1__addScheduleOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__addScheduleOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__addScheduleOperation * SOAP_FMAC2 soap_instantiate__ns1__addScheduleOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__addScheduleOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__addScheduleOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__addScheduleOperation);
		if (size)
			*size = sizeof(_ns1__addScheduleOperation);
		((_ns1__addScheduleOperation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__addScheduleOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__addScheduleOperation);
		for (int i = 0; i < n; i++)
			((_ns1__addScheduleOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__addScheduleOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__addScheduleOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__addScheduleOperation %p -> %p\n", q, p));
	*(_ns1__addScheduleOperation*)p = *(_ns1__addScheduleOperation*)q;
}

void _ns1__getScheduleOperationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, &this->_ns1__getScheduleOperationResponse::message_USCOREresult);
	this->_ns1__getScheduleOperationResponse::__sizeschedule_USCORElist = 0;
	this->_ns1__getScheduleOperationResponse::schedule_USCORElist = NULL;
	/* transient soap skipped */
}

void _ns1__getScheduleOperationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->_ns1__getScheduleOperationResponse::schedule_USCORElist)
	{	int i;
		for (i = 0; i < this->_ns1__getScheduleOperationResponse::__sizeschedule_USCORElist; i++)
		{
			soap_serialize_PointerTons1__SCHEDULE_USCOREINFO_USCOREType(soap, this->_ns1__getScheduleOperationResponse::schedule_USCORElist + i);
		}
	}
	/* transient soap skipped */
}

int _ns1__getScheduleOperationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getScheduleOperationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getScheduleOperationResponse(struct soap *soap, const char *tag, int id, const _ns1__getScheduleOperationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getScheduleOperationResponse), type))
		return soap->error;
	if (soap_out_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", -1, &(a->_ns1__getScheduleOperationResponse::message_USCOREresult), ""))
		return soap->error;
	if (a->_ns1__getScheduleOperationResponse::schedule_USCORElist)
	{	int i;
		for (i = 0; i < a->_ns1__getScheduleOperationResponse::__sizeschedule_USCORElist; i++)
			if (soap_out_PointerTons1__SCHEDULE_USCOREINFO_USCOREType(soap, "schedule_list", -1, a->_ns1__getScheduleOperationResponse::schedule_USCORElist + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getScheduleOperationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getScheduleOperationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getScheduleOperationResponse * SOAP_FMAC4 soap_in__ns1__getScheduleOperationResponse(struct soap *soap, const char *tag, _ns1__getScheduleOperationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getScheduleOperationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getScheduleOperationResponse, sizeof(_ns1__getScheduleOperationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getScheduleOperationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getScheduleOperationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message_USCOREresult1 = 1;
	struct soap_blist *soap_blist_schedule_USCORElist1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message_USCOREresult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", &(a->_ns1__getScheduleOperationResponse::message_USCOREresult), "ns1:MESSAGE_RESULT_Enum"))
				{	soap_flag_message_USCOREresult1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "schedule_list", 1, NULL))
			{	if (a->_ns1__getScheduleOperationResponse::schedule_USCORElist == NULL)
				{	if (soap_blist_schedule_USCORElist1 == NULL)
						soap_blist_schedule_USCORElist1 = soap_new_block(soap);
					a->_ns1__getScheduleOperationResponse::schedule_USCORElist = (ns1__SCHEDULE_USCOREINFO_USCOREType **)soap_push_block(soap, soap_blist_schedule_USCORElist1, sizeof(ns1__SCHEDULE_USCOREINFO_USCOREType *));
					if (a->_ns1__getScheduleOperationResponse::schedule_USCORElist == NULL)
						return NULL;
					*a->_ns1__getScheduleOperationResponse::schedule_USCORElist = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__SCHEDULE_USCOREINFO_USCOREType(soap, "schedule_list", a->_ns1__getScheduleOperationResponse::schedule_USCORElist, "ns1:SCHEDULE_INFO_Type"))
				{	a->_ns1__getScheduleOperationResponse::__sizeschedule_USCORElist++;
					a->_ns1__getScheduleOperationResponse::schedule_USCORElist = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_ns1__getScheduleOperationResponse::schedule_USCORElist)
			soap_pop_block(soap, soap_blist_schedule_USCORElist1);
		if (a->_ns1__getScheduleOperationResponse::__sizeschedule_USCORElist)
			a->_ns1__getScheduleOperationResponse::schedule_USCORElist = (ns1__SCHEDULE_USCOREINFO_USCOREType **)soap_save_block(soap, soap_blist_schedule_USCORElist1, NULL, 1);
		else
		{	a->_ns1__getScheduleOperationResponse::schedule_USCORElist = NULL;
			if (soap_blist_schedule_USCORElist1)
				soap_end_block(soap, soap_blist_schedule_USCORElist1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getScheduleOperationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getScheduleOperationResponse, 0, sizeof(_ns1__getScheduleOperationResponse), 0, soap_copy__ns1__getScheduleOperationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_message_USCOREresult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getScheduleOperationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getScheduleOperationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getScheduleOperationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getScheduleOperationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getScheduleOperationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getScheduleOperationResponse * SOAP_FMAC4 soap_get__ns1__getScheduleOperationResponse(struct soap *soap, _ns1__getScheduleOperationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getScheduleOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getScheduleOperationResponse * SOAP_FMAC2 soap_instantiate__ns1__getScheduleOperationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getScheduleOperationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getScheduleOperationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getScheduleOperationResponse);
		if (size)
			*size = sizeof(_ns1__getScheduleOperationResponse);
		((_ns1__getScheduleOperationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getScheduleOperationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getScheduleOperationResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getScheduleOperationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getScheduleOperationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getScheduleOperationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getScheduleOperationResponse %p -> %p\n", q, p));
	*(_ns1__getScheduleOperationResponse*)p = *(_ns1__getScheduleOperationResponse*)q;
}

void _ns1__getScheduleOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getScheduleOperation::current_USCORElogin_USCOREinfo = NULL;
	soap_default_int(soap, &this->_ns1__getScheduleOperation::listschedule_USCOREid);
	soap_default_int(soap, &this->_ns1__getScheduleOperation::schedule_USCOREid);
	/* transient soap skipped */
}

void _ns1__getScheduleOperation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, &this->_ns1__getScheduleOperation::current_USCORElogin_USCOREinfo);
	/* transient soap skipped */
}

int _ns1__getScheduleOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getScheduleOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getScheduleOperation(struct soap *soap, const char *tag, int id, const _ns1__getScheduleOperation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getScheduleOperation), type))
		return soap->error;
	if (a->_ns1__getScheduleOperation::current_USCORElogin_USCOREinfo)
	{	if (soap_out_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", -1, &a->_ns1__getScheduleOperation::current_USCORElogin_USCOREinfo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "current_login_info"))
		return soap->error;
	if (soap_out_int(soap, "listschedule_id", -1, &(a->_ns1__getScheduleOperation::listschedule_USCOREid), ""))
		return soap->error;
	if (soap_out_int(soap, "schedule_id", -1, &(a->_ns1__getScheduleOperation::schedule_USCOREid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getScheduleOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getScheduleOperation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getScheduleOperation * SOAP_FMAC4 soap_in__ns1__getScheduleOperation(struct soap *soap, const char *tag, _ns1__getScheduleOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getScheduleOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getScheduleOperation, sizeof(_ns1__getScheduleOperation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getScheduleOperation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getScheduleOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_current_USCORElogin_USCOREinfo1 = 1;
	size_t soap_flag_listschedule_USCOREid1 = 1;
	size_t soap_flag_schedule_USCOREid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_current_USCORElogin_USCOREinfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", &(a->_ns1__getScheduleOperation::current_USCORElogin_USCOREinfo), "ns1:CURR_LOGIN_INFO_Type"))
				{	soap_flag_current_USCORElogin_USCOREinfo1--;
					continue;
				}
			if (soap_flag_listschedule_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "listschedule_id", &(a->_ns1__getScheduleOperation::listschedule_USCOREid), "xsd:int"))
				{	soap_flag_listschedule_USCOREid1--;
					continue;
				}
			if (soap_flag_schedule_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "schedule_id", &(a->_ns1__getScheduleOperation::schedule_USCOREid), "xsd:int"))
				{	soap_flag_schedule_USCOREid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getScheduleOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getScheduleOperation, 0, sizeof(_ns1__getScheduleOperation), 0, soap_copy__ns1__getScheduleOperation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_current_USCORElogin_USCOREinfo1 > 0 || soap_flag_listschedule_USCOREid1 > 0 || soap_flag_schedule_USCOREid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getScheduleOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getScheduleOperation);
	if (this->soap_out(soap, tag?tag:"ns1:getScheduleOperation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getScheduleOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getScheduleOperation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getScheduleOperation * SOAP_FMAC4 soap_get__ns1__getScheduleOperation(struct soap *soap, _ns1__getScheduleOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getScheduleOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getScheduleOperation * SOAP_FMAC2 soap_instantiate__ns1__getScheduleOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getScheduleOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getScheduleOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getScheduleOperation);
		if (size)
			*size = sizeof(_ns1__getScheduleOperation);
		((_ns1__getScheduleOperation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getScheduleOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getScheduleOperation);
		for (int i = 0; i < n; i++)
			((_ns1__getScheduleOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getScheduleOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getScheduleOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getScheduleOperation %p -> %p\n", q, p));
	*(_ns1__getScheduleOperation*)p = *(_ns1__getScheduleOperation*)q;
}

void _ns1__removeListScheduleOperationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, &this->_ns1__removeListScheduleOperationResponse::message_USCOREresult);
	/* transient soap skipped */
}

void _ns1__removeListScheduleOperationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__removeListScheduleOperationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__removeListScheduleOperationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__removeListScheduleOperationResponse(struct soap *soap, const char *tag, int id, const _ns1__removeListScheduleOperationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__removeListScheduleOperationResponse), type))
		return soap->error;
	if (soap_out_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", -1, &(a->_ns1__removeListScheduleOperationResponse::message_USCOREresult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__removeListScheduleOperationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__removeListScheduleOperationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__removeListScheduleOperationResponse * SOAP_FMAC4 soap_in__ns1__removeListScheduleOperationResponse(struct soap *soap, const char *tag, _ns1__removeListScheduleOperationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__removeListScheduleOperationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__removeListScheduleOperationResponse, sizeof(_ns1__removeListScheduleOperationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__removeListScheduleOperationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__removeListScheduleOperationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message_USCOREresult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message_USCOREresult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", &(a->_ns1__removeListScheduleOperationResponse::message_USCOREresult), "ns1:MESSAGE_RESULT_Enum"))
				{	soap_flag_message_USCOREresult1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__removeListScheduleOperationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__removeListScheduleOperationResponse, 0, sizeof(_ns1__removeListScheduleOperationResponse), 0, soap_copy__ns1__removeListScheduleOperationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_message_USCOREresult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__removeListScheduleOperationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__removeListScheduleOperationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:removeListScheduleOperationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__removeListScheduleOperationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__removeListScheduleOperationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__removeListScheduleOperationResponse * SOAP_FMAC4 soap_get__ns1__removeListScheduleOperationResponse(struct soap *soap, _ns1__removeListScheduleOperationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__removeListScheduleOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__removeListScheduleOperationResponse * SOAP_FMAC2 soap_instantiate__ns1__removeListScheduleOperationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__removeListScheduleOperationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__removeListScheduleOperationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__removeListScheduleOperationResponse);
		if (size)
			*size = sizeof(_ns1__removeListScheduleOperationResponse);
		((_ns1__removeListScheduleOperationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__removeListScheduleOperationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__removeListScheduleOperationResponse);
		for (int i = 0; i < n; i++)
			((_ns1__removeListScheduleOperationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__removeListScheduleOperationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__removeListScheduleOperationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__removeListScheduleOperationResponse %p -> %p\n", q, p));
	*(_ns1__removeListScheduleOperationResponse*)p = *(_ns1__removeListScheduleOperationResponse*)q;
}

void _ns1__removeListScheduleOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__removeListScheduleOperation::current_USCORElogin_USCOREinfo = NULL;
	soap_default_int(soap, &this->_ns1__removeListScheduleOperation::listschedule_USCOREid);
	/* transient soap skipped */
}

void _ns1__removeListScheduleOperation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, &this->_ns1__removeListScheduleOperation::current_USCORElogin_USCOREinfo);
	/* transient soap skipped */
}

int _ns1__removeListScheduleOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__removeListScheduleOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__removeListScheduleOperation(struct soap *soap, const char *tag, int id, const _ns1__removeListScheduleOperation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__removeListScheduleOperation), type))
		return soap->error;
	if (a->_ns1__removeListScheduleOperation::current_USCORElogin_USCOREinfo)
	{	if (soap_out_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", -1, &a->_ns1__removeListScheduleOperation::current_USCORElogin_USCOREinfo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "current_login_info"))
		return soap->error;
	if (soap_out_int(soap, "listschedule_id", -1, &(a->_ns1__removeListScheduleOperation::listschedule_USCOREid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__removeListScheduleOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__removeListScheduleOperation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__removeListScheduleOperation * SOAP_FMAC4 soap_in__ns1__removeListScheduleOperation(struct soap *soap, const char *tag, _ns1__removeListScheduleOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__removeListScheduleOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__removeListScheduleOperation, sizeof(_ns1__removeListScheduleOperation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__removeListScheduleOperation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__removeListScheduleOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_current_USCORElogin_USCOREinfo1 = 1;
	size_t soap_flag_listschedule_USCOREid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_current_USCORElogin_USCOREinfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", &(a->_ns1__removeListScheduleOperation::current_USCORElogin_USCOREinfo), "ns1:CURR_LOGIN_INFO_Type"))
				{	soap_flag_current_USCORElogin_USCOREinfo1--;
					continue;
				}
			if (soap_flag_listschedule_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "listschedule_id", &(a->_ns1__removeListScheduleOperation::listschedule_USCOREid), "xsd:int"))
				{	soap_flag_listschedule_USCOREid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__removeListScheduleOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__removeListScheduleOperation, 0, sizeof(_ns1__removeListScheduleOperation), 0, soap_copy__ns1__removeListScheduleOperation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_current_USCORElogin_USCOREinfo1 > 0 || soap_flag_listschedule_USCOREid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__removeListScheduleOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__removeListScheduleOperation);
	if (this->soap_out(soap, tag?tag:"ns1:removeListScheduleOperation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__removeListScheduleOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__removeListScheduleOperation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__removeListScheduleOperation * SOAP_FMAC4 soap_get__ns1__removeListScheduleOperation(struct soap *soap, _ns1__removeListScheduleOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__removeListScheduleOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__removeListScheduleOperation * SOAP_FMAC2 soap_instantiate__ns1__removeListScheduleOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__removeListScheduleOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__removeListScheduleOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__removeListScheduleOperation);
		if (size)
			*size = sizeof(_ns1__removeListScheduleOperation);
		((_ns1__removeListScheduleOperation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__removeListScheduleOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__removeListScheduleOperation);
		for (int i = 0; i < n; i++)
			((_ns1__removeListScheduleOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__removeListScheduleOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__removeListScheduleOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__removeListScheduleOperation %p -> %p\n", q, p));
	*(_ns1__removeListScheduleOperation*)p = *(_ns1__removeListScheduleOperation*)q;
}

void _ns1__editListScheduleOperationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, &this->_ns1__editListScheduleOperationResponse::message_USCOREresult);
	soap_default_int(soap, &this->_ns1__editListScheduleOperationResponse::listscheduleId);
	/* transient soap skipped */
}

void _ns1__editListScheduleOperationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__editListScheduleOperationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__editListScheduleOperationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__editListScheduleOperationResponse(struct soap *soap, const char *tag, int id, const _ns1__editListScheduleOperationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__editListScheduleOperationResponse), type))
		return soap->error;
	if (soap_out_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", -1, &(a->_ns1__editListScheduleOperationResponse::message_USCOREresult), ""))
		return soap->error;
	if (soap_out_int(soap, "listscheduleId", -1, &(a->_ns1__editListScheduleOperationResponse::listscheduleId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__editListScheduleOperationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__editListScheduleOperationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__editListScheduleOperationResponse * SOAP_FMAC4 soap_in__ns1__editListScheduleOperationResponse(struct soap *soap, const char *tag, _ns1__editListScheduleOperationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__editListScheduleOperationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__editListScheduleOperationResponse, sizeof(_ns1__editListScheduleOperationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__editListScheduleOperationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__editListScheduleOperationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message_USCOREresult1 = 1;
	size_t soap_flag_listscheduleId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message_USCOREresult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", &(a->_ns1__editListScheduleOperationResponse::message_USCOREresult), "ns1:MESSAGE_RESULT_Enum"))
				{	soap_flag_message_USCOREresult1--;
					continue;
				}
			if (soap_flag_listscheduleId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "listscheduleId", &(a->_ns1__editListScheduleOperationResponse::listscheduleId), "xsd:int"))
				{	soap_flag_listscheduleId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__editListScheduleOperationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__editListScheduleOperationResponse, 0, sizeof(_ns1__editListScheduleOperationResponse), 0, soap_copy__ns1__editListScheduleOperationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_message_USCOREresult1 > 0 || soap_flag_listscheduleId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__editListScheduleOperationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__editListScheduleOperationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:editListScheduleOperationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__editListScheduleOperationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__editListScheduleOperationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__editListScheduleOperationResponse * SOAP_FMAC4 soap_get__ns1__editListScheduleOperationResponse(struct soap *soap, _ns1__editListScheduleOperationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__editListScheduleOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__editListScheduleOperationResponse * SOAP_FMAC2 soap_instantiate__ns1__editListScheduleOperationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__editListScheduleOperationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__editListScheduleOperationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__editListScheduleOperationResponse);
		if (size)
			*size = sizeof(_ns1__editListScheduleOperationResponse);
		((_ns1__editListScheduleOperationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__editListScheduleOperationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__editListScheduleOperationResponse);
		for (int i = 0; i < n; i++)
			((_ns1__editListScheduleOperationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__editListScheduleOperationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__editListScheduleOperationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__editListScheduleOperationResponse %p -> %p\n", q, p));
	*(_ns1__editListScheduleOperationResponse*)p = *(_ns1__editListScheduleOperationResponse*)q;
}

void _ns1__editListScheduleOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__editListScheduleOperation::current_USCORElogin_USCOREinfo = NULL;
	this->_ns1__editListScheduleOperation::listschedule = NULL;
	/* transient soap skipped */
}

void _ns1__editListScheduleOperation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, &this->_ns1__editListScheduleOperation::current_USCORElogin_USCOREinfo);
	soap_serialize_PointerTons1__LISTSCHEDULE_USCOREINFO_USCOREType(soap, &this->_ns1__editListScheduleOperation::listschedule);
	/* transient soap skipped */
}

int _ns1__editListScheduleOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__editListScheduleOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__editListScheduleOperation(struct soap *soap, const char *tag, int id, const _ns1__editListScheduleOperation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__editListScheduleOperation), type))
		return soap->error;
	if (a->_ns1__editListScheduleOperation::current_USCORElogin_USCOREinfo)
	{	if (soap_out_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", -1, &a->_ns1__editListScheduleOperation::current_USCORElogin_USCOREinfo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "current_login_info"))
		return soap->error;
	if (a->_ns1__editListScheduleOperation::listschedule)
	{	if (soap_out_PointerTons1__LISTSCHEDULE_USCOREINFO_USCOREType(soap, "listschedule", -1, &a->_ns1__editListScheduleOperation::listschedule, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "listschedule"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__editListScheduleOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__editListScheduleOperation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__editListScheduleOperation * SOAP_FMAC4 soap_in__ns1__editListScheduleOperation(struct soap *soap, const char *tag, _ns1__editListScheduleOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__editListScheduleOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__editListScheduleOperation, sizeof(_ns1__editListScheduleOperation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__editListScheduleOperation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__editListScheduleOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_current_USCORElogin_USCOREinfo1 = 1;
	size_t soap_flag_listschedule1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_current_USCORElogin_USCOREinfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", &(a->_ns1__editListScheduleOperation::current_USCORElogin_USCOREinfo), "ns1:CURR_LOGIN_INFO_Type"))
				{	soap_flag_current_USCORElogin_USCOREinfo1--;
					continue;
				}
			if (soap_flag_listschedule1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__LISTSCHEDULE_USCOREINFO_USCOREType(soap, "listschedule", &(a->_ns1__editListScheduleOperation::listschedule), "ns1:LISTSCHEDULE_INFO_Type"))
				{	soap_flag_listschedule1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__editListScheduleOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__editListScheduleOperation, 0, sizeof(_ns1__editListScheduleOperation), 0, soap_copy__ns1__editListScheduleOperation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_current_USCORElogin_USCOREinfo1 > 0 || soap_flag_listschedule1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__editListScheduleOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__editListScheduleOperation);
	if (this->soap_out(soap, tag?tag:"ns1:editListScheduleOperation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__editListScheduleOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__editListScheduleOperation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__editListScheduleOperation * SOAP_FMAC4 soap_get__ns1__editListScheduleOperation(struct soap *soap, _ns1__editListScheduleOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__editListScheduleOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__editListScheduleOperation * SOAP_FMAC2 soap_instantiate__ns1__editListScheduleOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__editListScheduleOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__editListScheduleOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__editListScheduleOperation);
		if (size)
			*size = sizeof(_ns1__editListScheduleOperation);
		((_ns1__editListScheduleOperation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__editListScheduleOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__editListScheduleOperation);
		for (int i = 0; i < n; i++)
			((_ns1__editListScheduleOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__editListScheduleOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__editListScheduleOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__editListScheduleOperation %p -> %p\n", q, p));
	*(_ns1__editListScheduleOperation*)p = *(_ns1__editListScheduleOperation*)q;
}

void _ns1__addListScheduleOperationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, &this->_ns1__addListScheduleOperationResponse::message_USCOREresult);
	soap_default_int(soap, &this->_ns1__addListScheduleOperationResponse::listschedule_USCOREid);
	/* transient soap skipped */
}

void _ns1__addListScheduleOperationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__addListScheduleOperationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__addListScheduleOperationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__addListScheduleOperationResponse(struct soap *soap, const char *tag, int id, const _ns1__addListScheduleOperationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__addListScheduleOperationResponse), type))
		return soap->error;
	if (soap_out_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", -1, &(a->_ns1__addListScheduleOperationResponse::message_USCOREresult), ""))
		return soap->error;
	if (soap_out_int(soap, "listschedule_id", -1, &(a->_ns1__addListScheduleOperationResponse::listschedule_USCOREid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__addListScheduleOperationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__addListScheduleOperationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__addListScheduleOperationResponse * SOAP_FMAC4 soap_in__ns1__addListScheduleOperationResponse(struct soap *soap, const char *tag, _ns1__addListScheduleOperationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__addListScheduleOperationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__addListScheduleOperationResponse, sizeof(_ns1__addListScheduleOperationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__addListScheduleOperationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__addListScheduleOperationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message_USCOREresult1 = 1;
	size_t soap_flag_listschedule_USCOREid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message_USCOREresult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", &(a->_ns1__addListScheduleOperationResponse::message_USCOREresult), "ns1:MESSAGE_RESULT_Enum"))
				{	soap_flag_message_USCOREresult1--;
					continue;
				}
			if (soap_flag_listschedule_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "listschedule_id", &(a->_ns1__addListScheduleOperationResponse::listschedule_USCOREid), "xsd:int"))
				{	soap_flag_listschedule_USCOREid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__addListScheduleOperationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__addListScheduleOperationResponse, 0, sizeof(_ns1__addListScheduleOperationResponse), 0, soap_copy__ns1__addListScheduleOperationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_message_USCOREresult1 > 0 || soap_flag_listschedule_USCOREid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__addListScheduleOperationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__addListScheduleOperationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:addListScheduleOperationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__addListScheduleOperationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__addListScheduleOperationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__addListScheduleOperationResponse * SOAP_FMAC4 soap_get__ns1__addListScheduleOperationResponse(struct soap *soap, _ns1__addListScheduleOperationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__addListScheduleOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__addListScheduleOperationResponse * SOAP_FMAC2 soap_instantiate__ns1__addListScheduleOperationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__addListScheduleOperationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__addListScheduleOperationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__addListScheduleOperationResponse);
		if (size)
			*size = sizeof(_ns1__addListScheduleOperationResponse);
		((_ns1__addListScheduleOperationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__addListScheduleOperationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__addListScheduleOperationResponse);
		for (int i = 0; i < n; i++)
			((_ns1__addListScheduleOperationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__addListScheduleOperationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__addListScheduleOperationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__addListScheduleOperationResponse %p -> %p\n", q, p));
	*(_ns1__addListScheduleOperationResponse*)p = *(_ns1__addListScheduleOperationResponse*)q;
}

void _ns1__addListScheduleOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__addListScheduleOperation::current_USCORElogin_USCOREinfo = NULL;
	soap_default_string(soap, &this->_ns1__addListScheduleOperation::listschedule_USCOREname);
	soap_default_int(soap, &this->_ns1__addListScheduleOperation::listschedule_USCOREprogram_USCOREid);
	/* transient soap skipped */
}

void _ns1__addListScheduleOperation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, &this->_ns1__addListScheduleOperation::current_USCORElogin_USCOREinfo);
	soap_serialize_string(soap, &this->_ns1__addListScheduleOperation::listschedule_USCOREname);
	/* transient soap skipped */
}

int _ns1__addListScheduleOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__addListScheduleOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__addListScheduleOperation(struct soap *soap, const char *tag, int id, const _ns1__addListScheduleOperation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__addListScheduleOperation), type))
		return soap->error;
	if (a->_ns1__addListScheduleOperation::current_USCORElogin_USCOREinfo)
	{	if (soap_out_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", -1, &a->_ns1__addListScheduleOperation::current_USCORElogin_USCOREinfo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "current_login_info"))
		return soap->error;
	if (a->_ns1__addListScheduleOperation::listschedule_USCOREname)
	{	if (soap_out_string(soap, "listschedule_name", -1, &a->_ns1__addListScheduleOperation::listschedule_USCOREname, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "listschedule_name"))
		return soap->error;
	if (soap_out_int(soap, "listschedule_program_id", -1, &(a->_ns1__addListScheduleOperation::listschedule_USCOREprogram_USCOREid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__addListScheduleOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__addListScheduleOperation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__addListScheduleOperation * SOAP_FMAC4 soap_in__ns1__addListScheduleOperation(struct soap *soap, const char *tag, _ns1__addListScheduleOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__addListScheduleOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__addListScheduleOperation, sizeof(_ns1__addListScheduleOperation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__addListScheduleOperation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__addListScheduleOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_current_USCORElogin_USCOREinfo1 = 1;
	size_t soap_flag_listschedule_USCOREname1 = 1;
	size_t soap_flag_listschedule_USCOREprogram_USCOREid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_current_USCORElogin_USCOREinfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", &(a->_ns1__addListScheduleOperation::current_USCORElogin_USCOREinfo), "ns1:CURR_LOGIN_INFO_Type"))
				{	soap_flag_current_USCORElogin_USCOREinfo1--;
					continue;
				}
			if (soap_flag_listschedule_USCOREname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "listschedule_name", &(a->_ns1__addListScheduleOperation::listschedule_USCOREname), "xsd:string"))
				{	soap_flag_listschedule_USCOREname1--;
					continue;
				}
			if (soap_flag_listschedule_USCOREprogram_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "listschedule_program_id", &(a->_ns1__addListScheduleOperation::listschedule_USCOREprogram_USCOREid), "xsd:int"))
				{	soap_flag_listschedule_USCOREprogram_USCOREid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__addListScheduleOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__addListScheduleOperation, 0, sizeof(_ns1__addListScheduleOperation), 0, soap_copy__ns1__addListScheduleOperation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_current_USCORElogin_USCOREinfo1 > 0 || soap_flag_listschedule_USCOREname1 > 0 || soap_flag_listschedule_USCOREprogram_USCOREid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__addListScheduleOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__addListScheduleOperation);
	if (this->soap_out(soap, tag?tag:"ns1:addListScheduleOperation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__addListScheduleOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__addListScheduleOperation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__addListScheduleOperation * SOAP_FMAC4 soap_get__ns1__addListScheduleOperation(struct soap *soap, _ns1__addListScheduleOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__addListScheduleOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__addListScheduleOperation * SOAP_FMAC2 soap_instantiate__ns1__addListScheduleOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__addListScheduleOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__addListScheduleOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__addListScheduleOperation);
		if (size)
			*size = sizeof(_ns1__addListScheduleOperation);
		((_ns1__addListScheduleOperation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__addListScheduleOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__addListScheduleOperation);
		for (int i = 0; i < n; i++)
			((_ns1__addListScheduleOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__addListScheduleOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__addListScheduleOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__addListScheduleOperation %p -> %p\n", q, p));
	*(_ns1__addListScheduleOperation*)p = *(_ns1__addListScheduleOperation*)q;
}

void _ns1__getListScheduleOperationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, &this->_ns1__getListScheduleOperationResponse::message_USCOREresult);
	this->_ns1__getListScheduleOperationResponse::__sizelistschedule_USCORElist = 0;
	this->_ns1__getListScheduleOperationResponse::listschedule_USCORElist = NULL;
	/* transient soap skipped */
}

void _ns1__getListScheduleOperationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->_ns1__getListScheduleOperationResponse::listschedule_USCORElist)
	{	int i;
		for (i = 0; i < this->_ns1__getListScheduleOperationResponse::__sizelistschedule_USCORElist; i++)
		{
			soap_serialize_PointerTons1__LISTSCHEDULE_USCOREINFO_USCOREType(soap, this->_ns1__getListScheduleOperationResponse::listschedule_USCORElist + i);
		}
	}
	/* transient soap skipped */
}

int _ns1__getListScheduleOperationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getListScheduleOperationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getListScheduleOperationResponse(struct soap *soap, const char *tag, int id, const _ns1__getListScheduleOperationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getListScheduleOperationResponse), type))
		return soap->error;
	if (soap_out_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", -1, &(a->_ns1__getListScheduleOperationResponse::message_USCOREresult), ""))
		return soap->error;
	if (a->_ns1__getListScheduleOperationResponse::listschedule_USCORElist)
	{	int i;
		for (i = 0; i < a->_ns1__getListScheduleOperationResponse::__sizelistschedule_USCORElist; i++)
			if (soap_out_PointerTons1__LISTSCHEDULE_USCOREINFO_USCOREType(soap, "listschedule_list", -1, a->_ns1__getListScheduleOperationResponse::listschedule_USCORElist + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getListScheduleOperationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getListScheduleOperationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getListScheduleOperationResponse * SOAP_FMAC4 soap_in__ns1__getListScheduleOperationResponse(struct soap *soap, const char *tag, _ns1__getListScheduleOperationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getListScheduleOperationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getListScheduleOperationResponse, sizeof(_ns1__getListScheduleOperationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getListScheduleOperationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getListScheduleOperationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message_USCOREresult1 = 1;
	struct soap_blist *soap_blist_listschedule_USCORElist1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message_USCOREresult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", &(a->_ns1__getListScheduleOperationResponse::message_USCOREresult), "ns1:MESSAGE_RESULT_Enum"))
				{	soap_flag_message_USCOREresult1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "listschedule_list", 1, NULL))
			{	if (a->_ns1__getListScheduleOperationResponse::listschedule_USCORElist == NULL)
				{	if (soap_blist_listschedule_USCORElist1 == NULL)
						soap_blist_listschedule_USCORElist1 = soap_new_block(soap);
					a->_ns1__getListScheduleOperationResponse::listschedule_USCORElist = (ns1__LISTSCHEDULE_USCOREINFO_USCOREType **)soap_push_block(soap, soap_blist_listschedule_USCORElist1, sizeof(ns1__LISTSCHEDULE_USCOREINFO_USCOREType *));
					if (a->_ns1__getListScheduleOperationResponse::listschedule_USCORElist == NULL)
						return NULL;
					*a->_ns1__getListScheduleOperationResponse::listschedule_USCORElist = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__LISTSCHEDULE_USCOREINFO_USCOREType(soap, "listschedule_list", a->_ns1__getListScheduleOperationResponse::listschedule_USCORElist, "ns1:LISTSCHEDULE_INFO_Type"))
				{	a->_ns1__getListScheduleOperationResponse::__sizelistschedule_USCORElist++;
					a->_ns1__getListScheduleOperationResponse::listschedule_USCORElist = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_ns1__getListScheduleOperationResponse::listschedule_USCORElist)
			soap_pop_block(soap, soap_blist_listschedule_USCORElist1);
		if (a->_ns1__getListScheduleOperationResponse::__sizelistschedule_USCORElist)
			a->_ns1__getListScheduleOperationResponse::listschedule_USCORElist = (ns1__LISTSCHEDULE_USCOREINFO_USCOREType **)soap_save_block(soap, soap_blist_listschedule_USCORElist1, NULL, 1);
		else
		{	a->_ns1__getListScheduleOperationResponse::listschedule_USCORElist = NULL;
			if (soap_blist_listschedule_USCORElist1)
				soap_end_block(soap, soap_blist_listschedule_USCORElist1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getListScheduleOperationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getListScheduleOperationResponse, 0, sizeof(_ns1__getListScheduleOperationResponse), 0, soap_copy__ns1__getListScheduleOperationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_message_USCOREresult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getListScheduleOperationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getListScheduleOperationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getListScheduleOperationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getListScheduleOperationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getListScheduleOperationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getListScheduleOperationResponse * SOAP_FMAC4 soap_get__ns1__getListScheduleOperationResponse(struct soap *soap, _ns1__getListScheduleOperationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getListScheduleOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getListScheduleOperationResponse * SOAP_FMAC2 soap_instantiate__ns1__getListScheduleOperationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getListScheduleOperationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getListScheduleOperationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getListScheduleOperationResponse);
		if (size)
			*size = sizeof(_ns1__getListScheduleOperationResponse);
		((_ns1__getListScheduleOperationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getListScheduleOperationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getListScheduleOperationResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getListScheduleOperationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getListScheduleOperationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getListScheduleOperationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getListScheduleOperationResponse %p -> %p\n", q, p));
	*(_ns1__getListScheduleOperationResponse*)p = *(_ns1__getListScheduleOperationResponse*)q;
}

void _ns1__getListScheduleOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getListScheduleOperation::current_USCORElogin_USCOREinfo = NULL;
	soap_default_int(soap, &this->_ns1__getListScheduleOperation::listschedule_USCOREid);
	soap_default_int(soap, &this->_ns1__getListScheduleOperation::listschedule_USCOREprogramid);
	/* transient soap skipped */
}

void _ns1__getListScheduleOperation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, &this->_ns1__getListScheduleOperation::current_USCORElogin_USCOREinfo);
	/* transient soap skipped */
}

int _ns1__getListScheduleOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getListScheduleOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getListScheduleOperation(struct soap *soap, const char *tag, int id, const _ns1__getListScheduleOperation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getListScheduleOperation), type))
		return soap->error;
	if (a->_ns1__getListScheduleOperation::current_USCORElogin_USCOREinfo)
	{	if (soap_out_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", -1, &a->_ns1__getListScheduleOperation::current_USCORElogin_USCOREinfo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "current_login_info"))
		return soap->error;
	if (soap_out_int(soap, "listschedule_id", -1, &(a->_ns1__getListScheduleOperation::listschedule_USCOREid), ""))
		return soap->error;
	if (soap_out_int(soap, "listschedule_programid", -1, &(a->_ns1__getListScheduleOperation::listschedule_USCOREprogramid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getListScheduleOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getListScheduleOperation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getListScheduleOperation * SOAP_FMAC4 soap_in__ns1__getListScheduleOperation(struct soap *soap, const char *tag, _ns1__getListScheduleOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getListScheduleOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getListScheduleOperation, sizeof(_ns1__getListScheduleOperation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getListScheduleOperation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getListScheduleOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_current_USCORElogin_USCOREinfo1 = 1;
	size_t soap_flag_listschedule_USCOREid1 = 1;
	size_t soap_flag_listschedule_USCOREprogramid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_current_USCORElogin_USCOREinfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", &(a->_ns1__getListScheduleOperation::current_USCORElogin_USCOREinfo), "ns1:CURR_LOGIN_INFO_Type"))
				{	soap_flag_current_USCORElogin_USCOREinfo1--;
					continue;
				}
			if (soap_flag_listschedule_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "listschedule_id", &(a->_ns1__getListScheduleOperation::listschedule_USCOREid), "xsd:int"))
				{	soap_flag_listschedule_USCOREid1--;
					continue;
				}
			if (soap_flag_listschedule_USCOREprogramid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "listschedule_programid", &(a->_ns1__getListScheduleOperation::listschedule_USCOREprogramid), "xsd:int"))
				{	soap_flag_listschedule_USCOREprogramid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getListScheduleOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getListScheduleOperation, 0, sizeof(_ns1__getListScheduleOperation), 0, soap_copy__ns1__getListScheduleOperation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_current_USCORElogin_USCOREinfo1 > 0 || soap_flag_listschedule_USCOREid1 > 0 || soap_flag_listschedule_USCOREprogramid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getListScheduleOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getListScheduleOperation);
	if (this->soap_out(soap, tag?tag:"ns1:getListScheduleOperation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getListScheduleOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getListScheduleOperation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getListScheduleOperation * SOAP_FMAC4 soap_get__ns1__getListScheduleOperation(struct soap *soap, _ns1__getListScheduleOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getListScheduleOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getListScheduleOperation * SOAP_FMAC2 soap_instantiate__ns1__getListScheduleOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getListScheduleOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getListScheduleOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getListScheduleOperation);
		if (size)
			*size = sizeof(_ns1__getListScheduleOperation);
		((_ns1__getListScheduleOperation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getListScheduleOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getListScheduleOperation);
		for (int i = 0; i < n; i++)
			((_ns1__getListScheduleOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getListScheduleOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getListScheduleOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getListScheduleOperation %p -> %p\n", q, p));
	*(_ns1__getListScheduleOperation*)p = *(_ns1__getListScheduleOperation*)q;
}

void _ns1__addDayScheduleOperationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__addDayScheduleOperationResponse::dayschedule_USCOREid);
	soap_default_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, &this->_ns1__addDayScheduleOperationResponse::message_USCOREresult);
	/* transient soap skipped */
}

void _ns1__addDayScheduleOperationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__addDayScheduleOperationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__addDayScheduleOperationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__addDayScheduleOperationResponse(struct soap *soap, const char *tag, int id, const _ns1__addDayScheduleOperationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__addDayScheduleOperationResponse), type))
		return soap->error;
	if (soap_out_int(soap, "dayschedule_id", -1, &(a->_ns1__addDayScheduleOperationResponse::dayschedule_USCOREid), ""))
		return soap->error;
	if (soap_out_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", -1, &(a->_ns1__addDayScheduleOperationResponse::message_USCOREresult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__addDayScheduleOperationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__addDayScheduleOperationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__addDayScheduleOperationResponse * SOAP_FMAC4 soap_in__ns1__addDayScheduleOperationResponse(struct soap *soap, const char *tag, _ns1__addDayScheduleOperationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__addDayScheduleOperationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__addDayScheduleOperationResponse, sizeof(_ns1__addDayScheduleOperationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__addDayScheduleOperationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__addDayScheduleOperationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_dayschedule_USCOREid1 = 1;
	size_t soap_flag_message_USCOREresult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dayschedule_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "dayschedule_id", &(a->_ns1__addDayScheduleOperationResponse::dayschedule_USCOREid), "xsd:int"))
				{	soap_flag_dayschedule_USCOREid1--;
					continue;
				}
			if (soap_flag_message_USCOREresult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", &(a->_ns1__addDayScheduleOperationResponse::message_USCOREresult), "ns1:MESSAGE_RESULT_Enum"))
				{	soap_flag_message_USCOREresult1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__addDayScheduleOperationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__addDayScheduleOperationResponse, 0, sizeof(_ns1__addDayScheduleOperationResponse), 0, soap_copy__ns1__addDayScheduleOperationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_dayschedule_USCOREid1 > 0 || soap_flag_message_USCOREresult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__addDayScheduleOperationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__addDayScheduleOperationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:addDayScheduleOperationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__addDayScheduleOperationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__addDayScheduleOperationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__addDayScheduleOperationResponse * SOAP_FMAC4 soap_get__ns1__addDayScheduleOperationResponse(struct soap *soap, _ns1__addDayScheduleOperationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__addDayScheduleOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__addDayScheduleOperationResponse * SOAP_FMAC2 soap_instantiate__ns1__addDayScheduleOperationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__addDayScheduleOperationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__addDayScheduleOperationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__addDayScheduleOperationResponse);
		if (size)
			*size = sizeof(_ns1__addDayScheduleOperationResponse);
		((_ns1__addDayScheduleOperationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__addDayScheduleOperationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__addDayScheduleOperationResponse);
		for (int i = 0; i < n; i++)
			((_ns1__addDayScheduleOperationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__addDayScheduleOperationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__addDayScheduleOperationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__addDayScheduleOperationResponse %p -> %p\n", q, p));
	*(_ns1__addDayScheduleOperationResponse*)p = *(_ns1__addDayScheduleOperationResponse*)q;
}

void _ns1__addDayScheduleOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__addDayScheduleOperation::current_USCORElogin_USCOREinfo = NULL;
	this->_ns1__addDayScheduleOperation::dayschedule = NULL;
	/* transient soap skipped */
}

void _ns1__addDayScheduleOperation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, &this->_ns1__addDayScheduleOperation::current_USCORElogin_USCOREinfo);
	soap_serialize_PointerTons1__DAYSCHEDULE_USCOREINFO_USCOREType(soap, &this->_ns1__addDayScheduleOperation::dayschedule);
	/* transient soap skipped */
}

int _ns1__addDayScheduleOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__addDayScheduleOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__addDayScheduleOperation(struct soap *soap, const char *tag, int id, const _ns1__addDayScheduleOperation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__addDayScheduleOperation), type))
		return soap->error;
	if (a->_ns1__addDayScheduleOperation::current_USCORElogin_USCOREinfo)
	{	if (soap_out_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", -1, &a->_ns1__addDayScheduleOperation::current_USCORElogin_USCOREinfo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "current_login_info"))
		return soap->error;
	if (a->_ns1__addDayScheduleOperation::dayschedule)
	{	if (soap_out_PointerTons1__DAYSCHEDULE_USCOREINFO_USCOREType(soap, "dayschedule", -1, &a->_ns1__addDayScheduleOperation::dayschedule, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "dayschedule"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__addDayScheduleOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__addDayScheduleOperation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__addDayScheduleOperation * SOAP_FMAC4 soap_in__ns1__addDayScheduleOperation(struct soap *soap, const char *tag, _ns1__addDayScheduleOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__addDayScheduleOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__addDayScheduleOperation, sizeof(_ns1__addDayScheduleOperation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__addDayScheduleOperation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__addDayScheduleOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_current_USCORElogin_USCOREinfo1 = 1;
	size_t soap_flag_dayschedule1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_current_USCORElogin_USCOREinfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", &(a->_ns1__addDayScheduleOperation::current_USCORElogin_USCOREinfo), "ns1:CURR_LOGIN_INFO_Type"))
				{	soap_flag_current_USCORElogin_USCOREinfo1--;
					continue;
				}
			if (soap_flag_dayschedule1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__DAYSCHEDULE_USCOREINFO_USCOREType(soap, "dayschedule", &(a->_ns1__addDayScheduleOperation::dayschedule), "ns1:DAYSCHEDULE_INFO_Type"))
				{	soap_flag_dayschedule1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__addDayScheduleOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__addDayScheduleOperation, 0, sizeof(_ns1__addDayScheduleOperation), 0, soap_copy__ns1__addDayScheduleOperation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_current_USCORElogin_USCOREinfo1 > 0 || soap_flag_dayschedule1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__addDayScheduleOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__addDayScheduleOperation);
	if (this->soap_out(soap, tag?tag:"ns1:addDayScheduleOperation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__addDayScheduleOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__addDayScheduleOperation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__addDayScheduleOperation * SOAP_FMAC4 soap_get__ns1__addDayScheduleOperation(struct soap *soap, _ns1__addDayScheduleOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__addDayScheduleOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__addDayScheduleOperation * SOAP_FMAC2 soap_instantiate__ns1__addDayScheduleOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__addDayScheduleOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__addDayScheduleOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__addDayScheduleOperation);
		if (size)
			*size = sizeof(_ns1__addDayScheduleOperation);
		((_ns1__addDayScheduleOperation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__addDayScheduleOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__addDayScheduleOperation);
		for (int i = 0; i < n; i++)
			((_ns1__addDayScheduleOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__addDayScheduleOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__addDayScheduleOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__addDayScheduleOperation %p -> %p\n", q, p));
	*(_ns1__addDayScheduleOperation*)p = *(_ns1__addDayScheduleOperation*)q;
}

void _ns1__removeDayScheduleOperationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, &this->_ns1__removeDayScheduleOperationResponse::message_USCOREresult);
	/* transient soap skipped */
}

void _ns1__removeDayScheduleOperationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__removeDayScheduleOperationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__removeDayScheduleOperationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__removeDayScheduleOperationResponse(struct soap *soap, const char *tag, int id, const _ns1__removeDayScheduleOperationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__removeDayScheduleOperationResponse), type))
		return soap->error;
	if (soap_out_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", -1, &(a->_ns1__removeDayScheduleOperationResponse::message_USCOREresult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__removeDayScheduleOperationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__removeDayScheduleOperationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__removeDayScheduleOperationResponse * SOAP_FMAC4 soap_in__ns1__removeDayScheduleOperationResponse(struct soap *soap, const char *tag, _ns1__removeDayScheduleOperationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__removeDayScheduleOperationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__removeDayScheduleOperationResponse, sizeof(_ns1__removeDayScheduleOperationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__removeDayScheduleOperationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__removeDayScheduleOperationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message_USCOREresult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message_USCOREresult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", &(a->_ns1__removeDayScheduleOperationResponse::message_USCOREresult), "ns1:MESSAGE_RESULT_Enum"))
				{	soap_flag_message_USCOREresult1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__removeDayScheduleOperationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__removeDayScheduleOperationResponse, 0, sizeof(_ns1__removeDayScheduleOperationResponse), 0, soap_copy__ns1__removeDayScheduleOperationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_message_USCOREresult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__removeDayScheduleOperationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__removeDayScheduleOperationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:removeDayScheduleOperationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__removeDayScheduleOperationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__removeDayScheduleOperationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__removeDayScheduleOperationResponse * SOAP_FMAC4 soap_get__ns1__removeDayScheduleOperationResponse(struct soap *soap, _ns1__removeDayScheduleOperationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__removeDayScheduleOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__removeDayScheduleOperationResponse * SOAP_FMAC2 soap_instantiate__ns1__removeDayScheduleOperationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__removeDayScheduleOperationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__removeDayScheduleOperationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__removeDayScheduleOperationResponse);
		if (size)
			*size = sizeof(_ns1__removeDayScheduleOperationResponse);
		((_ns1__removeDayScheduleOperationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__removeDayScheduleOperationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__removeDayScheduleOperationResponse);
		for (int i = 0; i < n; i++)
			((_ns1__removeDayScheduleOperationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__removeDayScheduleOperationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__removeDayScheduleOperationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__removeDayScheduleOperationResponse %p -> %p\n", q, p));
	*(_ns1__removeDayScheduleOperationResponse*)p = *(_ns1__removeDayScheduleOperationResponse*)q;
}

void _ns1__removeDayScheduleOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__removeDayScheduleOperation::current_USCORElogin_USCOREinfo = NULL;
	soap_default_int(soap, &this->_ns1__removeDayScheduleOperation::dayschedule_USCOREid);
	/* transient soap skipped */
}

void _ns1__removeDayScheduleOperation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, &this->_ns1__removeDayScheduleOperation::current_USCORElogin_USCOREinfo);
	/* transient soap skipped */
}

int _ns1__removeDayScheduleOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__removeDayScheduleOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__removeDayScheduleOperation(struct soap *soap, const char *tag, int id, const _ns1__removeDayScheduleOperation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__removeDayScheduleOperation), type))
		return soap->error;
	if (a->_ns1__removeDayScheduleOperation::current_USCORElogin_USCOREinfo)
	{	if (soap_out_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", -1, &a->_ns1__removeDayScheduleOperation::current_USCORElogin_USCOREinfo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "current_login_info"))
		return soap->error;
	if (soap_out_int(soap, "dayschedule_id", -1, &(a->_ns1__removeDayScheduleOperation::dayschedule_USCOREid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__removeDayScheduleOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__removeDayScheduleOperation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__removeDayScheduleOperation * SOAP_FMAC4 soap_in__ns1__removeDayScheduleOperation(struct soap *soap, const char *tag, _ns1__removeDayScheduleOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__removeDayScheduleOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__removeDayScheduleOperation, sizeof(_ns1__removeDayScheduleOperation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__removeDayScheduleOperation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__removeDayScheduleOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_current_USCORElogin_USCOREinfo1 = 1;
	size_t soap_flag_dayschedule_USCOREid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_current_USCORElogin_USCOREinfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", &(a->_ns1__removeDayScheduleOperation::current_USCORElogin_USCOREinfo), "ns1:CURR_LOGIN_INFO_Type"))
				{	soap_flag_current_USCORElogin_USCOREinfo1--;
					continue;
				}
			if (soap_flag_dayschedule_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "dayschedule_id", &(a->_ns1__removeDayScheduleOperation::dayschedule_USCOREid), "xsd:int"))
				{	soap_flag_dayschedule_USCOREid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__removeDayScheduleOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__removeDayScheduleOperation, 0, sizeof(_ns1__removeDayScheduleOperation), 0, soap_copy__ns1__removeDayScheduleOperation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_current_USCORElogin_USCOREinfo1 > 0 || soap_flag_dayschedule_USCOREid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__removeDayScheduleOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__removeDayScheduleOperation);
	if (this->soap_out(soap, tag?tag:"ns1:removeDayScheduleOperation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__removeDayScheduleOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__removeDayScheduleOperation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__removeDayScheduleOperation * SOAP_FMAC4 soap_get__ns1__removeDayScheduleOperation(struct soap *soap, _ns1__removeDayScheduleOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__removeDayScheduleOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__removeDayScheduleOperation * SOAP_FMAC2 soap_instantiate__ns1__removeDayScheduleOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__removeDayScheduleOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__removeDayScheduleOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__removeDayScheduleOperation);
		if (size)
			*size = sizeof(_ns1__removeDayScheduleOperation);
		((_ns1__removeDayScheduleOperation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__removeDayScheduleOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__removeDayScheduleOperation);
		for (int i = 0; i < n; i++)
			((_ns1__removeDayScheduleOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__removeDayScheduleOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__removeDayScheduleOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__removeDayScheduleOperation %p -> %p\n", q, p));
	*(_ns1__removeDayScheduleOperation*)p = *(_ns1__removeDayScheduleOperation*)q;
}

void _ns1__editDayScheduleOperationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, &this->_ns1__editDayScheduleOperationResponse::message_USCOREresult);
	/* transient soap skipped */
}

void _ns1__editDayScheduleOperationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__editDayScheduleOperationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__editDayScheduleOperationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__editDayScheduleOperationResponse(struct soap *soap, const char *tag, int id, const _ns1__editDayScheduleOperationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__editDayScheduleOperationResponse), type))
		return soap->error;
	if (soap_out_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", -1, &(a->_ns1__editDayScheduleOperationResponse::message_USCOREresult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__editDayScheduleOperationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__editDayScheduleOperationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__editDayScheduleOperationResponse * SOAP_FMAC4 soap_in__ns1__editDayScheduleOperationResponse(struct soap *soap, const char *tag, _ns1__editDayScheduleOperationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__editDayScheduleOperationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__editDayScheduleOperationResponse, sizeof(_ns1__editDayScheduleOperationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__editDayScheduleOperationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__editDayScheduleOperationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message_USCOREresult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message_USCOREresult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", &(a->_ns1__editDayScheduleOperationResponse::message_USCOREresult), "ns1:MESSAGE_RESULT_Enum"))
				{	soap_flag_message_USCOREresult1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__editDayScheduleOperationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__editDayScheduleOperationResponse, 0, sizeof(_ns1__editDayScheduleOperationResponse), 0, soap_copy__ns1__editDayScheduleOperationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_message_USCOREresult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__editDayScheduleOperationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__editDayScheduleOperationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:editDayScheduleOperationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__editDayScheduleOperationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__editDayScheduleOperationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__editDayScheduleOperationResponse * SOAP_FMAC4 soap_get__ns1__editDayScheduleOperationResponse(struct soap *soap, _ns1__editDayScheduleOperationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__editDayScheduleOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__editDayScheduleOperationResponse * SOAP_FMAC2 soap_instantiate__ns1__editDayScheduleOperationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__editDayScheduleOperationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__editDayScheduleOperationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__editDayScheduleOperationResponse);
		if (size)
			*size = sizeof(_ns1__editDayScheduleOperationResponse);
		((_ns1__editDayScheduleOperationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__editDayScheduleOperationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__editDayScheduleOperationResponse);
		for (int i = 0; i < n; i++)
			((_ns1__editDayScheduleOperationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__editDayScheduleOperationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__editDayScheduleOperationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__editDayScheduleOperationResponse %p -> %p\n", q, p));
	*(_ns1__editDayScheduleOperationResponse*)p = *(_ns1__editDayScheduleOperationResponse*)q;
}

void _ns1__editDayScheduleOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__editDayScheduleOperation::current_USCORElogin_USCOREinfo = NULL;
	this->_ns1__editDayScheduleOperation::dayschedule = NULL;
	/* transient soap skipped */
}

void _ns1__editDayScheduleOperation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, &this->_ns1__editDayScheduleOperation::current_USCORElogin_USCOREinfo);
	soap_serialize_PointerTons1__DAYSCHEDULE_USCOREINFO_USCOREType(soap, &this->_ns1__editDayScheduleOperation::dayschedule);
	/* transient soap skipped */
}

int _ns1__editDayScheduleOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__editDayScheduleOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__editDayScheduleOperation(struct soap *soap, const char *tag, int id, const _ns1__editDayScheduleOperation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__editDayScheduleOperation), type))
		return soap->error;
	if (a->_ns1__editDayScheduleOperation::current_USCORElogin_USCOREinfo)
	{	if (soap_out_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", -1, &a->_ns1__editDayScheduleOperation::current_USCORElogin_USCOREinfo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "current_login_info"))
		return soap->error;
	if (a->_ns1__editDayScheduleOperation::dayschedule)
	{	if (soap_out_PointerTons1__DAYSCHEDULE_USCOREINFO_USCOREType(soap, "dayschedule", -1, &a->_ns1__editDayScheduleOperation::dayschedule, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "dayschedule"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__editDayScheduleOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__editDayScheduleOperation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__editDayScheduleOperation * SOAP_FMAC4 soap_in__ns1__editDayScheduleOperation(struct soap *soap, const char *tag, _ns1__editDayScheduleOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__editDayScheduleOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__editDayScheduleOperation, sizeof(_ns1__editDayScheduleOperation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__editDayScheduleOperation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__editDayScheduleOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_current_USCORElogin_USCOREinfo1 = 1;
	size_t soap_flag_dayschedule1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_current_USCORElogin_USCOREinfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", &(a->_ns1__editDayScheduleOperation::current_USCORElogin_USCOREinfo), "ns1:CURR_LOGIN_INFO_Type"))
				{	soap_flag_current_USCORElogin_USCOREinfo1--;
					continue;
				}
			if (soap_flag_dayschedule1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__DAYSCHEDULE_USCOREINFO_USCOREType(soap, "dayschedule", &(a->_ns1__editDayScheduleOperation::dayschedule), "ns1:DAYSCHEDULE_INFO_Type"))
				{	soap_flag_dayschedule1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__editDayScheduleOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__editDayScheduleOperation, 0, sizeof(_ns1__editDayScheduleOperation), 0, soap_copy__ns1__editDayScheduleOperation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_current_USCORElogin_USCOREinfo1 > 0 || soap_flag_dayschedule1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__editDayScheduleOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__editDayScheduleOperation);
	if (this->soap_out(soap, tag?tag:"ns1:editDayScheduleOperation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__editDayScheduleOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__editDayScheduleOperation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__editDayScheduleOperation * SOAP_FMAC4 soap_get__ns1__editDayScheduleOperation(struct soap *soap, _ns1__editDayScheduleOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__editDayScheduleOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__editDayScheduleOperation * SOAP_FMAC2 soap_instantiate__ns1__editDayScheduleOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__editDayScheduleOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__editDayScheduleOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__editDayScheduleOperation);
		if (size)
			*size = sizeof(_ns1__editDayScheduleOperation);
		((_ns1__editDayScheduleOperation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__editDayScheduleOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__editDayScheduleOperation);
		for (int i = 0; i < n; i++)
			((_ns1__editDayScheduleOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__editDayScheduleOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__editDayScheduleOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__editDayScheduleOperation %p -> %p\n", q, p));
	*(_ns1__editDayScheduleOperation*)p = *(_ns1__editDayScheduleOperation*)q;
}

void _ns1__getDayScheduleOperationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, &this->_ns1__getDayScheduleOperationResponse::message_USCOREresult);
	this->_ns1__getDayScheduleOperationResponse::__sizedayschedule_USCORElist = 0;
	this->_ns1__getDayScheduleOperationResponse::dayschedule_USCORElist = NULL;
	/* transient soap skipped */
}

void _ns1__getDayScheduleOperationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->_ns1__getDayScheduleOperationResponse::dayschedule_USCORElist)
	{	int i;
		for (i = 0; i < this->_ns1__getDayScheduleOperationResponse::__sizedayschedule_USCORElist; i++)
		{
			soap_serialize_PointerTons1__DAYSCHEDULE_USCOREINFO_USCOREType(soap, this->_ns1__getDayScheduleOperationResponse::dayschedule_USCORElist + i);
		}
	}
	/* transient soap skipped */
}

int _ns1__getDayScheduleOperationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getDayScheduleOperationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getDayScheduleOperationResponse(struct soap *soap, const char *tag, int id, const _ns1__getDayScheduleOperationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getDayScheduleOperationResponse), type))
		return soap->error;
	if (soap_out_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", -1, &(a->_ns1__getDayScheduleOperationResponse::message_USCOREresult), ""))
		return soap->error;
	if (a->_ns1__getDayScheduleOperationResponse::dayschedule_USCORElist)
	{	int i;
		for (i = 0; i < a->_ns1__getDayScheduleOperationResponse::__sizedayschedule_USCORElist; i++)
			if (soap_out_PointerTons1__DAYSCHEDULE_USCOREINFO_USCOREType(soap, "dayschedule_list", -1, a->_ns1__getDayScheduleOperationResponse::dayschedule_USCORElist + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getDayScheduleOperationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getDayScheduleOperationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getDayScheduleOperationResponse * SOAP_FMAC4 soap_in__ns1__getDayScheduleOperationResponse(struct soap *soap, const char *tag, _ns1__getDayScheduleOperationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getDayScheduleOperationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getDayScheduleOperationResponse, sizeof(_ns1__getDayScheduleOperationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getDayScheduleOperationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getDayScheduleOperationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message_USCOREresult1 = 1;
	struct soap_blist *soap_blist_dayschedule_USCORElist1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message_USCOREresult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", &(a->_ns1__getDayScheduleOperationResponse::message_USCOREresult), "ns1:MESSAGE_RESULT_Enum"))
				{	soap_flag_message_USCOREresult1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "dayschedule_list", 1, NULL))
			{	if (a->_ns1__getDayScheduleOperationResponse::dayschedule_USCORElist == NULL)
				{	if (soap_blist_dayschedule_USCORElist1 == NULL)
						soap_blist_dayschedule_USCORElist1 = soap_new_block(soap);
					a->_ns1__getDayScheduleOperationResponse::dayschedule_USCORElist = (ns1__DAYSCHEDULE_USCOREINFO_USCOREType **)soap_push_block(soap, soap_blist_dayschedule_USCORElist1, sizeof(ns1__DAYSCHEDULE_USCOREINFO_USCOREType *));
					if (a->_ns1__getDayScheduleOperationResponse::dayschedule_USCORElist == NULL)
						return NULL;
					*a->_ns1__getDayScheduleOperationResponse::dayschedule_USCORElist = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__DAYSCHEDULE_USCOREINFO_USCOREType(soap, "dayschedule_list", a->_ns1__getDayScheduleOperationResponse::dayschedule_USCORElist, "ns1:DAYSCHEDULE_INFO_Type"))
				{	a->_ns1__getDayScheduleOperationResponse::__sizedayschedule_USCORElist++;
					a->_ns1__getDayScheduleOperationResponse::dayschedule_USCORElist = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_ns1__getDayScheduleOperationResponse::dayschedule_USCORElist)
			soap_pop_block(soap, soap_blist_dayschedule_USCORElist1);
		if (a->_ns1__getDayScheduleOperationResponse::__sizedayschedule_USCORElist)
			a->_ns1__getDayScheduleOperationResponse::dayschedule_USCORElist = (ns1__DAYSCHEDULE_USCOREINFO_USCOREType **)soap_save_block(soap, soap_blist_dayschedule_USCORElist1, NULL, 1);
		else
		{	a->_ns1__getDayScheduleOperationResponse::dayschedule_USCORElist = NULL;
			if (soap_blist_dayschedule_USCORElist1)
				soap_end_block(soap, soap_blist_dayschedule_USCORElist1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getDayScheduleOperationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getDayScheduleOperationResponse, 0, sizeof(_ns1__getDayScheduleOperationResponse), 0, soap_copy__ns1__getDayScheduleOperationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_message_USCOREresult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getDayScheduleOperationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getDayScheduleOperationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getDayScheduleOperationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getDayScheduleOperationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getDayScheduleOperationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getDayScheduleOperationResponse * SOAP_FMAC4 soap_get__ns1__getDayScheduleOperationResponse(struct soap *soap, _ns1__getDayScheduleOperationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getDayScheduleOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getDayScheduleOperationResponse * SOAP_FMAC2 soap_instantiate__ns1__getDayScheduleOperationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getDayScheduleOperationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getDayScheduleOperationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getDayScheduleOperationResponse);
		if (size)
			*size = sizeof(_ns1__getDayScheduleOperationResponse);
		((_ns1__getDayScheduleOperationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getDayScheduleOperationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getDayScheduleOperationResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getDayScheduleOperationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getDayScheduleOperationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getDayScheduleOperationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getDayScheduleOperationResponse %p -> %p\n", q, p));
	*(_ns1__getDayScheduleOperationResponse*)p = *(_ns1__getDayScheduleOperationResponse*)q;
}

void _ns1__getDayScheduleOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__getDayScheduleOperation::program_USCOREid);
	soap_default_int(soap, &this->_ns1__getDayScheduleOperation::dayschedule_USCOREid);
	this->_ns1__getDayScheduleOperation::current_USCORElogin_USCOREinfo = NULL;
	/* transient soap skipped */
}

void _ns1__getDayScheduleOperation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, &this->_ns1__getDayScheduleOperation::current_USCORElogin_USCOREinfo);
	/* transient soap skipped */
}

int _ns1__getDayScheduleOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getDayScheduleOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getDayScheduleOperation(struct soap *soap, const char *tag, int id, const _ns1__getDayScheduleOperation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getDayScheduleOperation), type))
		return soap->error;
	if (soap_out_int(soap, "program_id", -1, &(a->_ns1__getDayScheduleOperation::program_USCOREid), ""))
		return soap->error;
	if (soap_out_int(soap, "dayschedule_id", -1, &(a->_ns1__getDayScheduleOperation::dayschedule_USCOREid), ""))
		return soap->error;
	if (a->_ns1__getDayScheduleOperation::current_USCORElogin_USCOREinfo)
	{	if (soap_out_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", -1, &a->_ns1__getDayScheduleOperation::current_USCORElogin_USCOREinfo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "current_login_info"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getDayScheduleOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getDayScheduleOperation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getDayScheduleOperation * SOAP_FMAC4 soap_in__ns1__getDayScheduleOperation(struct soap *soap, const char *tag, _ns1__getDayScheduleOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getDayScheduleOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getDayScheduleOperation, sizeof(_ns1__getDayScheduleOperation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getDayScheduleOperation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getDayScheduleOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_program_USCOREid1 = 1;
	size_t soap_flag_dayschedule_USCOREid1 = 1;
	size_t soap_flag_current_USCORElogin_USCOREinfo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_program_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "program_id", &(a->_ns1__getDayScheduleOperation::program_USCOREid), "xsd:int"))
				{	soap_flag_program_USCOREid1--;
					continue;
				}
			if (soap_flag_dayschedule_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "dayschedule_id", &(a->_ns1__getDayScheduleOperation::dayschedule_USCOREid), "xsd:int"))
				{	soap_flag_dayschedule_USCOREid1--;
					continue;
				}
			if (soap_flag_current_USCORElogin_USCOREinfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", &(a->_ns1__getDayScheduleOperation::current_USCORElogin_USCOREinfo), "ns1:CURR_LOGIN_INFO_Type"))
				{	soap_flag_current_USCORElogin_USCOREinfo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getDayScheduleOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getDayScheduleOperation, 0, sizeof(_ns1__getDayScheduleOperation), 0, soap_copy__ns1__getDayScheduleOperation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_program_USCOREid1 > 0 || soap_flag_dayschedule_USCOREid1 > 0 || soap_flag_current_USCORElogin_USCOREinfo1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getDayScheduleOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getDayScheduleOperation);
	if (this->soap_out(soap, tag?tag:"ns1:getDayScheduleOperation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getDayScheduleOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getDayScheduleOperation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getDayScheduleOperation * SOAP_FMAC4 soap_get__ns1__getDayScheduleOperation(struct soap *soap, _ns1__getDayScheduleOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getDayScheduleOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getDayScheduleOperation * SOAP_FMAC2 soap_instantiate__ns1__getDayScheduleOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getDayScheduleOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getDayScheduleOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getDayScheduleOperation);
		if (size)
			*size = sizeof(_ns1__getDayScheduleOperation);
		((_ns1__getDayScheduleOperation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getDayScheduleOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getDayScheduleOperation);
		for (int i = 0; i < n; i++)
			((_ns1__getDayScheduleOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getDayScheduleOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getDayScheduleOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getDayScheduleOperation %p -> %p\n", q, p));
	*(_ns1__getDayScheduleOperation*)p = *(_ns1__getDayScheduleOperation*)q;
}

void _ns1__editProgramOperationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, &this->_ns1__editProgramOperationResponse::message_USCOREresult);
	/* transient soap skipped */
}

void _ns1__editProgramOperationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__editProgramOperationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__editProgramOperationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__editProgramOperationResponse(struct soap *soap, const char *tag, int id, const _ns1__editProgramOperationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__editProgramOperationResponse), type))
		return soap->error;
	if (soap_out_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", -1, &(a->_ns1__editProgramOperationResponse::message_USCOREresult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__editProgramOperationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__editProgramOperationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__editProgramOperationResponse * SOAP_FMAC4 soap_in__ns1__editProgramOperationResponse(struct soap *soap, const char *tag, _ns1__editProgramOperationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__editProgramOperationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__editProgramOperationResponse, sizeof(_ns1__editProgramOperationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__editProgramOperationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__editProgramOperationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message_USCOREresult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message_USCOREresult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", &(a->_ns1__editProgramOperationResponse::message_USCOREresult), "ns1:MESSAGE_RESULT_Enum"))
				{	soap_flag_message_USCOREresult1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__editProgramOperationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__editProgramOperationResponse, 0, sizeof(_ns1__editProgramOperationResponse), 0, soap_copy__ns1__editProgramOperationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_message_USCOREresult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__editProgramOperationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__editProgramOperationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:editProgramOperationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__editProgramOperationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__editProgramOperationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__editProgramOperationResponse * SOAP_FMAC4 soap_get__ns1__editProgramOperationResponse(struct soap *soap, _ns1__editProgramOperationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__editProgramOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__editProgramOperationResponse * SOAP_FMAC2 soap_instantiate__ns1__editProgramOperationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__editProgramOperationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__editProgramOperationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__editProgramOperationResponse);
		if (size)
			*size = sizeof(_ns1__editProgramOperationResponse);
		((_ns1__editProgramOperationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__editProgramOperationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__editProgramOperationResponse);
		for (int i = 0; i < n; i++)
			((_ns1__editProgramOperationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__editProgramOperationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__editProgramOperationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__editProgramOperationResponse %p -> %p\n", q, p));
	*(_ns1__editProgramOperationResponse*)p = *(_ns1__editProgramOperationResponse*)q;
}

void _ns1__editProgramOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__editProgramOperation::current_USCORElogin_USCOREinfo = NULL;
	this->_ns1__editProgramOperation::program = NULL;
	/* transient soap skipped */
}

void _ns1__editProgramOperation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, &this->_ns1__editProgramOperation::current_USCORElogin_USCOREinfo);
	soap_serialize_PointerTons1__PROGRAM_USCOREINFO_USCOREType(soap, &this->_ns1__editProgramOperation::program);
	/* transient soap skipped */
}

int _ns1__editProgramOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__editProgramOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__editProgramOperation(struct soap *soap, const char *tag, int id, const _ns1__editProgramOperation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__editProgramOperation), type))
		return soap->error;
	if (a->_ns1__editProgramOperation::current_USCORElogin_USCOREinfo)
	{	if (soap_out_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", -1, &a->_ns1__editProgramOperation::current_USCORElogin_USCOREinfo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "current_login_info"))
		return soap->error;
	if (a->_ns1__editProgramOperation::program)
	{	if (soap_out_PointerTons1__PROGRAM_USCOREINFO_USCOREType(soap, "program", -1, &a->_ns1__editProgramOperation::program, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "program"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__editProgramOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__editProgramOperation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__editProgramOperation * SOAP_FMAC4 soap_in__ns1__editProgramOperation(struct soap *soap, const char *tag, _ns1__editProgramOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__editProgramOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__editProgramOperation, sizeof(_ns1__editProgramOperation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__editProgramOperation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__editProgramOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_current_USCORElogin_USCOREinfo1 = 1;
	size_t soap_flag_program1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_current_USCORElogin_USCOREinfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", &(a->_ns1__editProgramOperation::current_USCORElogin_USCOREinfo), "ns1:CURR_LOGIN_INFO_Type"))
				{	soap_flag_current_USCORElogin_USCOREinfo1--;
					continue;
				}
			if (soap_flag_program1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__PROGRAM_USCOREINFO_USCOREType(soap, "program", &(a->_ns1__editProgramOperation::program), "ns1:PROGRAM_INFO_Type"))
				{	soap_flag_program1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__editProgramOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__editProgramOperation, 0, sizeof(_ns1__editProgramOperation), 0, soap_copy__ns1__editProgramOperation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_current_USCORElogin_USCOREinfo1 > 0 || soap_flag_program1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__editProgramOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__editProgramOperation);
	if (this->soap_out(soap, tag?tag:"ns1:editProgramOperation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__editProgramOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__editProgramOperation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__editProgramOperation * SOAP_FMAC4 soap_get__ns1__editProgramOperation(struct soap *soap, _ns1__editProgramOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__editProgramOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__editProgramOperation * SOAP_FMAC2 soap_instantiate__ns1__editProgramOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__editProgramOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__editProgramOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__editProgramOperation);
		if (size)
			*size = sizeof(_ns1__editProgramOperation);
		((_ns1__editProgramOperation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__editProgramOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__editProgramOperation);
		for (int i = 0; i < n; i++)
			((_ns1__editProgramOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__editProgramOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__editProgramOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__editProgramOperation %p -> %p\n", q, p));
	*(_ns1__editProgramOperation*)p = *(_ns1__editProgramOperation*)q;
}

void _ns1__getProgramOperationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, &this->_ns1__getProgramOperationResponse::message_USCOREresult);
	this->_ns1__getProgramOperationResponse::__sizeprogram_USCORElist = 0;
	this->_ns1__getProgramOperationResponse::program_USCORElist = NULL;
	/* transient soap skipped */
}

void _ns1__getProgramOperationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->_ns1__getProgramOperationResponse::program_USCORElist)
	{	int i;
		for (i = 0; i < this->_ns1__getProgramOperationResponse::__sizeprogram_USCORElist; i++)
		{
			soap_serialize_PointerTons1__PROGRAM_USCOREINFO_USCOREType(soap, this->_ns1__getProgramOperationResponse::program_USCORElist + i);
		}
	}
	/* transient soap skipped */
}

int _ns1__getProgramOperationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getProgramOperationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getProgramOperationResponse(struct soap *soap, const char *tag, int id, const _ns1__getProgramOperationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getProgramOperationResponse), type))
		return soap->error;
	if (soap_out_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", -1, &(a->_ns1__getProgramOperationResponse::message_USCOREresult), ""))
		return soap->error;
	if (a->_ns1__getProgramOperationResponse::program_USCORElist)
	{	int i;
		for (i = 0; i < a->_ns1__getProgramOperationResponse::__sizeprogram_USCORElist; i++)
			if (soap_out_PointerTons1__PROGRAM_USCOREINFO_USCOREType(soap, "program_list", -1, a->_ns1__getProgramOperationResponse::program_USCORElist + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getProgramOperationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getProgramOperationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getProgramOperationResponse * SOAP_FMAC4 soap_in__ns1__getProgramOperationResponse(struct soap *soap, const char *tag, _ns1__getProgramOperationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getProgramOperationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getProgramOperationResponse, sizeof(_ns1__getProgramOperationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getProgramOperationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getProgramOperationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message_USCOREresult1 = 1;
	struct soap_blist *soap_blist_program_USCORElist1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message_USCOREresult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", &(a->_ns1__getProgramOperationResponse::message_USCOREresult), "ns1:MESSAGE_RESULT_Enum"))
				{	soap_flag_message_USCOREresult1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "program_list", 1, NULL))
			{	if (a->_ns1__getProgramOperationResponse::program_USCORElist == NULL)
				{	if (soap_blist_program_USCORElist1 == NULL)
						soap_blist_program_USCORElist1 = soap_new_block(soap);
					a->_ns1__getProgramOperationResponse::program_USCORElist = (ns1__PROGRAM_USCOREINFO_USCOREType **)soap_push_block(soap, soap_blist_program_USCORElist1, sizeof(ns1__PROGRAM_USCOREINFO_USCOREType *));
					if (a->_ns1__getProgramOperationResponse::program_USCORElist == NULL)
						return NULL;
					*a->_ns1__getProgramOperationResponse::program_USCORElist = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__PROGRAM_USCOREINFO_USCOREType(soap, "program_list", a->_ns1__getProgramOperationResponse::program_USCORElist, "ns1:PROGRAM_INFO_Type"))
				{	a->_ns1__getProgramOperationResponse::__sizeprogram_USCORElist++;
					a->_ns1__getProgramOperationResponse::program_USCORElist = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_ns1__getProgramOperationResponse::program_USCORElist)
			soap_pop_block(soap, soap_blist_program_USCORElist1);
		if (a->_ns1__getProgramOperationResponse::__sizeprogram_USCORElist)
			a->_ns1__getProgramOperationResponse::program_USCORElist = (ns1__PROGRAM_USCOREINFO_USCOREType **)soap_save_block(soap, soap_blist_program_USCORElist1, NULL, 1);
		else
		{	a->_ns1__getProgramOperationResponse::program_USCORElist = NULL;
			if (soap_blist_program_USCORElist1)
				soap_end_block(soap, soap_blist_program_USCORElist1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getProgramOperationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getProgramOperationResponse, 0, sizeof(_ns1__getProgramOperationResponse), 0, soap_copy__ns1__getProgramOperationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_message_USCOREresult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getProgramOperationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getProgramOperationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getProgramOperationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getProgramOperationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getProgramOperationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getProgramOperationResponse * SOAP_FMAC4 soap_get__ns1__getProgramOperationResponse(struct soap *soap, _ns1__getProgramOperationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getProgramOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getProgramOperationResponse * SOAP_FMAC2 soap_instantiate__ns1__getProgramOperationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getProgramOperationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getProgramOperationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getProgramOperationResponse);
		if (size)
			*size = sizeof(_ns1__getProgramOperationResponse);
		((_ns1__getProgramOperationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getProgramOperationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getProgramOperationResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getProgramOperationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getProgramOperationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getProgramOperationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getProgramOperationResponse %p -> %p\n", q, p));
	*(_ns1__getProgramOperationResponse*)p = *(_ns1__getProgramOperationResponse*)q;
}

void _ns1__getProgramOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getProgramOperation::current_USCORElogin_USCOREinfo = NULL;
	soap_default_int(soap, &this->_ns1__getProgramOperation::program_USCOREid);
	soap_default_int(soap, &this->_ns1__getProgramOperation::zone_USCOREid);
	/* transient soap skipped */
}

void _ns1__getProgramOperation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, &this->_ns1__getProgramOperation::current_USCORElogin_USCOREinfo);
	/* transient soap skipped */
}

int _ns1__getProgramOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getProgramOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getProgramOperation(struct soap *soap, const char *tag, int id, const _ns1__getProgramOperation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getProgramOperation), type))
		return soap->error;
	if (a->_ns1__getProgramOperation::current_USCORElogin_USCOREinfo)
	{	if (soap_out_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", -1, &a->_ns1__getProgramOperation::current_USCORElogin_USCOREinfo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "current_login_info"))
		return soap->error;
	if (soap_out_int(soap, "program_id", -1, &(a->_ns1__getProgramOperation::program_USCOREid), ""))
		return soap->error;
	if (soap_out_int(soap, "zone_id", -1, &(a->_ns1__getProgramOperation::zone_USCOREid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getProgramOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getProgramOperation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getProgramOperation * SOAP_FMAC4 soap_in__ns1__getProgramOperation(struct soap *soap, const char *tag, _ns1__getProgramOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getProgramOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getProgramOperation, sizeof(_ns1__getProgramOperation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getProgramOperation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getProgramOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_current_USCORElogin_USCOREinfo1 = 1;
	size_t soap_flag_program_USCOREid1 = 1;
	size_t soap_flag_zone_USCOREid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_current_USCORElogin_USCOREinfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", &(a->_ns1__getProgramOperation::current_USCORElogin_USCOREinfo), "ns1:CURR_LOGIN_INFO_Type"))
				{	soap_flag_current_USCORElogin_USCOREinfo1--;
					continue;
				}
			if (soap_flag_program_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "program_id", &(a->_ns1__getProgramOperation::program_USCOREid), "xsd:int"))
				{	soap_flag_program_USCOREid1--;
					continue;
				}
			if (soap_flag_zone_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "zone_id", &(a->_ns1__getProgramOperation::zone_USCOREid), "xsd:int"))
				{	soap_flag_zone_USCOREid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getProgramOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getProgramOperation, 0, sizeof(_ns1__getProgramOperation), 0, soap_copy__ns1__getProgramOperation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_current_USCORElogin_USCOREinfo1 > 0 || soap_flag_program_USCOREid1 > 0 || soap_flag_zone_USCOREid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getProgramOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getProgramOperation);
	if (this->soap_out(soap, tag?tag:"ns1:getProgramOperation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getProgramOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getProgramOperation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getProgramOperation * SOAP_FMAC4 soap_get__ns1__getProgramOperation(struct soap *soap, _ns1__getProgramOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getProgramOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getProgramOperation * SOAP_FMAC2 soap_instantiate__ns1__getProgramOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getProgramOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getProgramOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getProgramOperation);
		if (size)
			*size = sizeof(_ns1__getProgramOperation);
		((_ns1__getProgramOperation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getProgramOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getProgramOperation);
		for (int i = 0; i < n; i++)
			((_ns1__getProgramOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getProgramOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getProgramOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getProgramOperation %p -> %p\n", q, p));
	*(_ns1__getProgramOperation*)p = *(_ns1__getProgramOperation*)q;
}

void _ns1__editUserByUserOperationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, &this->_ns1__editUserByUserOperationResponse::message_USCOREresult);
	/* transient soap skipped */
}

void _ns1__editUserByUserOperationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__editUserByUserOperationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__editUserByUserOperationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__editUserByUserOperationResponse(struct soap *soap, const char *tag, int id, const _ns1__editUserByUserOperationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__editUserByUserOperationResponse), type))
		return soap->error;
	if (soap_out_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", -1, &(a->_ns1__editUserByUserOperationResponse::message_USCOREresult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__editUserByUserOperationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__editUserByUserOperationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__editUserByUserOperationResponse * SOAP_FMAC4 soap_in__ns1__editUserByUserOperationResponse(struct soap *soap, const char *tag, _ns1__editUserByUserOperationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__editUserByUserOperationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__editUserByUserOperationResponse, sizeof(_ns1__editUserByUserOperationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__editUserByUserOperationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__editUserByUserOperationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message_USCOREresult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message_USCOREresult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", &(a->_ns1__editUserByUserOperationResponse::message_USCOREresult), "ns1:MESSAGE_RESULT_Enum"))
				{	soap_flag_message_USCOREresult1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__editUserByUserOperationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__editUserByUserOperationResponse, 0, sizeof(_ns1__editUserByUserOperationResponse), 0, soap_copy__ns1__editUserByUserOperationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_message_USCOREresult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__editUserByUserOperationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__editUserByUserOperationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:editUserByUserOperationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__editUserByUserOperationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__editUserByUserOperationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__editUserByUserOperationResponse * SOAP_FMAC4 soap_get__ns1__editUserByUserOperationResponse(struct soap *soap, _ns1__editUserByUserOperationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__editUserByUserOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__editUserByUserOperationResponse * SOAP_FMAC2 soap_instantiate__ns1__editUserByUserOperationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__editUserByUserOperationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__editUserByUserOperationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__editUserByUserOperationResponse);
		if (size)
			*size = sizeof(_ns1__editUserByUserOperationResponse);
		((_ns1__editUserByUserOperationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__editUserByUserOperationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__editUserByUserOperationResponse);
		for (int i = 0; i < n; i++)
			((_ns1__editUserByUserOperationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__editUserByUserOperationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__editUserByUserOperationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__editUserByUserOperationResponse %p -> %p\n", q, p));
	*(_ns1__editUserByUserOperationResponse*)p = *(_ns1__editUserByUserOperationResponse*)q;
}

void _ns1__editUserByUserOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__editUserByUserOperation::current_USCORElogin_USCOREinfo = NULL;
	this->_ns1__editUserByUserOperation::user = NULL;
	/* transient soap skipped */
}

void _ns1__editUserByUserOperation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, &this->_ns1__editUserByUserOperation::current_USCORElogin_USCOREinfo);
	soap_serialize_PointerTons1__USER_USCOREINFO_USCOREType(soap, &this->_ns1__editUserByUserOperation::user);
	/* transient soap skipped */
}

int _ns1__editUserByUserOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__editUserByUserOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__editUserByUserOperation(struct soap *soap, const char *tag, int id, const _ns1__editUserByUserOperation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__editUserByUserOperation), type))
		return soap->error;
	if (a->_ns1__editUserByUserOperation::current_USCORElogin_USCOREinfo)
	{	if (soap_out_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", -1, &a->_ns1__editUserByUserOperation::current_USCORElogin_USCOREinfo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "current_login_info"))
		return soap->error;
	if (a->_ns1__editUserByUserOperation::user)
	{	if (soap_out_PointerTons1__USER_USCOREINFO_USCOREType(soap, "user", -1, &a->_ns1__editUserByUserOperation::user, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "user"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__editUserByUserOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__editUserByUserOperation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__editUserByUserOperation * SOAP_FMAC4 soap_in__ns1__editUserByUserOperation(struct soap *soap, const char *tag, _ns1__editUserByUserOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__editUserByUserOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__editUserByUserOperation, sizeof(_ns1__editUserByUserOperation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__editUserByUserOperation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__editUserByUserOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_current_USCORElogin_USCOREinfo1 = 1;
	size_t soap_flag_user1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_current_USCORElogin_USCOREinfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", &(a->_ns1__editUserByUserOperation::current_USCORElogin_USCOREinfo), "ns1:CURR_LOGIN_INFO_Type"))
				{	soap_flag_current_USCORElogin_USCOREinfo1--;
					continue;
				}
			if (soap_flag_user1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__USER_USCOREINFO_USCOREType(soap, "user", &(a->_ns1__editUserByUserOperation::user), "ns1:USER_INFO_Type"))
				{	soap_flag_user1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__editUserByUserOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__editUserByUserOperation, 0, sizeof(_ns1__editUserByUserOperation), 0, soap_copy__ns1__editUserByUserOperation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_current_USCORElogin_USCOREinfo1 > 0 || soap_flag_user1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__editUserByUserOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__editUserByUserOperation);
	if (this->soap_out(soap, tag?tag:"ns1:editUserByUserOperation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__editUserByUserOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__editUserByUserOperation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__editUserByUserOperation * SOAP_FMAC4 soap_get__ns1__editUserByUserOperation(struct soap *soap, _ns1__editUserByUserOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__editUserByUserOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__editUserByUserOperation * SOAP_FMAC2 soap_instantiate__ns1__editUserByUserOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__editUserByUserOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__editUserByUserOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__editUserByUserOperation);
		if (size)
			*size = sizeof(_ns1__editUserByUserOperation);
		((_ns1__editUserByUserOperation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__editUserByUserOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__editUserByUserOperation);
		for (int i = 0; i < n; i++)
			((_ns1__editUserByUserOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__editUserByUserOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__editUserByUserOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__editUserByUserOperation %p -> %p\n", q, p));
	*(_ns1__editUserByUserOperation*)p = *(_ns1__editUserByUserOperation*)q;
}

void _ns1__removeUserOperationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, &this->_ns1__removeUserOperationResponse::message_USCOREresult);
	/* transient soap skipped */
}

void _ns1__removeUserOperationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__removeUserOperationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__removeUserOperationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__removeUserOperationResponse(struct soap *soap, const char *tag, int id, const _ns1__removeUserOperationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__removeUserOperationResponse), type))
		return soap->error;
	if (soap_out_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", -1, &(a->_ns1__removeUserOperationResponse::message_USCOREresult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__removeUserOperationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__removeUserOperationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__removeUserOperationResponse * SOAP_FMAC4 soap_in__ns1__removeUserOperationResponse(struct soap *soap, const char *tag, _ns1__removeUserOperationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__removeUserOperationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__removeUserOperationResponse, sizeof(_ns1__removeUserOperationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__removeUserOperationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__removeUserOperationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message_USCOREresult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message_USCOREresult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", &(a->_ns1__removeUserOperationResponse::message_USCOREresult), "ns1:MESSAGE_RESULT_Enum"))
				{	soap_flag_message_USCOREresult1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__removeUserOperationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__removeUserOperationResponse, 0, sizeof(_ns1__removeUserOperationResponse), 0, soap_copy__ns1__removeUserOperationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_message_USCOREresult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__removeUserOperationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__removeUserOperationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:removeUserOperationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__removeUserOperationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__removeUserOperationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__removeUserOperationResponse * SOAP_FMAC4 soap_get__ns1__removeUserOperationResponse(struct soap *soap, _ns1__removeUserOperationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__removeUserOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__removeUserOperationResponse * SOAP_FMAC2 soap_instantiate__ns1__removeUserOperationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__removeUserOperationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__removeUserOperationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__removeUserOperationResponse);
		if (size)
			*size = sizeof(_ns1__removeUserOperationResponse);
		((_ns1__removeUserOperationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__removeUserOperationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__removeUserOperationResponse);
		for (int i = 0; i < n; i++)
			((_ns1__removeUserOperationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__removeUserOperationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__removeUserOperationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__removeUserOperationResponse %p -> %p\n", q, p));
	*(_ns1__removeUserOperationResponse*)p = *(_ns1__removeUserOperationResponse*)q;
}

void _ns1__removeUserOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__removeUserOperation::current_USCORElogin_USCOREinfo = NULL;
	soap_default_int(soap, &this->_ns1__removeUserOperation::user_USCOREid);
	/* transient soap skipped */
}

void _ns1__removeUserOperation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, &this->_ns1__removeUserOperation::current_USCORElogin_USCOREinfo);
	/* transient soap skipped */
}

int _ns1__removeUserOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__removeUserOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__removeUserOperation(struct soap *soap, const char *tag, int id, const _ns1__removeUserOperation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__removeUserOperation), type))
		return soap->error;
	if (a->_ns1__removeUserOperation::current_USCORElogin_USCOREinfo)
	{	if (soap_out_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", -1, &a->_ns1__removeUserOperation::current_USCORElogin_USCOREinfo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "current_login_info"))
		return soap->error;
	if (soap_out_int(soap, "user_id", -1, &(a->_ns1__removeUserOperation::user_USCOREid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__removeUserOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__removeUserOperation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__removeUserOperation * SOAP_FMAC4 soap_in__ns1__removeUserOperation(struct soap *soap, const char *tag, _ns1__removeUserOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__removeUserOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__removeUserOperation, sizeof(_ns1__removeUserOperation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__removeUserOperation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__removeUserOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_current_USCORElogin_USCOREinfo1 = 1;
	size_t soap_flag_user_USCOREid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_current_USCORElogin_USCOREinfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", &(a->_ns1__removeUserOperation::current_USCORElogin_USCOREinfo), "ns1:CURR_LOGIN_INFO_Type"))
				{	soap_flag_current_USCORElogin_USCOREinfo1--;
					continue;
				}
			if (soap_flag_user_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "user_id", &(a->_ns1__removeUserOperation::user_USCOREid), "xsd:int"))
				{	soap_flag_user_USCOREid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__removeUserOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__removeUserOperation, 0, sizeof(_ns1__removeUserOperation), 0, soap_copy__ns1__removeUserOperation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_current_USCORElogin_USCOREinfo1 > 0 || soap_flag_user_USCOREid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__removeUserOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__removeUserOperation);
	if (this->soap_out(soap, tag?tag:"ns1:removeUserOperation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__removeUserOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__removeUserOperation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__removeUserOperation * SOAP_FMAC4 soap_get__ns1__removeUserOperation(struct soap *soap, _ns1__removeUserOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__removeUserOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__removeUserOperation * SOAP_FMAC2 soap_instantiate__ns1__removeUserOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__removeUserOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__removeUserOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__removeUserOperation);
		if (size)
			*size = sizeof(_ns1__removeUserOperation);
		((_ns1__removeUserOperation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__removeUserOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__removeUserOperation);
		for (int i = 0; i < n; i++)
			((_ns1__removeUserOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__removeUserOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__removeUserOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__removeUserOperation %p -> %p\n", q, p));
	*(_ns1__removeUserOperation*)p = *(_ns1__removeUserOperation*)q;
}

void _ns1__editUserOperationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, &this->_ns1__editUserOperationResponse::message_USCOREresult);
	/* transient soap skipped */
}

void _ns1__editUserOperationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__editUserOperationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__editUserOperationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__editUserOperationResponse(struct soap *soap, const char *tag, int id, const _ns1__editUserOperationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__editUserOperationResponse), type))
		return soap->error;
	if (soap_out_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", -1, &(a->_ns1__editUserOperationResponse::message_USCOREresult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__editUserOperationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__editUserOperationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__editUserOperationResponse * SOAP_FMAC4 soap_in__ns1__editUserOperationResponse(struct soap *soap, const char *tag, _ns1__editUserOperationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__editUserOperationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__editUserOperationResponse, sizeof(_ns1__editUserOperationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__editUserOperationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__editUserOperationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message_USCOREresult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message_USCOREresult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", &(a->_ns1__editUserOperationResponse::message_USCOREresult), "ns1:MESSAGE_RESULT_Enum"))
				{	soap_flag_message_USCOREresult1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__editUserOperationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__editUserOperationResponse, 0, sizeof(_ns1__editUserOperationResponse), 0, soap_copy__ns1__editUserOperationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_message_USCOREresult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__editUserOperationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__editUserOperationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:editUserOperationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__editUserOperationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__editUserOperationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__editUserOperationResponse * SOAP_FMAC4 soap_get__ns1__editUserOperationResponse(struct soap *soap, _ns1__editUserOperationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__editUserOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__editUserOperationResponse * SOAP_FMAC2 soap_instantiate__ns1__editUserOperationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__editUserOperationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__editUserOperationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__editUserOperationResponse);
		if (size)
			*size = sizeof(_ns1__editUserOperationResponse);
		((_ns1__editUserOperationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__editUserOperationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__editUserOperationResponse);
		for (int i = 0; i < n; i++)
			((_ns1__editUserOperationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__editUserOperationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__editUserOperationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__editUserOperationResponse %p -> %p\n", q, p));
	*(_ns1__editUserOperationResponse*)p = *(_ns1__editUserOperationResponse*)q;
}

void _ns1__editUserOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__editUserOperation::current_USCORElogin_USCOREinfo = NULL;
	this->_ns1__editUserOperation::user = NULL;
	soap_default_bool(soap, &this->_ns1__editUserOperation::isAddZone);
	/* transient soap skipped */
}

void _ns1__editUserOperation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, &this->_ns1__editUserOperation::current_USCORElogin_USCOREinfo);
	soap_serialize_PointerTons1__USER_USCOREINFO_USCOREType(soap, &this->_ns1__editUserOperation::user);
	/* transient soap skipped */
}

int _ns1__editUserOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__editUserOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__editUserOperation(struct soap *soap, const char *tag, int id, const _ns1__editUserOperation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__editUserOperation), type))
		return soap->error;
	if (a->_ns1__editUserOperation::current_USCORElogin_USCOREinfo)
	{	if (soap_out_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", -1, &a->_ns1__editUserOperation::current_USCORElogin_USCOREinfo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "current_login_info"))
		return soap->error;
	if (a->_ns1__editUserOperation::user)
	{	if (soap_out_PointerTons1__USER_USCOREINFO_USCOREType(soap, "user", -1, &a->_ns1__editUserOperation::user, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "user"))
		return soap->error;
	if (soap_out_bool(soap, "isAddZone", -1, &(a->_ns1__editUserOperation::isAddZone), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__editUserOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__editUserOperation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__editUserOperation * SOAP_FMAC4 soap_in__ns1__editUserOperation(struct soap *soap, const char *tag, _ns1__editUserOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__editUserOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__editUserOperation, sizeof(_ns1__editUserOperation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__editUserOperation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__editUserOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_current_USCORElogin_USCOREinfo1 = 1;
	size_t soap_flag_user1 = 1;
	size_t soap_flag_isAddZone1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_current_USCORElogin_USCOREinfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", &(a->_ns1__editUserOperation::current_USCORElogin_USCOREinfo), "ns1:CURR_LOGIN_INFO_Type"))
				{	soap_flag_current_USCORElogin_USCOREinfo1--;
					continue;
				}
			if (soap_flag_user1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__USER_USCOREINFO_USCOREType(soap, "user", &(a->_ns1__editUserOperation::user), "ns1:USER_INFO_Type"))
				{	soap_flag_user1--;
					continue;
				}
			if (soap_flag_isAddZone1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "isAddZone", &(a->_ns1__editUserOperation::isAddZone), "xsd:boolean"))
				{	soap_flag_isAddZone1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__editUserOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__editUserOperation, 0, sizeof(_ns1__editUserOperation), 0, soap_copy__ns1__editUserOperation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_current_USCORElogin_USCOREinfo1 > 0 || soap_flag_user1 > 0 || soap_flag_isAddZone1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__editUserOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__editUserOperation);
	if (this->soap_out(soap, tag?tag:"ns1:editUserOperation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__editUserOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__editUserOperation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__editUserOperation * SOAP_FMAC4 soap_get__ns1__editUserOperation(struct soap *soap, _ns1__editUserOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__editUserOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__editUserOperation * SOAP_FMAC2 soap_instantiate__ns1__editUserOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__editUserOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__editUserOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__editUserOperation);
		if (size)
			*size = sizeof(_ns1__editUserOperation);
		((_ns1__editUserOperation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__editUserOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__editUserOperation);
		for (int i = 0; i < n; i++)
			((_ns1__editUserOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__editUserOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__editUserOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__editUserOperation %p -> %p\n", q, p));
	*(_ns1__editUserOperation*)p = *(_ns1__editUserOperation*)q;
}

void _ns1__addUserOperationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, &this->_ns1__addUserOperationResponse::message_USCOREresult);
	soap_default_int(soap, &this->_ns1__addUserOperationResponse::user_USCOREid);
	/* transient soap skipped */
}

void _ns1__addUserOperationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__addUserOperationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__addUserOperationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__addUserOperationResponse(struct soap *soap, const char *tag, int id, const _ns1__addUserOperationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__addUserOperationResponse), type))
		return soap->error;
	if (soap_out_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", -1, &(a->_ns1__addUserOperationResponse::message_USCOREresult), ""))
		return soap->error;
	if (soap_out_int(soap, "user_id", -1, &(a->_ns1__addUserOperationResponse::user_USCOREid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__addUserOperationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__addUserOperationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__addUserOperationResponse * SOAP_FMAC4 soap_in__ns1__addUserOperationResponse(struct soap *soap, const char *tag, _ns1__addUserOperationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__addUserOperationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__addUserOperationResponse, sizeof(_ns1__addUserOperationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__addUserOperationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__addUserOperationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message_USCOREresult1 = 1;
	size_t soap_flag_user_USCOREid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message_USCOREresult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", &(a->_ns1__addUserOperationResponse::message_USCOREresult), "ns1:MESSAGE_RESULT_Enum"))
				{	soap_flag_message_USCOREresult1--;
					continue;
				}
			if (soap_flag_user_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "user_id", &(a->_ns1__addUserOperationResponse::user_USCOREid), "xsd:int"))
				{	soap_flag_user_USCOREid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__addUserOperationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__addUserOperationResponse, 0, sizeof(_ns1__addUserOperationResponse), 0, soap_copy__ns1__addUserOperationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_message_USCOREresult1 > 0 || soap_flag_user_USCOREid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__addUserOperationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__addUserOperationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:addUserOperationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__addUserOperationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__addUserOperationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__addUserOperationResponse * SOAP_FMAC4 soap_get__ns1__addUserOperationResponse(struct soap *soap, _ns1__addUserOperationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__addUserOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__addUserOperationResponse * SOAP_FMAC2 soap_instantiate__ns1__addUserOperationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__addUserOperationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__addUserOperationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__addUserOperationResponse);
		if (size)
			*size = sizeof(_ns1__addUserOperationResponse);
		((_ns1__addUserOperationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__addUserOperationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__addUserOperationResponse);
		for (int i = 0; i < n; i++)
			((_ns1__addUserOperationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__addUserOperationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__addUserOperationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__addUserOperationResponse %p -> %p\n", q, p));
	*(_ns1__addUserOperationResponse*)p = *(_ns1__addUserOperationResponse*)q;
}

void _ns1__addUserOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__addUserOperation::current_USCORElogin_USCOREinfo = NULL;
	this->_ns1__addUserOperation::user = NULL;
	/* transient soap skipped */
}

void _ns1__addUserOperation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, &this->_ns1__addUserOperation::current_USCORElogin_USCOREinfo);
	soap_serialize_PointerTons1__USER_USCOREINFO_USCOREType(soap, &this->_ns1__addUserOperation::user);
	/* transient soap skipped */
}

int _ns1__addUserOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__addUserOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__addUserOperation(struct soap *soap, const char *tag, int id, const _ns1__addUserOperation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__addUserOperation), type))
		return soap->error;
	if (a->_ns1__addUserOperation::current_USCORElogin_USCOREinfo)
	{	if (soap_out_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", -1, &a->_ns1__addUserOperation::current_USCORElogin_USCOREinfo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "current_login_info"))
		return soap->error;
	if (a->_ns1__addUserOperation::user)
	{	if (soap_out_PointerTons1__USER_USCOREINFO_USCOREType(soap, "user", -1, &a->_ns1__addUserOperation::user, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "user"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__addUserOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__addUserOperation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__addUserOperation * SOAP_FMAC4 soap_in__ns1__addUserOperation(struct soap *soap, const char *tag, _ns1__addUserOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__addUserOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__addUserOperation, sizeof(_ns1__addUserOperation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__addUserOperation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__addUserOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_current_USCORElogin_USCOREinfo1 = 1;
	size_t soap_flag_user1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_current_USCORElogin_USCOREinfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", &(a->_ns1__addUserOperation::current_USCORElogin_USCOREinfo), "ns1:CURR_LOGIN_INFO_Type"))
				{	soap_flag_current_USCORElogin_USCOREinfo1--;
					continue;
				}
			if (soap_flag_user1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__USER_USCOREINFO_USCOREType(soap, "user", &(a->_ns1__addUserOperation::user), "ns1:USER_INFO_Type"))
				{	soap_flag_user1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__addUserOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__addUserOperation, 0, sizeof(_ns1__addUserOperation), 0, soap_copy__ns1__addUserOperation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_current_USCORElogin_USCOREinfo1 > 0 || soap_flag_user1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__addUserOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__addUserOperation);
	if (this->soap_out(soap, tag?tag:"ns1:addUserOperation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__addUserOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__addUserOperation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__addUserOperation * SOAP_FMAC4 soap_get__ns1__addUserOperation(struct soap *soap, _ns1__addUserOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__addUserOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__addUserOperation * SOAP_FMAC2 soap_instantiate__ns1__addUserOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__addUserOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__addUserOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__addUserOperation);
		if (size)
			*size = sizeof(_ns1__addUserOperation);
		((_ns1__addUserOperation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__addUserOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__addUserOperation);
		for (int i = 0; i < n; i++)
			((_ns1__addUserOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__addUserOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__addUserOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__addUserOperation %p -> %p\n", q, p));
	*(_ns1__addUserOperation*)p = *(_ns1__addUserOperation*)q;
}

void _ns1__getAllUserOperationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, &this->_ns1__getAllUserOperationResponse::message_USCOREresult);
	this->_ns1__getAllUserOperationResponse::__sizeuser_USCORElist = 0;
	this->_ns1__getAllUserOperationResponse::user_USCORElist = NULL;
	/* transient soap skipped */
}

void _ns1__getAllUserOperationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->_ns1__getAllUserOperationResponse::user_USCORElist)
	{	int i;
		for (i = 0; i < this->_ns1__getAllUserOperationResponse::__sizeuser_USCORElist; i++)
		{
			soap_serialize_PointerTons1__USER_USCOREINFO_USCOREType(soap, this->_ns1__getAllUserOperationResponse::user_USCORElist + i);
		}
	}
	/* transient soap skipped */
}

int _ns1__getAllUserOperationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getAllUserOperationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getAllUserOperationResponse(struct soap *soap, const char *tag, int id, const _ns1__getAllUserOperationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getAllUserOperationResponse), type))
		return soap->error;
	if (soap_out_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", -1, &(a->_ns1__getAllUserOperationResponse::message_USCOREresult), ""))
		return soap->error;
	if (a->_ns1__getAllUserOperationResponse::user_USCORElist)
	{	int i;
		for (i = 0; i < a->_ns1__getAllUserOperationResponse::__sizeuser_USCORElist; i++)
			if (soap_out_PointerTons1__USER_USCOREINFO_USCOREType(soap, "user_list", -1, a->_ns1__getAllUserOperationResponse::user_USCORElist + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getAllUserOperationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getAllUserOperationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getAllUserOperationResponse * SOAP_FMAC4 soap_in__ns1__getAllUserOperationResponse(struct soap *soap, const char *tag, _ns1__getAllUserOperationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getAllUserOperationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getAllUserOperationResponse, sizeof(_ns1__getAllUserOperationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getAllUserOperationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getAllUserOperationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message_USCOREresult1 = 1;
	struct soap_blist *soap_blist_user_USCORElist1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message_USCOREresult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", &(a->_ns1__getAllUserOperationResponse::message_USCOREresult), "ns1:MESSAGE_RESULT_Enum"))
				{	soap_flag_message_USCOREresult1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "user_list", 1, NULL))
			{	if (a->_ns1__getAllUserOperationResponse::user_USCORElist == NULL)
				{	if (soap_blist_user_USCORElist1 == NULL)
						soap_blist_user_USCORElist1 = soap_new_block(soap);
					a->_ns1__getAllUserOperationResponse::user_USCORElist = (ns1__USER_USCOREINFO_USCOREType **)soap_push_block(soap, soap_blist_user_USCORElist1, sizeof(ns1__USER_USCOREINFO_USCOREType *));
					if (a->_ns1__getAllUserOperationResponse::user_USCORElist == NULL)
						return NULL;
					*a->_ns1__getAllUserOperationResponse::user_USCORElist = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__USER_USCOREINFO_USCOREType(soap, "user_list", a->_ns1__getAllUserOperationResponse::user_USCORElist, "ns1:USER_INFO_Type"))
				{	a->_ns1__getAllUserOperationResponse::__sizeuser_USCORElist++;
					a->_ns1__getAllUserOperationResponse::user_USCORElist = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_ns1__getAllUserOperationResponse::user_USCORElist)
			soap_pop_block(soap, soap_blist_user_USCORElist1);
		if (a->_ns1__getAllUserOperationResponse::__sizeuser_USCORElist)
			a->_ns1__getAllUserOperationResponse::user_USCORElist = (ns1__USER_USCOREINFO_USCOREType **)soap_save_block(soap, soap_blist_user_USCORElist1, NULL, 1);
		else
		{	a->_ns1__getAllUserOperationResponse::user_USCORElist = NULL;
			if (soap_blist_user_USCORElist1)
				soap_end_block(soap, soap_blist_user_USCORElist1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getAllUserOperationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getAllUserOperationResponse, 0, sizeof(_ns1__getAllUserOperationResponse), 0, soap_copy__ns1__getAllUserOperationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_message_USCOREresult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getAllUserOperationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getAllUserOperationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getAllUserOperationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getAllUserOperationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getAllUserOperationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getAllUserOperationResponse * SOAP_FMAC4 soap_get__ns1__getAllUserOperationResponse(struct soap *soap, _ns1__getAllUserOperationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getAllUserOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getAllUserOperationResponse * SOAP_FMAC2 soap_instantiate__ns1__getAllUserOperationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getAllUserOperationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getAllUserOperationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getAllUserOperationResponse);
		if (size)
			*size = sizeof(_ns1__getAllUserOperationResponse);
		((_ns1__getAllUserOperationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getAllUserOperationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getAllUserOperationResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getAllUserOperationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getAllUserOperationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getAllUserOperationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getAllUserOperationResponse %p -> %p\n", q, p));
	*(_ns1__getAllUserOperationResponse*)p = *(_ns1__getAllUserOperationResponse*)q;
}

void _ns1__getAllUserOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getAllUserOperation::current_USCORElogin_USCOREinfo = NULL;
	soap_default_int(soap, &this->_ns1__getAllUserOperation::userid);
	/* transient soap skipped */
}

void _ns1__getAllUserOperation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, &this->_ns1__getAllUserOperation::current_USCORElogin_USCOREinfo);
	/* transient soap skipped */
}

int _ns1__getAllUserOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getAllUserOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getAllUserOperation(struct soap *soap, const char *tag, int id, const _ns1__getAllUserOperation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getAllUserOperation), type))
		return soap->error;
	if (a->_ns1__getAllUserOperation::current_USCORElogin_USCOREinfo)
	{	if (soap_out_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", -1, &a->_ns1__getAllUserOperation::current_USCORElogin_USCOREinfo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "current_login_info"))
		return soap->error;
	if (soap_out_int(soap, "userid", -1, &(a->_ns1__getAllUserOperation::userid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getAllUserOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getAllUserOperation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getAllUserOperation * SOAP_FMAC4 soap_in__ns1__getAllUserOperation(struct soap *soap, const char *tag, _ns1__getAllUserOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getAllUserOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getAllUserOperation, sizeof(_ns1__getAllUserOperation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getAllUserOperation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getAllUserOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_current_USCORElogin_USCOREinfo1 = 1;
	size_t soap_flag_userid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_current_USCORElogin_USCOREinfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", &(a->_ns1__getAllUserOperation::current_USCORElogin_USCOREinfo), "ns1:CURR_LOGIN_INFO_Type"))
				{	soap_flag_current_USCORElogin_USCOREinfo1--;
					continue;
				}
			if (soap_flag_userid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "userid", &(a->_ns1__getAllUserOperation::userid), "xsd:int"))
				{	soap_flag_userid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getAllUserOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getAllUserOperation, 0, sizeof(_ns1__getAllUserOperation), 0, soap_copy__ns1__getAllUserOperation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_current_USCORElogin_USCOREinfo1 > 0 || soap_flag_userid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getAllUserOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getAllUserOperation);
	if (this->soap_out(soap, tag?tag:"ns1:getAllUserOperation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getAllUserOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getAllUserOperation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getAllUserOperation * SOAP_FMAC4 soap_get__ns1__getAllUserOperation(struct soap *soap, _ns1__getAllUserOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getAllUserOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getAllUserOperation * SOAP_FMAC2 soap_instantiate__ns1__getAllUserOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getAllUserOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getAllUserOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getAllUserOperation);
		if (size)
			*size = sizeof(_ns1__getAllUserOperation);
		((_ns1__getAllUserOperation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getAllUserOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getAllUserOperation);
		for (int i = 0; i < n; i++)
			((_ns1__getAllUserOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getAllUserOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getAllUserOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getAllUserOperation %p -> %p\n", q, p));
	*(_ns1__getAllUserOperation*)p = *(_ns1__getAllUserOperation*)q;
}

void _ns1__removeZoneOperationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, &this->_ns1__removeZoneOperationResponse::message_USCOREresult);
	/* transient soap skipped */
}

void _ns1__removeZoneOperationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__removeZoneOperationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__removeZoneOperationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__removeZoneOperationResponse(struct soap *soap, const char *tag, int id, const _ns1__removeZoneOperationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__removeZoneOperationResponse), type))
		return soap->error;
	if (soap_out_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", -1, &(a->_ns1__removeZoneOperationResponse::message_USCOREresult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__removeZoneOperationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__removeZoneOperationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__removeZoneOperationResponse * SOAP_FMAC4 soap_in__ns1__removeZoneOperationResponse(struct soap *soap, const char *tag, _ns1__removeZoneOperationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__removeZoneOperationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__removeZoneOperationResponse, sizeof(_ns1__removeZoneOperationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__removeZoneOperationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__removeZoneOperationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message_USCOREresult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message_USCOREresult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", &(a->_ns1__removeZoneOperationResponse::message_USCOREresult), "ns1:MESSAGE_RESULT_Enum"))
				{	soap_flag_message_USCOREresult1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__removeZoneOperationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__removeZoneOperationResponse, 0, sizeof(_ns1__removeZoneOperationResponse), 0, soap_copy__ns1__removeZoneOperationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_message_USCOREresult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__removeZoneOperationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__removeZoneOperationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:removeZoneOperationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__removeZoneOperationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__removeZoneOperationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__removeZoneOperationResponse * SOAP_FMAC4 soap_get__ns1__removeZoneOperationResponse(struct soap *soap, _ns1__removeZoneOperationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__removeZoneOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__removeZoneOperationResponse * SOAP_FMAC2 soap_instantiate__ns1__removeZoneOperationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__removeZoneOperationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__removeZoneOperationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__removeZoneOperationResponse);
		if (size)
			*size = sizeof(_ns1__removeZoneOperationResponse);
		((_ns1__removeZoneOperationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__removeZoneOperationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__removeZoneOperationResponse);
		for (int i = 0; i < n; i++)
			((_ns1__removeZoneOperationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__removeZoneOperationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__removeZoneOperationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__removeZoneOperationResponse %p -> %p\n", q, p));
	*(_ns1__removeZoneOperationResponse*)p = *(_ns1__removeZoneOperationResponse*)q;
}

void _ns1__removeZoneOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__removeZoneOperation::current_USCORElogin_USCOREinfo = NULL;
	soap_default_int(soap, &this->_ns1__removeZoneOperation::zoneid);
	/* transient soap skipped */
}

void _ns1__removeZoneOperation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, &this->_ns1__removeZoneOperation::current_USCORElogin_USCOREinfo);
	/* transient soap skipped */
}

int _ns1__removeZoneOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__removeZoneOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__removeZoneOperation(struct soap *soap, const char *tag, int id, const _ns1__removeZoneOperation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__removeZoneOperation), type))
		return soap->error;
	if (a->_ns1__removeZoneOperation::current_USCORElogin_USCOREinfo)
	{	if (soap_out_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", -1, &a->_ns1__removeZoneOperation::current_USCORElogin_USCOREinfo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "current_login_info"))
		return soap->error;
	if (soap_out_int(soap, "zoneid", -1, &(a->_ns1__removeZoneOperation::zoneid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__removeZoneOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__removeZoneOperation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__removeZoneOperation * SOAP_FMAC4 soap_in__ns1__removeZoneOperation(struct soap *soap, const char *tag, _ns1__removeZoneOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__removeZoneOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__removeZoneOperation, sizeof(_ns1__removeZoneOperation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__removeZoneOperation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__removeZoneOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_current_USCORElogin_USCOREinfo1 = 1;
	size_t soap_flag_zoneid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_current_USCORElogin_USCOREinfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", &(a->_ns1__removeZoneOperation::current_USCORElogin_USCOREinfo), "ns1:CURR_LOGIN_INFO_Type"))
				{	soap_flag_current_USCORElogin_USCOREinfo1--;
					continue;
				}
			if (soap_flag_zoneid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "zoneid", &(a->_ns1__removeZoneOperation::zoneid), "xsd:int"))
				{	soap_flag_zoneid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__removeZoneOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__removeZoneOperation, 0, sizeof(_ns1__removeZoneOperation), 0, soap_copy__ns1__removeZoneOperation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_current_USCORElogin_USCOREinfo1 > 0 || soap_flag_zoneid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__removeZoneOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__removeZoneOperation);
	if (this->soap_out(soap, tag?tag:"ns1:removeZoneOperation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__removeZoneOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__removeZoneOperation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__removeZoneOperation * SOAP_FMAC4 soap_get__ns1__removeZoneOperation(struct soap *soap, _ns1__removeZoneOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__removeZoneOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__removeZoneOperation * SOAP_FMAC2 soap_instantiate__ns1__removeZoneOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__removeZoneOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__removeZoneOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__removeZoneOperation);
		if (size)
			*size = sizeof(_ns1__removeZoneOperation);
		((_ns1__removeZoneOperation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__removeZoneOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__removeZoneOperation);
		for (int i = 0; i < n; i++)
			((_ns1__removeZoneOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__removeZoneOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__removeZoneOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__removeZoneOperation %p -> %p\n", q, p));
	*(_ns1__removeZoneOperation*)p = *(_ns1__removeZoneOperation*)q;
}

void _ns1__editZoneOperationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, &this->_ns1__editZoneOperationResponse::message_USCOREresult);
	/* transient soap skipped */
}

void _ns1__editZoneOperationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__editZoneOperationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__editZoneOperationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__editZoneOperationResponse(struct soap *soap, const char *tag, int id, const _ns1__editZoneOperationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__editZoneOperationResponse), type))
		return soap->error;
	if (soap_out_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", -1, &(a->_ns1__editZoneOperationResponse::message_USCOREresult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__editZoneOperationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__editZoneOperationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__editZoneOperationResponse * SOAP_FMAC4 soap_in__ns1__editZoneOperationResponse(struct soap *soap, const char *tag, _ns1__editZoneOperationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__editZoneOperationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__editZoneOperationResponse, sizeof(_ns1__editZoneOperationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__editZoneOperationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__editZoneOperationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message_USCOREresult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message_USCOREresult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", &(a->_ns1__editZoneOperationResponse::message_USCOREresult), "ns1:MESSAGE_RESULT_Enum"))
				{	soap_flag_message_USCOREresult1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__editZoneOperationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__editZoneOperationResponse, 0, sizeof(_ns1__editZoneOperationResponse), 0, soap_copy__ns1__editZoneOperationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_message_USCOREresult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__editZoneOperationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__editZoneOperationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:editZoneOperationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__editZoneOperationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__editZoneOperationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__editZoneOperationResponse * SOAP_FMAC4 soap_get__ns1__editZoneOperationResponse(struct soap *soap, _ns1__editZoneOperationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__editZoneOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__editZoneOperationResponse * SOAP_FMAC2 soap_instantiate__ns1__editZoneOperationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__editZoneOperationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__editZoneOperationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__editZoneOperationResponse);
		if (size)
			*size = sizeof(_ns1__editZoneOperationResponse);
		((_ns1__editZoneOperationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__editZoneOperationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__editZoneOperationResponse);
		for (int i = 0; i < n; i++)
			((_ns1__editZoneOperationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__editZoneOperationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__editZoneOperationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__editZoneOperationResponse %p -> %p\n", q, p));
	*(_ns1__editZoneOperationResponse*)p = *(_ns1__editZoneOperationResponse*)q;
}

void _ns1__editZoneOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__editZoneOperation::current_USCORElogin_USCOREinfo = NULL;
	this->_ns1__editZoneOperation::zone = NULL;
	/* transient soap skipped */
}

void _ns1__editZoneOperation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, &this->_ns1__editZoneOperation::current_USCORElogin_USCOREinfo);
	soap_serialize_PointerTons1__ZONE_USCOREINFO_USCOREType(soap, &this->_ns1__editZoneOperation::zone);
	/* transient soap skipped */
}

int _ns1__editZoneOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__editZoneOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__editZoneOperation(struct soap *soap, const char *tag, int id, const _ns1__editZoneOperation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__editZoneOperation), type))
		return soap->error;
	if (a->_ns1__editZoneOperation::current_USCORElogin_USCOREinfo)
	{	if (soap_out_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", -1, &a->_ns1__editZoneOperation::current_USCORElogin_USCOREinfo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "current_login_info"))
		return soap->error;
	if (a->_ns1__editZoneOperation::zone)
	{	if (soap_out_PointerTons1__ZONE_USCOREINFO_USCOREType(soap, "zone", -1, &a->_ns1__editZoneOperation::zone, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "zone"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__editZoneOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__editZoneOperation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__editZoneOperation * SOAP_FMAC4 soap_in__ns1__editZoneOperation(struct soap *soap, const char *tag, _ns1__editZoneOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__editZoneOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__editZoneOperation, sizeof(_ns1__editZoneOperation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__editZoneOperation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__editZoneOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_current_USCORElogin_USCOREinfo1 = 1;
	size_t soap_flag_zone1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_current_USCORElogin_USCOREinfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", &(a->_ns1__editZoneOperation::current_USCORElogin_USCOREinfo), "ns1:CURR_LOGIN_INFO_Type"))
				{	soap_flag_current_USCORElogin_USCOREinfo1--;
					continue;
				}
			if (soap_flag_zone1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ZONE_USCOREINFO_USCOREType(soap, "zone", &(a->_ns1__editZoneOperation::zone), "ns1:ZONE_INFO_Type"))
				{	soap_flag_zone1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__editZoneOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__editZoneOperation, 0, sizeof(_ns1__editZoneOperation), 0, soap_copy__ns1__editZoneOperation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_current_USCORElogin_USCOREinfo1 > 0 || soap_flag_zone1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__editZoneOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__editZoneOperation);
	if (this->soap_out(soap, tag?tag:"ns1:editZoneOperation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__editZoneOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__editZoneOperation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__editZoneOperation * SOAP_FMAC4 soap_get__ns1__editZoneOperation(struct soap *soap, _ns1__editZoneOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__editZoneOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__editZoneOperation * SOAP_FMAC2 soap_instantiate__ns1__editZoneOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__editZoneOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__editZoneOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__editZoneOperation);
		if (size)
			*size = sizeof(_ns1__editZoneOperation);
		((_ns1__editZoneOperation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__editZoneOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__editZoneOperation);
		for (int i = 0; i < n; i++)
			((_ns1__editZoneOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__editZoneOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__editZoneOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__editZoneOperation %p -> %p\n", q, p));
	*(_ns1__editZoneOperation*)p = *(_ns1__editZoneOperation*)q;
}

void _ns1__addZoneOperationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, &this->_ns1__addZoneOperationResponse::message_USCOREresult);
	soap_default_int(soap, &this->_ns1__addZoneOperationResponse::zone_USCOREid);
	/* transient soap skipped */
}

void _ns1__addZoneOperationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__addZoneOperationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__addZoneOperationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__addZoneOperationResponse(struct soap *soap, const char *tag, int id, const _ns1__addZoneOperationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__addZoneOperationResponse), type))
		return soap->error;
	if (soap_out_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", -1, &(a->_ns1__addZoneOperationResponse::message_USCOREresult), ""))
		return soap->error;
	if (soap_out_int(soap, "zone_id", -1, &(a->_ns1__addZoneOperationResponse::zone_USCOREid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__addZoneOperationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__addZoneOperationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__addZoneOperationResponse * SOAP_FMAC4 soap_in__ns1__addZoneOperationResponse(struct soap *soap, const char *tag, _ns1__addZoneOperationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__addZoneOperationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__addZoneOperationResponse, sizeof(_ns1__addZoneOperationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__addZoneOperationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__addZoneOperationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message_USCOREresult1 = 1;
	size_t soap_flag_zone_USCOREid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message_USCOREresult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", &(a->_ns1__addZoneOperationResponse::message_USCOREresult), "ns1:MESSAGE_RESULT_Enum"))
				{	soap_flag_message_USCOREresult1--;
					continue;
				}
			if (soap_flag_zone_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "zone_id", &(a->_ns1__addZoneOperationResponse::zone_USCOREid), "xsd:int"))
				{	soap_flag_zone_USCOREid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__addZoneOperationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__addZoneOperationResponse, 0, sizeof(_ns1__addZoneOperationResponse), 0, soap_copy__ns1__addZoneOperationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_message_USCOREresult1 > 0 || soap_flag_zone_USCOREid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__addZoneOperationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__addZoneOperationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:addZoneOperationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__addZoneOperationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__addZoneOperationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__addZoneOperationResponse * SOAP_FMAC4 soap_get__ns1__addZoneOperationResponse(struct soap *soap, _ns1__addZoneOperationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__addZoneOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__addZoneOperationResponse * SOAP_FMAC2 soap_instantiate__ns1__addZoneOperationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__addZoneOperationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__addZoneOperationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__addZoneOperationResponse);
		if (size)
			*size = sizeof(_ns1__addZoneOperationResponse);
		((_ns1__addZoneOperationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__addZoneOperationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__addZoneOperationResponse);
		for (int i = 0; i < n; i++)
			((_ns1__addZoneOperationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__addZoneOperationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__addZoneOperationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__addZoneOperationResponse %p -> %p\n", q, p));
	*(_ns1__addZoneOperationResponse*)p = *(_ns1__addZoneOperationResponse*)q;
}

void _ns1__addZoneOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__addZoneOperation::current_USCORElogin_USCOREinfo = NULL;
	this->_ns1__addZoneOperation::zone = NULL;
	/* transient soap skipped */
}

void _ns1__addZoneOperation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, &this->_ns1__addZoneOperation::current_USCORElogin_USCOREinfo);
	soap_serialize_PointerTons1__ZONE_USCOREINFO_USCOREType(soap, &this->_ns1__addZoneOperation::zone);
	/* transient soap skipped */
}

int _ns1__addZoneOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__addZoneOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__addZoneOperation(struct soap *soap, const char *tag, int id, const _ns1__addZoneOperation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__addZoneOperation), type))
		return soap->error;
	if (a->_ns1__addZoneOperation::current_USCORElogin_USCOREinfo)
	{	if (soap_out_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", -1, &a->_ns1__addZoneOperation::current_USCORElogin_USCOREinfo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "current_login_info"))
		return soap->error;
	if (a->_ns1__addZoneOperation::zone)
	{	if (soap_out_PointerTons1__ZONE_USCOREINFO_USCOREType(soap, "zone", -1, &a->_ns1__addZoneOperation::zone, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "zone"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__addZoneOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__addZoneOperation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__addZoneOperation * SOAP_FMAC4 soap_in__ns1__addZoneOperation(struct soap *soap, const char *tag, _ns1__addZoneOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__addZoneOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__addZoneOperation, sizeof(_ns1__addZoneOperation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__addZoneOperation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__addZoneOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_current_USCORElogin_USCOREinfo1 = 1;
	size_t soap_flag_zone1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_current_USCORElogin_USCOREinfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", &(a->_ns1__addZoneOperation::current_USCORElogin_USCOREinfo), "ns1:CURR_LOGIN_INFO_Type"))
				{	soap_flag_current_USCORElogin_USCOREinfo1--;
					continue;
				}
			if (soap_flag_zone1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ZONE_USCOREINFO_USCOREType(soap, "zone", &(a->_ns1__addZoneOperation::zone), "ns1:ZONE_INFO_Type"))
				{	soap_flag_zone1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__addZoneOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__addZoneOperation, 0, sizeof(_ns1__addZoneOperation), 0, soap_copy__ns1__addZoneOperation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_current_USCORElogin_USCOREinfo1 > 0 || soap_flag_zone1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__addZoneOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__addZoneOperation);
	if (this->soap_out(soap, tag?tag:"ns1:addZoneOperation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__addZoneOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__addZoneOperation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__addZoneOperation * SOAP_FMAC4 soap_get__ns1__addZoneOperation(struct soap *soap, _ns1__addZoneOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__addZoneOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__addZoneOperation * SOAP_FMAC2 soap_instantiate__ns1__addZoneOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__addZoneOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__addZoneOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__addZoneOperation);
		if (size)
			*size = sizeof(_ns1__addZoneOperation);
		((_ns1__addZoneOperation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__addZoneOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__addZoneOperation);
		for (int i = 0; i < n; i++)
			((_ns1__addZoneOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__addZoneOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__addZoneOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__addZoneOperation %p -> %p\n", q, p));
	*(_ns1__addZoneOperation*)p = *(_ns1__addZoneOperation*)q;
}

void _ns1__SetDcuToZoneOperationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, &this->_ns1__SetDcuToZoneOperationResponse::message_USCOREresult);
	/* transient soap skipped */
}

void _ns1__SetDcuToZoneOperationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__SetDcuToZoneOperationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SetDcuToZoneOperationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SetDcuToZoneOperationResponse(struct soap *soap, const char *tag, int id, const _ns1__SetDcuToZoneOperationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SetDcuToZoneOperationResponse), type))
		return soap->error;
	if (soap_out_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", -1, &(a->_ns1__SetDcuToZoneOperationResponse::message_USCOREresult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__SetDcuToZoneOperationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SetDcuToZoneOperationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SetDcuToZoneOperationResponse * SOAP_FMAC4 soap_in__ns1__SetDcuToZoneOperationResponse(struct soap *soap, const char *tag, _ns1__SetDcuToZoneOperationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SetDcuToZoneOperationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SetDcuToZoneOperationResponse, sizeof(_ns1__SetDcuToZoneOperationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__SetDcuToZoneOperationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__SetDcuToZoneOperationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message_USCOREresult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message_USCOREresult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", &(a->_ns1__SetDcuToZoneOperationResponse::message_USCOREresult), "ns1:MESSAGE_RESULT_Enum"))
				{	soap_flag_message_USCOREresult1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SetDcuToZoneOperationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SetDcuToZoneOperationResponse, 0, sizeof(_ns1__SetDcuToZoneOperationResponse), 0, soap_copy__ns1__SetDcuToZoneOperationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_message_USCOREresult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__SetDcuToZoneOperationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__SetDcuToZoneOperationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:SetDcuToZoneOperationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SetDcuToZoneOperationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SetDcuToZoneOperationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SetDcuToZoneOperationResponse * SOAP_FMAC4 soap_get__ns1__SetDcuToZoneOperationResponse(struct soap *soap, _ns1__SetDcuToZoneOperationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SetDcuToZoneOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__SetDcuToZoneOperationResponse * SOAP_FMAC2 soap_instantiate__ns1__SetDcuToZoneOperationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SetDcuToZoneOperationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__SetDcuToZoneOperationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__SetDcuToZoneOperationResponse);
		if (size)
			*size = sizeof(_ns1__SetDcuToZoneOperationResponse);
		((_ns1__SetDcuToZoneOperationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__SetDcuToZoneOperationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__SetDcuToZoneOperationResponse);
		for (int i = 0; i < n; i++)
			((_ns1__SetDcuToZoneOperationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__SetDcuToZoneOperationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__SetDcuToZoneOperationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__SetDcuToZoneOperationResponse %p -> %p\n", q, p));
	*(_ns1__SetDcuToZoneOperationResponse*)p = *(_ns1__SetDcuToZoneOperationResponse*)q;
}

void _ns1__SetDcuToZoneOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SetDcuToZoneOperation::current_USCORElogin_USCOREinfo = NULL;
	this->_ns1__SetDcuToZoneOperation::__sizedcu_USCORElist = 0;
	this->_ns1__SetDcuToZoneOperation::dcu_USCORElist = NULL;
	/* transient soap skipped */
}

void _ns1__SetDcuToZoneOperation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, &this->_ns1__SetDcuToZoneOperation::current_USCORElogin_USCOREinfo);
	if (this->_ns1__SetDcuToZoneOperation::dcu_USCORElist)
	{	int i;
		for (i = 0; i < this->_ns1__SetDcuToZoneOperation::__sizedcu_USCORElist; i++)
		{
			soap_serialize_PointerTons1__DCU_USCOREINFO_USCOREType(soap, this->_ns1__SetDcuToZoneOperation::dcu_USCORElist + i);
		}
	}
	/* transient soap skipped */
}

int _ns1__SetDcuToZoneOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SetDcuToZoneOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SetDcuToZoneOperation(struct soap *soap, const char *tag, int id, const _ns1__SetDcuToZoneOperation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SetDcuToZoneOperation), type))
		return soap->error;
	if (a->_ns1__SetDcuToZoneOperation::current_USCORElogin_USCOREinfo)
	{	if (soap_out_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", -1, &a->_ns1__SetDcuToZoneOperation::current_USCORElogin_USCOREinfo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "current_login_info"))
		return soap->error;
	if (a->_ns1__SetDcuToZoneOperation::dcu_USCORElist)
	{	int i;
		for (i = 0; i < a->_ns1__SetDcuToZoneOperation::__sizedcu_USCORElist; i++)
			if (soap_out_PointerTons1__DCU_USCOREINFO_USCOREType(soap, "dcu_list", -1, a->_ns1__SetDcuToZoneOperation::dcu_USCORElist + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__SetDcuToZoneOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SetDcuToZoneOperation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SetDcuToZoneOperation * SOAP_FMAC4 soap_in__ns1__SetDcuToZoneOperation(struct soap *soap, const char *tag, _ns1__SetDcuToZoneOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SetDcuToZoneOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SetDcuToZoneOperation, sizeof(_ns1__SetDcuToZoneOperation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__SetDcuToZoneOperation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__SetDcuToZoneOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_current_USCORElogin_USCOREinfo1 = 1;
	struct soap_blist *soap_blist_dcu_USCORElist1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_current_USCORElogin_USCOREinfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", &(a->_ns1__SetDcuToZoneOperation::current_USCORElogin_USCOREinfo), "ns1:CURR_LOGIN_INFO_Type"))
				{	soap_flag_current_USCORElogin_USCOREinfo1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "dcu_list", 1, NULL))
			{	if (a->_ns1__SetDcuToZoneOperation::dcu_USCORElist == NULL)
				{	if (soap_blist_dcu_USCORElist1 == NULL)
						soap_blist_dcu_USCORElist1 = soap_new_block(soap);
					a->_ns1__SetDcuToZoneOperation::dcu_USCORElist = (ns1__DCU_USCOREINFO_USCOREType **)soap_push_block(soap, soap_blist_dcu_USCORElist1, sizeof(ns1__DCU_USCOREINFO_USCOREType *));
					if (a->_ns1__SetDcuToZoneOperation::dcu_USCORElist == NULL)
						return NULL;
					*a->_ns1__SetDcuToZoneOperation::dcu_USCORElist = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__DCU_USCOREINFO_USCOREType(soap, "dcu_list", a->_ns1__SetDcuToZoneOperation::dcu_USCORElist, "ns1:DCU_INFO_Type"))
				{	a->_ns1__SetDcuToZoneOperation::__sizedcu_USCORElist++;
					a->_ns1__SetDcuToZoneOperation::dcu_USCORElist = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_ns1__SetDcuToZoneOperation::dcu_USCORElist)
			soap_pop_block(soap, soap_blist_dcu_USCORElist1);
		if (a->_ns1__SetDcuToZoneOperation::__sizedcu_USCORElist)
			a->_ns1__SetDcuToZoneOperation::dcu_USCORElist = (ns1__DCU_USCOREINFO_USCOREType **)soap_save_block(soap, soap_blist_dcu_USCORElist1, NULL, 1);
		else
		{	a->_ns1__SetDcuToZoneOperation::dcu_USCORElist = NULL;
			if (soap_blist_dcu_USCORElist1)
				soap_end_block(soap, soap_blist_dcu_USCORElist1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SetDcuToZoneOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SetDcuToZoneOperation, 0, sizeof(_ns1__SetDcuToZoneOperation), 0, soap_copy__ns1__SetDcuToZoneOperation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_current_USCORElogin_USCOREinfo1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__SetDcuToZoneOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__SetDcuToZoneOperation);
	if (this->soap_out(soap, tag?tag:"ns1:SetDcuToZoneOperation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SetDcuToZoneOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SetDcuToZoneOperation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SetDcuToZoneOperation * SOAP_FMAC4 soap_get__ns1__SetDcuToZoneOperation(struct soap *soap, _ns1__SetDcuToZoneOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SetDcuToZoneOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__SetDcuToZoneOperation * SOAP_FMAC2 soap_instantiate__ns1__SetDcuToZoneOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SetDcuToZoneOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__SetDcuToZoneOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__SetDcuToZoneOperation);
		if (size)
			*size = sizeof(_ns1__SetDcuToZoneOperation);
		((_ns1__SetDcuToZoneOperation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__SetDcuToZoneOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__SetDcuToZoneOperation);
		for (int i = 0; i < n; i++)
			((_ns1__SetDcuToZoneOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__SetDcuToZoneOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__SetDcuToZoneOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__SetDcuToZoneOperation %p -> %p\n", q, p));
	*(_ns1__SetDcuToZoneOperation*)p = *(_ns1__SetDcuToZoneOperation*)q;
}

void _ns1__getAllZoneForUserOperationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, &this->_ns1__getAllZoneForUserOperationResponse::message_USCOREresult);
	this->_ns1__getAllZoneForUserOperationResponse::__sizezone_USCORElist = 0;
	this->_ns1__getAllZoneForUserOperationResponse::zone_USCORElist = NULL;
	/* transient soap skipped */
}

void _ns1__getAllZoneForUserOperationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->_ns1__getAllZoneForUserOperationResponse::zone_USCORElist)
	{	int i;
		for (i = 0; i < this->_ns1__getAllZoneForUserOperationResponse::__sizezone_USCORElist; i++)
		{
			soap_serialize_PointerTons1__ZONE_USCOREINFO_USCOREType(soap, this->_ns1__getAllZoneForUserOperationResponse::zone_USCORElist + i);
		}
	}
	/* transient soap skipped */
}

int _ns1__getAllZoneForUserOperationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getAllZoneForUserOperationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getAllZoneForUserOperationResponse(struct soap *soap, const char *tag, int id, const _ns1__getAllZoneForUserOperationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getAllZoneForUserOperationResponse), type))
		return soap->error;
	if (soap_out_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", -1, &(a->_ns1__getAllZoneForUserOperationResponse::message_USCOREresult), ""))
		return soap->error;
	if (a->_ns1__getAllZoneForUserOperationResponse::zone_USCORElist)
	{	int i;
		for (i = 0; i < a->_ns1__getAllZoneForUserOperationResponse::__sizezone_USCORElist; i++)
			if (soap_out_PointerTons1__ZONE_USCOREINFO_USCOREType(soap, "zone_list", -1, a->_ns1__getAllZoneForUserOperationResponse::zone_USCORElist + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getAllZoneForUserOperationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getAllZoneForUserOperationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getAllZoneForUserOperationResponse * SOAP_FMAC4 soap_in__ns1__getAllZoneForUserOperationResponse(struct soap *soap, const char *tag, _ns1__getAllZoneForUserOperationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getAllZoneForUserOperationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getAllZoneForUserOperationResponse, sizeof(_ns1__getAllZoneForUserOperationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getAllZoneForUserOperationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getAllZoneForUserOperationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message_USCOREresult1 = 1;
	struct soap_blist *soap_blist_zone_USCORElist1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message_USCOREresult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", &(a->_ns1__getAllZoneForUserOperationResponse::message_USCOREresult), "ns1:MESSAGE_RESULT_Enum"))
				{	soap_flag_message_USCOREresult1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "zone_list", 1, NULL))
			{	if (a->_ns1__getAllZoneForUserOperationResponse::zone_USCORElist == NULL)
				{	if (soap_blist_zone_USCORElist1 == NULL)
						soap_blist_zone_USCORElist1 = soap_new_block(soap);
					a->_ns1__getAllZoneForUserOperationResponse::zone_USCORElist = (ns1__ZONE_USCOREINFO_USCOREType **)soap_push_block(soap, soap_blist_zone_USCORElist1, sizeof(ns1__ZONE_USCOREINFO_USCOREType *));
					if (a->_ns1__getAllZoneForUserOperationResponse::zone_USCORElist == NULL)
						return NULL;
					*a->_ns1__getAllZoneForUserOperationResponse::zone_USCORElist = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__ZONE_USCOREINFO_USCOREType(soap, "zone_list", a->_ns1__getAllZoneForUserOperationResponse::zone_USCORElist, "ns1:ZONE_INFO_Type"))
				{	a->_ns1__getAllZoneForUserOperationResponse::__sizezone_USCORElist++;
					a->_ns1__getAllZoneForUserOperationResponse::zone_USCORElist = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_ns1__getAllZoneForUserOperationResponse::zone_USCORElist)
			soap_pop_block(soap, soap_blist_zone_USCORElist1);
		if (a->_ns1__getAllZoneForUserOperationResponse::__sizezone_USCORElist)
			a->_ns1__getAllZoneForUserOperationResponse::zone_USCORElist = (ns1__ZONE_USCOREINFO_USCOREType **)soap_save_block(soap, soap_blist_zone_USCORElist1, NULL, 1);
		else
		{	a->_ns1__getAllZoneForUserOperationResponse::zone_USCORElist = NULL;
			if (soap_blist_zone_USCORElist1)
				soap_end_block(soap, soap_blist_zone_USCORElist1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getAllZoneForUserOperationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getAllZoneForUserOperationResponse, 0, sizeof(_ns1__getAllZoneForUserOperationResponse), 0, soap_copy__ns1__getAllZoneForUserOperationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_message_USCOREresult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getAllZoneForUserOperationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getAllZoneForUserOperationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getAllZoneForUserOperationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getAllZoneForUserOperationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getAllZoneForUserOperationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getAllZoneForUserOperationResponse * SOAP_FMAC4 soap_get__ns1__getAllZoneForUserOperationResponse(struct soap *soap, _ns1__getAllZoneForUserOperationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getAllZoneForUserOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getAllZoneForUserOperationResponse * SOAP_FMAC2 soap_instantiate__ns1__getAllZoneForUserOperationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getAllZoneForUserOperationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getAllZoneForUserOperationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getAllZoneForUserOperationResponse);
		if (size)
			*size = sizeof(_ns1__getAllZoneForUserOperationResponse);
		((_ns1__getAllZoneForUserOperationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getAllZoneForUserOperationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getAllZoneForUserOperationResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getAllZoneForUserOperationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getAllZoneForUserOperationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getAllZoneForUserOperationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getAllZoneForUserOperationResponse %p -> %p\n", q, p));
	*(_ns1__getAllZoneForUserOperationResponse*)p = *(_ns1__getAllZoneForUserOperationResponse*)q;
}

void _ns1__getAllZoneForUserOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getAllZoneForUserOperation::current_USCORElogin_USCOREinfo = NULL;
	soap_default_int(soap, &this->_ns1__getAllZoneForUserOperation::user_USCOREid);
	/* transient soap skipped */
}

void _ns1__getAllZoneForUserOperation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, &this->_ns1__getAllZoneForUserOperation::current_USCORElogin_USCOREinfo);
	/* transient soap skipped */
}

int _ns1__getAllZoneForUserOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getAllZoneForUserOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getAllZoneForUserOperation(struct soap *soap, const char *tag, int id, const _ns1__getAllZoneForUserOperation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getAllZoneForUserOperation), type))
		return soap->error;
	if (a->_ns1__getAllZoneForUserOperation::current_USCORElogin_USCOREinfo)
	{	if (soap_out_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", -1, &a->_ns1__getAllZoneForUserOperation::current_USCORElogin_USCOREinfo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "current_login_info"))
		return soap->error;
	if (soap_out_int(soap, "user_id", -1, &(a->_ns1__getAllZoneForUserOperation::user_USCOREid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getAllZoneForUserOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getAllZoneForUserOperation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getAllZoneForUserOperation * SOAP_FMAC4 soap_in__ns1__getAllZoneForUserOperation(struct soap *soap, const char *tag, _ns1__getAllZoneForUserOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getAllZoneForUserOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getAllZoneForUserOperation, sizeof(_ns1__getAllZoneForUserOperation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getAllZoneForUserOperation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getAllZoneForUserOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_current_USCORElogin_USCOREinfo1 = 1;
	size_t soap_flag_user_USCOREid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_current_USCORElogin_USCOREinfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", &(a->_ns1__getAllZoneForUserOperation::current_USCORElogin_USCOREinfo), "ns1:CURR_LOGIN_INFO_Type"))
				{	soap_flag_current_USCORElogin_USCOREinfo1--;
					continue;
				}
			if (soap_flag_user_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "user_id", &(a->_ns1__getAllZoneForUserOperation::user_USCOREid), "xsd:int"))
				{	soap_flag_user_USCOREid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getAllZoneForUserOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getAllZoneForUserOperation, 0, sizeof(_ns1__getAllZoneForUserOperation), 0, soap_copy__ns1__getAllZoneForUserOperation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_current_USCORElogin_USCOREinfo1 > 0 || soap_flag_user_USCOREid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getAllZoneForUserOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getAllZoneForUserOperation);
	if (this->soap_out(soap, tag?tag:"ns1:getAllZoneForUserOperation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getAllZoneForUserOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getAllZoneForUserOperation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getAllZoneForUserOperation * SOAP_FMAC4 soap_get__ns1__getAllZoneForUserOperation(struct soap *soap, _ns1__getAllZoneForUserOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getAllZoneForUserOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getAllZoneForUserOperation * SOAP_FMAC2 soap_instantiate__ns1__getAllZoneForUserOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getAllZoneForUserOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getAllZoneForUserOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getAllZoneForUserOperation);
		if (size)
			*size = sizeof(_ns1__getAllZoneForUserOperation);
		((_ns1__getAllZoneForUserOperation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getAllZoneForUserOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getAllZoneForUserOperation);
		for (int i = 0; i < n; i++)
			((_ns1__getAllZoneForUserOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getAllZoneForUserOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getAllZoneForUserOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getAllZoneForUserOperation %p -> %p\n", q, p));
	*(_ns1__getAllZoneForUserOperation*)p = *(_ns1__getAllZoneForUserOperation*)q;
}

void _ns1__getAllZoneOperationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, &this->_ns1__getAllZoneOperationResponse::message_USCOREresult);
	this->_ns1__getAllZoneOperationResponse::__sizezone_USCORElist = 0;
	this->_ns1__getAllZoneOperationResponse::zone_USCORElist = NULL;
	/* transient soap skipped */
}

void _ns1__getAllZoneOperationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->_ns1__getAllZoneOperationResponse::zone_USCORElist)
	{	int i;
		for (i = 0; i < this->_ns1__getAllZoneOperationResponse::__sizezone_USCORElist; i++)
		{
			soap_serialize_PointerTons1__ZONE_USCOREINFO_USCOREType(soap, this->_ns1__getAllZoneOperationResponse::zone_USCORElist + i);
		}
	}
	/* transient soap skipped */
}

int _ns1__getAllZoneOperationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getAllZoneOperationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getAllZoneOperationResponse(struct soap *soap, const char *tag, int id, const _ns1__getAllZoneOperationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getAllZoneOperationResponse), type))
		return soap->error;
	if (soap_out_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", -1, &(a->_ns1__getAllZoneOperationResponse::message_USCOREresult), ""))
		return soap->error;
	if (a->_ns1__getAllZoneOperationResponse::zone_USCORElist)
	{	int i;
		for (i = 0; i < a->_ns1__getAllZoneOperationResponse::__sizezone_USCORElist; i++)
			if (soap_out_PointerTons1__ZONE_USCOREINFO_USCOREType(soap, "zone_list", -1, a->_ns1__getAllZoneOperationResponse::zone_USCORElist + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getAllZoneOperationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getAllZoneOperationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getAllZoneOperationResponse * SOAP_FMAC4 soap_in__ns1__getAllZoneOperationResponse(struct soap *soap, const char *tag, _ns1__getAllZoneOperationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getAllZoneOperationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getAllZoneOperationResponse, sizeof(_ns1__getAllZoneOperationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getAllZoneOperationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getAllZoneOperationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message_USCOREresult1 = 1;
	struct soap_blist *soap_blist_zone_USCORElist1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message_USCOREresult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", &(a->_ns1__getAllZoneOperationResponse::message_USCOREresult), "ns1:MESSAGE_RESULT_Enum"))
				{	soap_flag_message_USCOREresult1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "zone_list", 1, NULL))
			{	if (a->_ns1__getAllZoneOperationResponse::zone_USCORElist == NULL)
				{	if (soap_blist_zone_USCORElist1 == NULL)
						soap_blist_zone_USCORElist1 = soap_new_block(soap);
					a->_ns1__getAllZoneOperationResponse::zone_USCORElist = (ns1__ZONE_USCOREINFO_USCOREType **)soap_push_block(soap, soap_blist_zone_USCORElist1, sizeof(ns1__ZONE_USCOREINFO_USCOREType *));
					if (a->_ns1__getAllZoneOperationResponse::zone_USCORElist == NULL)
						return NULL;
					*a->_ns1__getAllZoneOperationResponse::zone_USCORElist = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__ZONE_USCOREINFO_USCOREType(soap, "zone_list", a->_ns1__getAllZoneOperationResponse::zone_USCORElist, "ns1:ZONE_INFO_Type"))
				{	a->_ns1__getAllZoneOperationResponse::__sizezone_USCORElist++;
					a->_ns1__getAllZoneOperationResponse::zone_USCORElist = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_ns1__getAllZoneOperationResponse::zone_USCORElist)
			soap_pop_block(soap, soap_blist_zone_USCORElist1);
		if (a->_ns1__getAllZoneOperationResponse::__sizezone_USCORElist)
			a->_ns1__getAllZoneOperationResponse::zone_USCORElist = (ns1__ZONE_USCOREINFO_USCOREType **)soap_save_block(soap, soap_blist_zone_USCORElist1, NULL, 1);
		else
		{	a->_ns1__getAllZoneOperationResponse::zone_USCORElist = NULL;
			if (soap_blist_zone_USCORElist1)
				soap_end_block(soap, soap_blist_zone_USCORElist1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getAllZoneOperationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getAllZoneOperationResponse, 0, sizeof(_ns1__getAllZoneOperationResponse), 0, soap_copy__ns1__getAllZoneOperationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_message_USCOREresult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getAllZoneOperationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getAllZoneOperationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getAllZoneOperationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getAllZoneOperationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getAllZoneOperationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getAllZoneOperationResponse * SOAP_FMAC4 soap_get__ns1__getAllZoneOperationResponse(struct soap *soap, _ns1__getAllZoneOperationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getAllZoneOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getAllZoneOperationResponse * SOAP_FMAC2 soap_instantiate__ns1__getAllZoneOperationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getAllZoneOperationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getAllZoneOperationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getAllZoneOperationResponse);
		if (size)
			*size = sizeof(_ns1__getAllZoneOperationResponse);
		((_ns1__getAllZoneOperationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getAllZoneOperationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getAllZoneOperationResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getAllZoneOperationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getAllZoneOperationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getAllZoneOperationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getAllZoneOperationResponse %p -> %p\n", q, p));
	*(_ns1__getAllZoneOperationResponse*)p = *(_ns1__getAllZoneOperationResponse*)q;
}

void _ns1__getAllZoneOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getAllZoneOperation::current_USCORElogin_USCOREinfo = NULL;
	/* transient soap skipped */
}

void _ns1__getAllZoneOperation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, &this->_ns1__getAllZoneOperation::current_USCORElogin_USCOREinfo);
	/* transient soap skipped */
}

int _ns1__getAllZoneOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getAllZoneOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getAllZoneOperation(struct soap *soap, const char *tag, int id, const _ns1__getAllZoneOperation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getAllZoneOperation), type))
		return soap->error;
	if (a->_ns1__getAllZoneOperation::current_USCORElogin_USCOREinfo)
	{	if (soap_out_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", -1, &a->_ns1__getAllZoneOperation::current_USCORElogin_USCOREinfo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "current_login_info"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getAllZoneOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getAllZoneOperation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getAllZoneOperation * SOAP_FMAC4 soap_in__ns1__getAllZoneOperation(struct soap *soap, const char *tag, _ns1__getAllZoneOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getAllZoneOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getAllZoneOperation, sizeof(_ns1__getAllZoneOperation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getAllZoneOperation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getAllZoneOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_current_USCORElogin_USCOREinfo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_current_USCORElogin_USCOREinfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", &(a->_ns1__getAllZoneOperation::current_USCORElogin_USCOREinfo), "ns1:CURR_LOGIN_INFO_Type"))
				{	soap_flag_current_USCORElogin_USCOREinfo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getAllZoneOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getAllZoneOperation, 0, sizeof(_ns1__getAllZoneOperation), 0, soap_copy__ns1__getAllZoneOperation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_current_USCORElogin_USCOREinfo1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getAllZoneOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getAllZoneOperation);
	if (this->soap_out(soap, tag?tag:"ns1:getAllZoneOperation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getAllZoneOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getAllZoneOperation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getAllZoneOperation * SOAP_FMAC4 soap_get__ns1__getAllZoneOperation(struct soap *soap, _ns1__getAllZoneOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getAllZoneOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getAllZoneOperation * SOAP_FMAC2 soap_instantiate__ns1__getAllZoneOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getAllZoneOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getAllZoneOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getAllZoneOperation);
		if (size)
			*size = sizeof(_ns1__getAllZoneOperation);
		((_ns1__getAllZoneOperation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getAllZoneOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getAllZoneOperation);
		for (int i = 0; i < n; i++)
			((_ns1__getAllZoneOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getAllZoneOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getAllZoneOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getAllZoneOperation %p -> %p\n", q, p));
	*(_ns1__getAllZoneOperation*)p = *(_ns1__getAllZoneOperation*)q;
}

void _ns1__deleteUserLogOperationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, &this->_ns1__deleteUserLogOperationResponse::message_USCOREresult);
	/* transient soap skipped */
}

void _ns1__deleteUserLogOperationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__deleteUserLogOperationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__deleteUserLogOperationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__deleteUserLogOperationResponse(struct soap *soap, const char *tag, int id, const _ns1__deleteUserLogOperationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__deleteUserLogOperationResponse), type))
		return soap->error;
	if (soap_out_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", -1, &(a->_ns1__deleteUserLogOperationResponse::message_USCOREresult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__deleteUserLogOperationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__deleteUserLogOperationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__deleteUserLogOperationResponse * SOAP_FMAC4 soap_in__ns1__deleteUserLogOperationResponse(struct soap *soap, const char *tag, _ns1__deleteUserLogOperationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__deleteUserLogOperationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__deleteUserLogOperationResponse, sizeof(_ns1__deleteUserLogOperationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__deleteUserLogOperationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__deleteUserLogOperationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message_USCOREresult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message_USCOREresult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", &(a->_ns1__deleteUserLogOperationResponse::message_USCOREresult), "ns1:MESSAGE_RESULT_Enum"))
				{	soap_flag_message_USCOREresult1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__deleteUserLogOperationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__deleteUserLogOperationResponse, 0, sizeof(_ns1__deleteUserLogOperationResponse), 0, soap_copy__ns1__deleteUserLogOperationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_message_USCOREresult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__deleteUserLogOperationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__deleteUserLogOperationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:deleteUserLogOperationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__deleteUserLogOperationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__deleteUserLogOperationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__deleteUserLogOperationResponse * SOAP_FMAC4 soap_get__ns1__deleteUserLogOperationResponse(struct soap *soap, _ns1__deleteUserLogOperationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__deleteUserLogOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__deleteUserLogOperationResponse * SOAP_FMAC2 soap_instantiate__ns1__deleteUserLogOperationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__deleteUserLogOperationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__deleteUserLogOperationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__deleteUserLogOperationResponse);
		if (size)
			*size = sizeof(_ns1__deleteUserLogOperationResponse);
		((_ns1__deleteUserLogOperationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__deleteUserLogOperationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__deleteUserLogOperationResponse);
		for (int i = 0; i < n; i++)
			((_ns1__deleteUserLogOperationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__deleteUserLogOperationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__deleteUserLogOperationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__deleteUserLogOperationResponse %p -> %p\n", q, p));
	*(_ns1__deleteUserLogOperationResponse*)p = *(_ns1__deleteUserLogOperationResponse*)q;
}

void _ns1__deleteUserLogOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__deleteUserLogOperation::current_USCORElogin_USCOREinfo = NULL;
	soap_default_int(soap, &this->_ns1__deleteUserLogOperation::userlog_USCOREid);
	/* transient soap skipped */
}

void _ns1__deleteUserLogOperation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, &this->_ns1__deleteUserLogOperation::current_USCORElogin_USCOREinfo);
	/* transient soap skipped */
}

int _ns1__deleteUserLogOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__deleteUserLogOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__deleteUserLogOperation(struct soap *soap, const char *tag, int id, const _ns1__deleteUserLogOperation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__deleteUserLogOperation), type))
		return soap->error;
	if (a->_ns1__deleteUserLogOperation::current_USCORElogin_USCOREinfo)
	{	if (soap_out_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", -1, &a->_ns1__deleteUserLogOperation::current_USCORElogin_USCOREinfo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "current_login_info"))
		return soap->error;
	if (soap_out_int(soap, "userlog_id", -1, &(a->_ns1__deleteUserLogOperation::userlog_USCOREid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__deleteUserLogOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__deleteUserLogOperation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__deleteUserLogOperation * SOAP_FMAC4 soap_in__ns1__deleteUserLogOperation(struct soap *soap, const char *tag, _ns1__deleteUserLogOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__deleteUserLogOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__deleteUserLogOperation, sizeof(_ns1__deleteUserLogOperation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__deleteUserLogOperation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__deleteUserLogOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_current_USCORElogin_USCOREinfo1 = 1;
	size_t soap_flag_userlog_USCOREid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_current_USCORElogin_USCOREinfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", &(a->_ns1__deleteUserLogOperation::current_USCORElogin_USCOREinfo), "ns1:CURR_LOGIN_INFO_Type"))
				{	soap_flag_current_USCORElogin_USCOREinfo1--;
					continue;
				}
			if (soap_flag_userlog_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "userlog_id", &(a->_ns1__deleteUserLogOperation::userlog_USCOREid), "xsd:int"))
				{	soap_flag_userlog_USCOREid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__deleteUserLogOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__deleteUserLogOperation, 0, sizeof(_ns1__deleteUserLogOperation), 0, soap_copy__ns1__deleteUserLogOperation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_current_USCORElogin_USCOREinfo1 > 0 || soap_flag_userlog_USCOREid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__deleteUserLogOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__deleteUserLogOperation);
	if (this->soap_out(soap, tag?tag:"ns1:deleteUserLogOperation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__deleteUserLogOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__deleteUserLogOperation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__deleteUserLogOperation * SOAP_FMAC4 soap_get__ns1__deleteUserLogOperation(struct soap *soap, _ns1__deleteUserLogOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__deleteUserLogOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__deleteUserLogOperation * SOAP_FMAC2 soap_instantiate__ns1__deleteUserLogOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__deleteUserLogOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__deleteUserLogOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__deleteUserLogOperation);
		if (size)
			*size = sizeof(_ns1__deleteUserLogOperation);
		((_ns1__deleteUserLogOperation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__deleteUserLogOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__deleteUserLogOperation);
		for (int i = 0; i < n; i++)
			((_ns1__deleteUserLogOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__deleteUserLogOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__deleteUserLogOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__deleteUserLogOperation %p -> %p\n", q, p));
	*(_ns1__deleteUserLogOperation*)p = *(_ns1__deleteUserLogOperation*)q;
}

void _ns1__getUserLogOperationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, &this->_ns1__getUserLogOperationResponse::message_USCOREresult);
	this->_ns1__getUserLogOperationResponse::__sizeuserlog_USCORElist = 0;
	this->_ns1__getUserLogOperationResponse::userlog_USCORElist = NULL;
	/* transient soap skipped */
}

void _ns1__getUserLogOperationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->_ns1__getUserLogOperationResponse::userlog_USCORElist)
	{	int i;
		for (i = 0; i < this->_ns1__getUserLogOperationResponse::__sizeuserlog_USCORElist; i++)
		{
			soap_serialize_PointerTons1__USER_USCORELOG_USCOREINFO_USCOREType(soap, this->_ns1__getUserLogOperationResponse::userlog_USCORElist + i);
		}
	}
	/* transient soap skipped */
}

int _ns1__getUserLogOperationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getUserLogOperationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getUserLogOperationResponse(struct soap *soap, const char *tag, int id, const _ns1__getUserLogOperationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getUserLogOperationResponse), type))
		return soap->error;
	if (soap_out_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", -1, &(a->_ns1__getUserLogOperationResponse::message_USCOREresult), ""))
		return soap->error;
	if (a->_ns1__getUserLogOperationResponse::userlog_USCORElist)
	{	int i;
		for (i = 0; i < a->_ns1__getUserLogOperationResponse::__sizeuserlog_USCORElist; i++)
			if (soap_out_PointerTons1__USER_USCORELOG_USCOREINFO_USCOREType(soap, "userlog_list", -1, a->_ns1__getUserLogOperationResponse::userlog_USCORElist + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getUserLogOperationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getUserLogOperationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getUserLogOperationResponse * SOAP_FMAC4 soap_in__ns1__getUserLogOperationResponse(struct soap *soap, const char *tag, _ns1__getUserLogOperationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getUserLogOperationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getUserLogOperationResponse, sizeof(_ns1__getUserLogOperationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getUserLogOperationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getUserLogOperationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message_USCOREresult1 = 1;
	struct soap_blist *soap_blist_userlog_USCORElist1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message_USCOREresult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", &(a->_ns1__getUserLogOperationResponse::message_USCOREresult), "ns1:MESSAGE_RESULT_Enum"))
				{	soap_flag_message_USCOREresult1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "userlog_list", 1, NULL))
			{	if (a->_ns1__getUserLogOperationResponse::userlog_USCORElist == NULL)
				{	if (soap_blist_userlog_USCORElist1 == NULL)
						soap_blist_userlog_USCORElist1 = soap_new_block(soap);
					a->_ns1__getUserLogOperationResponse::userlog_USCORElist = (ns1__USER_USCORELOG_USCOREINFO_USCOREType **)soap_push_block(soap, soap_blist_userlog_USCORElist1, sizeof(ns1__USER_USCORELOG_USCOREINFO_USCOREType *));
					if (a->_ns1__getUserLogOperationResponse::userlog_USCORElist == NULL)
						return NULL;
					*a->_ns1__getUserLogOperationResponse::userlog_USCORElist = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__USER_USCORELOG_USCOREINFO_USCOREType(soap, "userlog_list", a->_ns1__getUserLogOperationResponse::userlog_USCORElist, "ns1:USER_LOG_INFO_Type"))
				{	a->_ns1__getUserLogOperationResponse::__sizeuserlog_USCORElist++;
					a->_ns1__getUserLogOperationResponse::userlog_USCORElist = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_ns1__getUserLogOperationResponse::userlog_USCORElist)
			soap_pop_block(soap, soap_blist_userlog_USCORElist1);
		if (a->_ns1__getUserLogOperationResponse::__sizeuserlog_USCORElist)
			a->_ns1__getUserLogOperationResponse::userlog_USCORElist = (ns1__USER_USCORELOG_USCOREINFO_USCOREType **)soap_save_block(soap, soap_blist_userlog_USCORElist1, NULL, 1);
		else
		{	a->_ns1__getUserLogOperationResponse::userlog_USCORElist = NULL;
			if (soap_blist_userlog_USCORElist1)
				soap_end_block(soap, soap_blist_userlog_USCORElist1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getUserLogOperationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getUserLogOperationResponse, 0, sizeof(_ns1__getUserLogOperationResponse), 0, soap_copy__ns1__getUserLogOperationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_message_USCOREresult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getUserLogOperationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getUserLogOperationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getUserLogOperationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getUserLogOperationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getUserLogOperationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getUserLogOperationResponse * SOAP_FMAC4 soap_get__ns1__getUserLogOperationResponse(struct soap *soap, _ns1__getUserLogOperationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getUserLogOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getUserLogOperationResponse * SOAP_FMAC2 soap_instantiate__ns1__getUserLogOperationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getUserLogOperationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getUserLogOperationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getUserLogOperationResponse);
		if (size)
			*size = sizeof(_ns1__getUserLogOperationResponse);
		((_ns1__getUserLogOperationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getUserLogOperationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getUserLogOperationResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getUserLogOperationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getUserLogOperationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getUserLogOperationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getUserLogOperationResponse %p -> %p\n", q, p));
	*(_ns1__getUserLogOperationResponse*)p = *(_ns1__getUserLogOperationResponse*)q;
}

void _ns1__getUserLogOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getUserLogOperation::current_USCORElogin_USCOREinfo = NULL;
	soap_default_int(soap, &this->_ns1__getUserLogOperation::user_USCOREid);
	/* transient soap skipped */
}

void _ns1__getUserLogOperation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, &this->_ns1__getUserLogOperation::current_USCORElogin_USCOREinfo);
	/* transient soap skipped */
}

int _ns1__getUserLogOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getUserLogOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getUserLogOperation(struct soap *soap, const char *tag, int id, const _ns1__getUserLogOperation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getUserLogOperation), type))
		return soap->error;
	if (a->_ns1__getUserLogOperation::current_USCORElogin_USCOREinfo)
	{	if (soap_out_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", -1, &a->_ns1__getUserLogOperation::current_USCORElogin_USCOREinfo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "current_login_info"))
		return soap->error;
	if (soap_out_int(soap, "user_id", -1, &(a->_ns1__getUserLogOperation::user_USCOREid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getUserLogOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getUserLogOperation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getUserLogOperation * SOAP_FMAC4 soap_in__ns1__getUserLogOperation(struct soap *soap, const char *tag, _ns1__getUserLogOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getUserLogOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getUserLogOperation, sizeof(_ns1__getUserLogOperation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getUserLogOperation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getUserLogOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_current_USCORElogin_USCOREinfo1 = 1;
	size_t soap_flag_user_USCOREid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_current_USCORElogin_USCOREinfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", &(a->_ns1__getUserLogOperation::current_USCORElogin_USCOREinfo), "ns1:CURR_LOGIN_INFO_Type"))
				{	soap_flag_current_USCORElogin_USCOREinfo1--;
					continue;
				}
			if (soap_flag_user_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "user_id", &(a->_ns1__getUserLogOperation::user_USCOREid), "xsd:int"))
				{	soap_flag_user_USCOREid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getUserLogOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getUserLogOperation, 0, sizeof(_ns1__getUserLogOperation), 0, soap_copy__ns1__getUserLogOperation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_current_USCORElogin_USCOREinfo1 > 0 || soap_flag_user_USCOREid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getUserLogOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getUserLogOperation);
	if (this->soap_out(soap, tag?tag:"ns1:getUserLogOperation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getUserLogOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getUserLogOperation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getUserLogOperation * SOAP_FMAC4 soap_get__ns1__getUserLogOperation(struct soap *soap, _ns1__getUserLogOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getUserLogOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getUserLogOperation * SOAP_FMAC2 soap_instantiate__ns1__getUserLogOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getUserLogOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getUserLogOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getUserLogOperation);
		if (size)
			*size = sizeof(_ns1__getUserLogOperation);
		((_ns1__getUserLogOperation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getUserLogOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getUserLogOperation);
		for (int i = 0; i < n; i++)
			((_ns1__getUserLogOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getUserLogOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getUserLogOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getUserLogOperation %p -> %p\n", q, p));
	*(_ns1__getUserLogOperation*)p = *(_ns1__getUserLogOperation*)q;
}

void _ns1__deleteEventLogOperationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, &this->_ns1__deleteEventLogOperationResponse::message_USCOREresult);
	/* transient soap skipped */
}

void _ns1__deleteEventLogOperationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__deleteEventLogOperationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__deleteEventLogOperationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__deleteEventLogOperationResponse(struct soap *soap, const char *tag, int id, const _ns1__deleteEventLogOperationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__deleteEventLogOperationResponse), type))
		return soap->error;
	if (soap_out_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", -1, &(a->_ns1__deleteEventLogOperationResponse::message_USCOREresult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__deleteEventLogOperationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__deleteEventLogOperationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__deleteEventLogOperationResponse * SOAP_FMAC4 soap_in__ns1__deleteEventLogOperationResponse(struct soap *soap, const char *tag, _ns1__deleteEventLogOperationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__deleteEventLogOperationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__deleteEventLogOperationResponse, sizeof(_ns1__deleteEventLogOperationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__deleteEventLogOperationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__deleteEventLogOperationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message_USCOREresult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message_USCOREresult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", &(a->_ns1__deleteEventLogOperationResponse::message_USCOREresult), "ns1:MESSAGE_RESULT_Enum"))
				{	soap_flag_message_USCOREresult1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__deleteEventLogOperationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__deleteEventLogOperationResponse, 0, sizeof(_ns1__deleteEventLogOperationResponse), 0, soap_copy__ns1__deleteEventLogOperationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_message_USCOREresult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__deleteEventLogOperationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__deleteEventLogOperationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:deleteEventLogOperationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__deleteEventLogOperationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__deleteEventLogOperationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__deleteEventLogOperationResponse * SOAP_FMAC4 soap_get__ns1__deleteEventLogOperationResponse(struct soap *soap, _ns1__deleteEventLogOperationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__deleteEventLogOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__deleteEventLogOperationResponse * SOAP_FMAC2 soap_instantiate__ns1__deleteEventLogOperationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__deleteEventLogOperationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__deleteEventLogOperationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__deleteEventLogOperationResponse);
		if (size)
			*size = sizeof(_ns1__deleteEventLogOperationResponse);
		((_ns1__deleteEventLogOperationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__deleteEventLogOperationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__deleteEventLogOperationResponse);
		for (int i = 0; i < n; i++)
			((_ns1__deleteEventLogOperationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__deleteEventLogOperationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__deleteEventLogOperationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__deleteEventLogOperationResponse %p -> %p\n", q, p));
	*(_ns1__deleteEventLogOperationResponse*)p = *(_ns1__deleteEventLogOperationResponse*)q;
}

void _ns1__deleteEventLogOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__deleteEventLogOperation::current_USCORElogin_USCOREinfo = NULL;
	soap_default_int(soap, &this->_ns1__deleteEventLogOperation::even_USCOREid);
	/* transient soap skipped */
}

void _ns1__deleteEventLogOperation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, &this->_ns1__deleteEventLogOperation::current_USCORElogin_USCOREinfo);
	/* transient soap skipped */
}

int _ns1__deleteEventLogOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__deleteEventLogOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__deleteEventLogOperation(struct soap *soap, const char *tag, int id, const _ns1__deleteEventLogOperation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__deleteEventLogOperation), type))
		return soap->error;
	if (a->_ns1__deleteEventLogOperation::current_USCORElogin_USCOREinfo)
	{	if (soap_out_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", -1, &a->_ns1__deleteEventLogOperation::current_USCORElogin_USCOREinfo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "current_login_info"))
		return soap->error;
	if (soap_out_int(soap, "even_id", -1, &(a->_ns1__deleteEventLogOperation::even_USCOREid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__deleteEventLogOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__deleteEventLogOperation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__deleteEventLogOperation * SOAP_FMAC4 soap_in__ns1__deleteEventLogOperation(struct soap *soap, const char *tag, _ns1__deleteEventLogOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__deleteEventLogOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__deleteEventLogOperation, sizeof(_ns1__deleteEventLogOperation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__deleteEventLogOperation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__deleteEventLogOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_current_USCORElogin_USCOREinfo1 = 1;
	size_t soap_flag_even_USCOREid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_current_USCORElogin_USCOREinfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", &(a->_ns1__deleteEventLogOperation::current_USCORElogin_USCOREinfo), "ns1:CURR_LOGIN_INFO_Type"))
				{	soap_flag_current_USCORElogin_USCOREinfo1--;
					continue;
				}
			if (soap_flag_even_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "even_id", &(a->_ns1__deleteEventLogOperation::even_USCOREid), "xsd:int"))
				{	soap_flag_even_USCOREid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__deleteEventLogOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__deleteEventLogOperation, 0, sizeof(_ns1__deleteEventLogOperation), 0, soap_copy__ns1__deleteEventLogOperation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_current_USCORElogin_USCOREinfo1 > 0 || soap_flag_even_USCOREid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__deleteEventLogOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__deleteEventLogOperation);
	if (this->soap_out(soap, tag?tag:"ns1:deleteEventLogOperation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__deleteEventLogOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__deleteEventLogOperation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__deleteEventLogOperation * SOAP_FMAC4 soap_get__ns1__deleteEventLogOperation(struct soap *soap, _ns1__deleteEventLogOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__deleteEventLogOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__deleteEventLogOperation * SOAP_FMAC2 soap_instantiate__ns1__deleteEventLogOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__deleteEventLogOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__deleteEventLogOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__deleteEventLogOperation);
		if (size)
			*size = sizeof(_ns1__deleteEventLogOperation);
		((_ns1__deleteEventLogOperation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__deleteEventLogOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__deleteEventLogOperation);
		for (int i = 0; i < n; i++)
			((_ns1__deleteEventLogOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__deleteEventLogOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__deleteEventLogOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__deleteEventLogOperation %p -> %p\n", q, p));
	*(_ns1__deleteEventLogOperation*)p = *(_ns1__deleteEventLogOperation*)q;
}

void _ns1__updateReadEventLogOperationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, &this->_ns1__updateReadEventLogOperationResponse::message_USCOREresult);
	/* transient soap skipped */
}

void _ns1__updateReadEventLogOperationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__updateReadEventLogOperationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__updateReadEventLogOperationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__updateReadEventLogOperationResponse(struct soap *soap, const char *tag, int id, const _ns1__updateReadEventLogOperationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__updateReadEventLogOperationResponse), type))
		return soap->error;
	if (soap_out_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", -1, &(a->_ns1__updateReadEventLogOperationResponse::message_USCOREresult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__updateReadEventLogOperationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__updateReadEventLogOperationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__updateReadEventLogOperationResponse * SOAP_FMAC4 soap_in__ns1__updateReadEventLogOperationResponse(struct soap *soap, const char *tag, _ns1__updateReadEventLogOperationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__updateReadEventLogOperationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__updateReadEventLogOperationResponse, sizeof(_ns1__updateReadEventLogOperationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__updateReadEventLogOperationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__updateReadEventLogOperationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message_USCOREresult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message_USCOREresult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", &(a->_ns1__updateReadEventLogOperationResponse::message_USCOREresult), "ns1:MESSAGE_RESULT_Enum"))
				{	soap_flag_message_USCOREresult1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__updateReadEventLogOperationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__updateReadEventLogOperationResponse, 0, sizeof(_ns1__updateReadEventLogOperationResponse), 0, soap_copy__ns1__updateReadEventLogOperationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_message_USCOREresult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__updateReadEventLogOperationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__updateReadEventLogOperationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:updateReadEventLogOperationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__updateReadEventLogOperationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__updateReadEventLogOperationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__updateReadEventLogOperationResponse * SOAP_FMAC4 soap_get__ns1__updateReadEventLogOperationResponse(struct soap *soap, _ns1__updateReadEventLogOperationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__updateReadEventLogOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__updateReadEventLogOperationResponse * SOAP_FMAC2 soap_instantiate__ns1__updateReadEventLogOperationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__updateReadEventLogOperationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__updateReadEventLogOperationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__updateReadEventLogOperationResponse);
		if (size)
			*size = sizeof(_ns1__updateReadEventLogOperationResponse);
		((_ns1__updateReadEventLogOperationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__updateReadEventLogOperationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__updateReadEventLogOperationResponse);
		for (int i = 0; i < n; i++)
			((_ns1__updateReadEventLogOperationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__updateReadEventLogOperationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__updateReadEventLogOperationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__updateReadEventLogOperationResponse %p -> %p\n", q, p));
	*(_ns1__updateReadEventLogOperationResponse*)p = *(_ns1__updateReadEventLogOperationResponse*)q;
}

void _ns1__updateReadEventLogOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__updateReadEventLogOperation::current_USCORElogin_USCOREinfo = NULL;
	soap_default_int(soap, &this->_ns1__updateReadEventLogOperation::even_USCOREid);
	/* transient soap skipped */
}

void _ns1__updateReadEventLogOperation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, &this->_ns1__updateReadEventLogOperation::current_USCORElogin_USCOREinfo);
	/* transient soap skipped */
}

int _ns1__updateReadEventLogOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__updateReadEventLogOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__updateReadEventLogOperation(struct soap *soap, const char *tag, int id, const _ns1__updateReadEventLogOperation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__updateReadEventLogOperation), type))
		return soap->error;
	if (a->_ns1__updateReadEventLogOperation::current_USCORElogin_USCOREinfo)
	{	if (soap_out_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", -1, &a->_ns1__updateReadEventLogOperation::current_USCORElogin_USCOREinfo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "current_login_info"))
		return soap->error;
	if (soap_out_int(soap, "even_id", -1, &(a->_ns1__updateReadEventLogOperation::even_USCOREid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__updateReadEventLogOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__updateReadEventLogOperation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__updateReadEventLogOperation * SOAP_FMAC4 soap_in__ns1__updateReadEventLogOperation(struct soap *soap, const char *tag, _ns1__updateReadEventLogOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__updateReadEventLogOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__updateReadEventLogOperation, sizeof(_ns1__updateReadEventLogOperation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__updateReadEventLogOperation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__updateReadEventLogOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_current_USCORElogin_USCOREinfo1 = 1;
	size_t soap_flag_even_USCOREid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_current_USCORElogin_USCOREinfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", &(a->_ns1__updateReadEventLogOperation::current_USCORElogin_USCOREinfo), "ns1:CURR_LOGIN_INFO_Type"))
				{	soap_flag_current_USCORElogin_USCOREinfo1--;
					continue;
				}
			if (soap_flag_even_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "even_id", &(a->_ns1__updateReadEventLogOperation::even_USCOREid), "xsd:int"))
				{	soap_flag_even_USCOREid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__updateReadEventLogOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__updateReadEventLogOperation, 0, sizeof(_ns1__updateReadEventLogOperation), 0, soap_copy__ns1__updateReadEventLogOperation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_current_USCORElogin_USCOREinfo1 > 0 || soap_flag_even_USCOREid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__updateReadEventLogOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__updateReadEventLogOperation);
	if (this->soap_out(soap, tag?tag:"ns1:updateReadEventLogOperation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__updateReadEventLogOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__updateReadEventLogOperation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__updateReadEventLogOperation * SOAP_FMAC4 soap_get__ns1__updateReadEventLogOperation(struct soap *soap, _ns1__updateReadEventLogOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__updateReadEventLogOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__updateReadEventLogOperation * SOAP_FMAC2 soap_instantiate__ns1__updateReadEventLogOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__updateReadEventLogOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__updateReadEventLogOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__updateReadEventLogOperation);
		if (size)
			*size = sizeof(_ns1__updateReadEventLogOperation);
		((_ns1__updateReadEventLogOperation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__updateReadEventLogOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__updateReadEventLogOperation);
		for (int i = 0; i < n; i++)
			((_ns1__updateReadEventLogOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__updateReadEventLogOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__updateReadEventLogOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__updateReadEventLogOperation %p -> %p\n", q, p));
	*(_ns1__updateReadEventLogOperation*)p = *(_ns1__updateReadEventLogOperation*)q;
}

void _ns1__getEventLogOperationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, &this->_ns1__getEventLogOperationResponse::message_USCOREresult);
	this->_ns1__getEventLogOperationResponse::__sizeeventlog_USCORElist = 0;
	this->_ns1__getEventLogOperationResponse::eventlog_USCORElist = NULL;
	/* transient soap skipped */
}

void _ns1__getEventLogOperationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->_ns1__getEventLogOperationResponse::eventlog_USCORElist)
	{	int i;
		for (i = 0; i < this->_ns1__getEventLogOperationResponse::__sizeeventlog_USCORElist; i++)
		{
			soap_serialize_PointerTons1__EVENT_USCORELOG_USCOREINFO_USCOREType(soap, this->_ns1__getEventLogOperationResponse::eventlog_USCORElist + i);
		}
	}
	/* transient soap skipped */
}

int _ns1__getEventLogOperationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getEventLogOperationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getEventLogOperationResponse(struct soap *soap, const char *tag, int id, const _ns1__getEventLogOperationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getEventLogOperationResponse), type))
		return soap->error;
	if (soap_out_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", -1, &(a->_ns1__getEventLogOperationResponse::message_USCOREresult), ""))
		return soap->error;
	if (a->_ns1__getEventLogOperationResponse::eventlog_USCORElist)
	{	int i;
		for (i = 0; i < a->_ns1__getEventLogOperationResponse::__sizeeventlog_USCORElist; i++)
			if (soap_out_PointerTons1__EVENT_USCORELOG_USCOREINFO_USCOREType(soap, "eventlog_list", -1, a->_ns1__getEventLogOperationResponse::eventlog_USCORElist + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getEventLogOperationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getEventLogOperationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getEventLogOperationResponse * SOAP_FMAC4 soap_in__ns1__getEventLogOperationResponse(struct soap *soap, const char *tag, _ns1__getEventLogOperationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getEventLogOperationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getEventLogOperationResponse, sizeof(_ns1__getEventLogOperationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getEventLogOperationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getEventLogOperationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message_USCOREresult1 = 1;
	struct soap_blist *soap_blist_eventlog_USCORElist1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message_USCOREresult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", &(a->_ns1__getEventLogOperationResponse::message_USCOREresult), "ns1:MESSAGE_RESULT_Enum"))
				{	soap_flag_message_USCOREresult1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "eventlog_list", 1, NULL))
			{	if (a->_ns1__getEventLogOperationResponse::eventlog_USCORElist == NULL)
				{	if (soap_blist_eventlog_USCORElist1 == NULL)
						soap_blist_eventlog_USCORElist1 = soap_new_block(soap);
					a->_ns1__getEventLogOperationResponse::eventlog_USCORElist = (ns1__EVENT_USCORELOG_USCOREINFO_USCOREType **)soap_push_block(soap, soap_blist_eventlog_USCORElist1, sizeof(ns1__EVENT_USCORELOG_USCOREINFO_USCOREType *));
					if (a->_ns1__getEventLogOperationResponse::eventlog_USCORElist == NULL)
						return NULL;
					*a->_ns1__getEventLogOperationResponse::eventlog_USCORElist = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__EVENT_USCORELOG_USCOREINFO_USCOREType(soap, "eventlog_list", a->_ns1__getEventLogOperationResponse::eventlog_USCORElist, "ns1:EVENT_LOG_INFO_Type"))
				{	a->_ns1__getEventLogOperationResponse::__sizeeventlog_USCORElist++;
					a->_ns1__getEventLogOperationResponse::eventlog_USCORElist = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_ns1__getEventLogOperationResponse::eventlog_USCORElist)
			soap_pop_block(soap, soap_blist_eventlog_USCORElist1);
		if (a->_ns1__getEventLogOperationResponse::__sizeeventlog_USCORElist)
			a->_ns1__getEventLogOperationResponse::eventlog_USCORElist = (ns1__EVENT_USCORELOG_USCOREINFO_USCOREType **)soap_save_block(soap, soap_blist_eventlog_USCORElist1, NULL, 1);
		else
		{	a->_ns1__getEventLogOperationResponse::eventlog_USCORElist = NULL;
			if (soap_blist_eventlog_USCORElist1)
				soap_end_block(soap, soap_blist_eventlog_USCORElist1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getEventLogOperationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getEventLogOperationResponse, 0, sizeof(_ns1__getEventLogOperationResponse), 0, soap_copy__ns1__getEventLogOperationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_message_USCOREresult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getEventLogOperationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getEventLogOperationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getEventLogOperationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getEventLogOperationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getEventLogOperationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getEventLogOperationResponse * SOAP_FMAC4 soap_get__ns1__getEventLogOperationResponse(struct soap *soap, _ns1__getEventLogOperationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getEventLogOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getEventLogOperationResponse * SOAP_FMAC2 soap_instantiate__ns1__getEventLogOperationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getEventLogOperationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getEventLogOperationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getEventLogOperationResponse);
		if (size)
			*size = sizeof(_ns1__getEventLogOperationResponse);
		((_ns1__getEventLogOperationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getEventLogOperationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getEventLogOperationResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getEventLogOperationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getEventLogOperationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getEventLogOperationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getEventLogOperationResponse %p -> %p\n", q, p));
	*(_ns1__getEventLogOperationResponse*)p = *(_ns1__getEventLogOperationResponse*)q;
}

void _ns1__getEventLogOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getEventLogOperation::current_USCORElogin_USCOREinfo = NULL;
	soap_default_string(soap, &this->_ns1__getEventLogOperation::dcu_USCOREid);
	soap_default_ns1__EVENTLOG_USCORETYPE_USCOREEnum(soap, &this->_ns1__getEventLogOperation::eventlog_USCOREtype);
	/* transient soap skipped */
}

void _ns1__getEventLogOperation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, &this->_ns1__getEventLogOperation::current_USCORElogin_USCOREinfo);
	soap_serialize_string(soap, &this->_ns1__getEventLogOperation::dcu_USCOREid);
	/* transient soap skipped */
}

int _ns1__getEventLogOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getEventLogOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getEventLogOperation(struct soap *soap, const char *tag, int id, const _ns1__getEventLogOperation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getEventLogOperation), type))
		return soap->error;
	if (a->_ns1__getEventLogOperation::current_USCORElogin_USCOREinfo)
	{	if (soap_out_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", -1, &a->_ns1__getEventLogOperation::current_USCORElogin_USCOREinfo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "current_login_info"))
		return soap->error;
	if (a->_ns1__getEventLogOperation::dcu_USCOREid)
	{	if (soap_out_string(soap, "dcu_id", -1, &a->_ns1__getEventLogOperation::dcu_USCOREid, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "dcu_id"))
		return soap->error;
	if (soap_out_ns1__EVENTLOG_USCORETYPE_USCOREEnum(soap, "eventlog_type", -1, &(a->_ns1__getEventLogOperation::eventlog_USCOREtype), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getEventLogOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getEventLogOperation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getEventLogOperation * SOAP_FMAC4 soap_in__ns1__getEventLogOperation(struct soap *soap, const char *tag, _ns1__getEventLogOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getEventLogOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getEventLogOperation, sizeof(_ns1__getEventLogOperation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getEventLogOperation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getEventLogOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_current_USCORElogin_USCOREinfo1 = 1;
	size_t soap_flag_dcu_USCOREid1 = 1;
	size_t soap_flag_eventlog_USCOREtype1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_current_USCORElogin_USCOREinfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", &(a->_ns1__getEventLogOperation::current_USCORElogin_USCOREinfo), "ns1:CURR_LOGIN_INFO_Type"))
				{	soap_flag_current_USCORElogin_USCOREinfo1--;
					continue;
				}
			if (soap_flag_dcu_USCOREid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "dcu_id", &(a->_ns1__getEventLogOperation::dcu_USCOREid), "xsd:string"))
				{	soap_flag_dcu_USCOREid1--;
					continue;
				}
			if (soap_flag_eventlog_USCOREtype1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__EVENTLOG_USCORETYPE_USCOREEnum(soap, "eventlog_type", &(a->_ns1__getEventLogOperation::eventlog_USCOREtype), "ns1:EVENTLOG_TYPE_Enum"))
				{	soap_flag_eventlog_USCOREtype1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getEventLogOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getEventLogOperation, 0, sizeof(_ns1__getEventLogOperation), 0, soap_copy__ns1__getEventLogOperation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_current_USCORElogin_USCOREinfo1 > 0 || soap_flag_dcu_USCOREid1 > 0 || soap_flag_eventlog_USCOREtype1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getEventLogOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getEventLogOperation);
	if (this->soap_out(soap, tag?tag:"ns1:getEventLogOperation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getEventLogOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getEventLogOperation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getEventLogOperation * SOAP_FMAC4 soap_get__ns1__getEventLogOperation(struct soap *soap, _ns1__getEventLogOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getEventLogOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getEventLogOperation * SOAP_FMAC2 soap_instantiate__ns1__getEventLogOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getEventLogOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getEventLogOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getEventLogOperation);
		if (size)
			*size = sizeof(_ns1__getEventLogOperation);
		((_ns1__getEventLogOperation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getEventLogOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getEventLogOperation);
		for (int i = 0; i < n; i++)
			((_ns1__getEventLogOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getEventLogOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getEventLogOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getEventLogOperation %p -> %p\n", q, p));
	*(_ns1__getEventLogOperation*)p = *(_ns1__getEventLogOperation*)q;
}

void _ns1__setProgramDcuOperationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, &this->_ns1__setProgramDcuOperationResponse::message_USCOREresult);
	/* transient soap skipped */
}

void _ns1__setProgramDcuOperationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__setProgramDcuOperationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__setProgramDcuOperationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__setProgramDcuOperationResponse(struct soap *soap, const char *tag, int id, const _ns1__setProgramDcuOperationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__setProgramDcuOperationResponse), type))
		return soap->error;
	if (soap_out_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", -1, &(a->_ns1__setProgramDcuOperationResponse::message_USCOREresult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__setProgramDcuOperationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__setProgramDcuOperationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__setProgramDcuOperationResponse * SOAP_FMAC4 soap_in__ns1__setProgramDcuOperationResponse(struct soap *soap, const char *tag, _ns1__setProgramDcuOperationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__setProgramDcuOperationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__setProgramDcuOperationResponse, sizeof(_ns1__setProgramDcuOperationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__setProgramDcuOperationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__setProgramDcuOperationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message_USCOREresult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message_USCOREresult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", &(a->_ns1__setProgramDcuOperationResponse::message_USCOREresult), "ns1:MESSAGE_RESULT_Enum"))
				{	soap_flag_message_USCOREresult1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__setProgramDcuOperationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__setProgramDcuOperationResponse, 0, sizeof(_ns1__setProgramDcuOperationResponse), 0, soap_copy__ns1__setProgramDcuOperationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_message_USCOREresult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__setProgramDcuOperationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__setProgramDcuOperationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:setProgramDcuOperationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__setProgramDcuOperationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__setProgramDcuOperationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__setProgramDcuOperationResponse * SOAP_FMAC4 soap_get__ns1__setProgramDcuOperationResponse(struct soap *soap, _ns1__setProgramDcuOperationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__setProgramDcuOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__setProgramDcuOperationResponse * SOAP_FMAC2 soap_instantiate__ns1__setProgramDcuOperationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__setProgramDcuOperationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__setProgramDcuOperationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__setProgramDcuOperationResponse);
		if (size)
			*size = sizeof(_ns1__setProgramDcuOperationResponse);
		((_ns1__setProgramDcuOperationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__setProgramDcuOperationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__setProgramDcuOperationResponse);
		for (int i = 0; i < n; i++)
			((_ns1__setProgramDcuOperationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__setProgramDcuOperationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__setProgramDcuOperationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__setProgramDcuOperationResponse %p -> %p\n", q, p));
	*(_ns1__setProgramDcuOperationResponse*)p = *(_ns1__setProgramDcuOperationResponse*)q;
}

void _ns1__setProgramDcuOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__setProgramDcuOperation::current_USCORElogin_USCOREinfo = NULL;
	soap_default_string(soap, &this->_ns1__setProgramDcuOperation::dcu_USCOREid);
	soap_default_int(soap, &this->_ns1__setProgramDcuOperation::dcu_USCOREmode);
	soap_default_int(soap, &this->_ns1__setProgramDcuOperation::dcu_USCOREprogramId);
	/* transient soap skipped */
}

void _ns1__setProgramDcuOperation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, &this->_ns1__setProgramDcuOperation::current_USCORElogin_USCOREinfo);
	soap_serialize_string(soap, &this->_ns1__setProgramDcuOperation::dcu_USCOREid);
	/* transient soap skipped */
}

int _ns1__setProgramDcuOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__setProgramDcuOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__setProgramDcuOperation(struct soap *soap, const char *tag, int id, const _ns1__setProgramDcuOperation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__setProgramDcuOperation), type))
		return soap->error;
	if (a->_ns1__setProgramDcuOperation::current_USCORElogin_USCOREinfo)
	{	if (soap_out_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", -1, &a->_ns1__setProgramDcuOperation::current_USCORElogin_USCOREinfo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "current_login_info"))
		return soap->error;
	if (a->_ns1__setProgramDcuOperation::dcu_USCOREid)
	{	if (soap_out_string(soap, "dcu_id", -1, &a->_ns1__setProgramDcuOperation::dcu_USCOREid, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "dcu_id"))
		return soap->error;
	if (soap_out_int(soap, "dcu_mode", -1, &(a->_ns1__setProgramDcuOperation::dcu_USCOREmode), ""))
		return soap->error;
	if (soap_out_int(soap, "dcu_programId", -1, &(a->_ns1__setProgramDcuOperation::dcu_USCOREprogramId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__setProgramDcuOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__setProgramDcuOperation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__setProgramDcuOperation * SOAP_FMAC4 soap_in__ns1__setProgramDcuOperation(struct soap *soap, const char *tag, _ns1__setProgramDcuOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__setProgramDcuOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__setProgramDcuOperation, sizeof(_ns1__setProgramDcuOperation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__setProgramDcuOperation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__setProgramDcuOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_current_USCORElogin_USCOREinfo1 = 1;
	size_t soap_flag_dcu_USCOREid1 = 1;
	size_t soap_flag_dcu_USCOREmode1 = 1;
	size_t soap_flag_dcu_USCOREprogramId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_current_USCORElogin_USCOREinfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", &(a->_ns1__setProgramDcuOperation::current_USCORElogin_USCOREinfo), "ns1:CURR_LOGIN_INFO_Type"))
				{	soap_flag_current_USCORElogin_USCOREinfo1--;
					continue;
				}
			if (soap_flag_dcu_USCOREid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "dcu_id", &(a->_ns1__setProgramDcuOperation::dcu_USCOREid), "xsd:string"))
				{	soap_flag_dcu_USCOREid1--;
					continue;
				}
			if (soap_flag_dcu_USCOREmode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "dcu_mode", &(a->_ns1__setProgramDcuOperation::dcu_USCOREmode), "xsd:int"))
				{	soap_flag_dcu_USCOREmode1--;
					continue;
				}
			if (soap_flag_dcu_USCOREprogramId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "dcu_programId", &(a->_ns1__setProgramDcuOperation::dcu_USCOREprogramId), "xsd:int"))
				{	soap_flag_dcu_USCOREprogramId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__setProgramDcuOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__setProgramDcuOperation, 0, sizeof(_ns1__setProgramDcuOperation), 0, soap_copy__ns1__setProgramDcuOperation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_current_USCORElogin_USCOREinfo1 > 0 || soap_flag_dcu_USCOREid1 > 0 || soap_flag_dcu_USCOREmode1 > 0 || soap_flag_dcu_USCOREprogramId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__setProgramDcuOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__setProgramDcuOperation);
	if (this->soap_out(soap, tag?tag:"ns1:setProgramDcuOperation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__setProgramDcuOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__setProgramDcuOperation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__setProgramDcuOperation * SOAP_FMAC4 soap_get__ns1__setProgramDcuOperation(struct soap *soap, _ns1__setProgramDcuOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__setProgramDcuOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__setProgramDcuOperation * SOAP_FMAC2 soap_instantiate__ns1__setProgramDcuOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__setProgramDcuOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__setProgramDcuOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__setProgramDcuOperation);
		if (size)
			*size = sizeof(_ns1__setProgramDcuOperation);
		((_ns1__setProgramDcuOperation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__setProgramDcuOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__setProgramDcuOperation);
		for (int i = 0; i < n; i++)
			((_ns1__setProgramDcuOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__setProgramDcuOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__setProgramDcuOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__setProgramDcuOperation %p -> %p\n", q, p));
	*(_ns1__setProgramDcuOperation*)p = *(_ns1__setProgramDcuOperation*)q;
}

void _ns1__controlLineOperationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, &this->_ns1__controlLineOperationResponse::message_USCOREresult);
	/* transient soap skipped */
}

void _ns1__controlLineOperationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__controlLineOperationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__controlLineOperationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__controlLineOperationResponse(struct soap *soap, const char *tag, int id, const _ns1__controlLineOperationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__controlLineOperationResponse), type))
		return soap->error;
	if (soap_out_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", -1, &(a->_ns1__controlLineOperationResponse::message_USCOREresult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__controlLineOperationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__controlLineOperationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__controlLineOperationResponse * SOAP_FMAC4 soap_in__ns1__controlLineOperationResponse(struct soap *soap, const char *tag, _ns1__controlLineOperationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__controlLineOperationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__controlLineOperationResponse, sizeof(_ns1__controlLineOperationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__controlLineOperationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__controlLineOperationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message_USCOREresult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message_USCOREresult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", &(a->_ns1__controlLineOperationResponse::message_USCOREresult), "ns1:MESSAGE_RESULT_Enum"))
				{	soap_flag_message_USCOREresult1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__controlLineOperationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__controlLineOperationResponse, 0, sizeof(_ns1__controlLineOperationResponse), 0, soap_copy__ns1__controlLineOperationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_message_USCOREresult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__controlLineOperationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__controlLineOperationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:controlLineOperationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__controlLineOperationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__controlLineOperationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__controlLineOperationResponse * SOAP_FMAC4 soap_get__ns1__controlLineOperationResponse(struct soap *soap, _ns1__controlLineOperationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__controlLineOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__controlLineOperationResponse * SOAP_FMAC2 soap_instantiate__ns1__controlLineOperationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__controlLineOperationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__controlLineOperationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__controlLineOperationResponse);
		if (size)
			*size = sizeof(_ns1__controlLineOperationResponse);
		((_ns1__controlLineOperationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__controlLineOperationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__controlLineOperationResponse);
		for (int i = 0; i < n; i++)
			((_ns1__controlLineOperationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__controlLineOperationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__controlLineOperationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__controlLineOperationResponse %p -> %p\n", q, p));
	*(_ns1__controlLineOperationResponse*)p = *(_ns1__controlLineOperationResponse*)q;
}

void _ns1__controlLineOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__controlLineOperation::current_USCORElogin_USCOREinfo = NULL;
	soap_default_string(soap, &this->_ns1__controlLineOperation::dcu_USCOREid);
	this->_ns1__controlLineOperation::__sizeline_USCORElist = 0;
	this->_ns1__controlLineOperation::line_USCORElist = NULL;
	/* transient soap skipped */
}

void _ns1__controlLineOperation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, &this->_ns1__controlLineOperation::current_USCORElogin_USCOREinfo);
	soap_serialize_string(soap, &this->_ns1__controlLineOperation::dcu_USCOREid);
	if (this->_ns1__controlLineOperation::line_USCORElist)
	{	int i;
		for (i = 0; i < this->_ns1__controlLineOperation::__sizeline_USCORElist; i++)
		{
			soap_serialize_PointerTons1__LINE_USCOREINFO_USCOREType(soap, this->_ns1__controlLineOperation::line_USCORElist + i);
		}
	}
	/* transient soap skipped */
}

int _ns1__controlLineOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__controlLineOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__controlLineOperation(struct soap *soap, const char *tag, int id, const _ns1__controlLineOperation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__controlLineOperation), type))
		return soap->error;
	if (a->_ns1__controlLineOperation::current_USCORElogin_USCOREinfo)
	{	if (soap_out_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", -1, &a->_ns1__controlLineOperation::current_USCORElogin_USCOREinfo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "current_login_info"))
		return soap->error;
	if (a->_ns1__controlLineOperation::dcu_USCOREid)
	{	if (soap_out_string(soap, "dcu_id", -1, &a->_ns1__controlLineOperation::dcu_USCOREid, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "dcu_id"))
		return soap->error;
	if (a->_ns1__controlLineOperation::line_USCORElist)
	{	int i;
		for (i = 0; i < a->_ns1__controlLineOperation::__sizeline_USCORElist; i++)
			if (soap_out_PointerTons1__LINE_USCOREINFO_USCOREType(soap, "line_list", -1, a->_ns1__controlLineOperation::line_USCORElist + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__controlLineOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__controlLineOperation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__controlLineOperation * SOAP_FMAC4 soap_in__ns1__controlLineOperation(struct soap *soap, const char *tag, _ns1__controlLineOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__controlLineOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__controlLineOperation, sizeof(_ns1__controlLineOperation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__controlLineOperation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__controlLineOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_current_USCORElogin_USCOREinfo1 = 1;
	size_t soap_flag_dcu_USCOREid1 = 1;
	struct soap_blist *soap_blist_line_USCORElist1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_current_USCORElogin_USCOREinfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", &(a->_ns1__controlLineOperation::current_USCORElogin_USCOREinfo), "ns1:CURR_LOGIN_INFO_Type"))
				{	soap_flag_current_USCORElogin_USCOREinfo1--;
					continue;
				}
			if (soap_flag_dcu_USCOREid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "dcu_id", &(a->_ns1__controlLineOperation::dcu_USCOREid), "xsd:string"))
				{	soap_flag_dcu_USCOREid1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "line_list", 1, NULL))
			{	if (a->_ns1__controlLineOperation::line_USCORElist == NULL)
				{	if (soap_blist_line_USCORElist1 == NULL)
						soap_blist_line_USCORElist1 = soap_new_block(soap);
					a->_ns1__controlLineOperation::line_USCORElist = (ns1__LINE_USCOREINFO_USCOREType **)soap_push_block(soap, soap_blist_line_USCORElist1, sizeof(ns1__LINE_USCOREINFO_USCOREType *));
					if (a->_ns1__controlLineOperation::line_USCORElist == NULL)
						return NULL;
					*a->_ns1__controlLineOperation::line_USCORElist = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__LINE_USCOREINFO_USCOREType(soap, "line_list", a->_ns1__controlLineOperation::line_USCORElist, "ns1:LINE_INFO_Type"))
				{	a->_ns1__controlLineOperation::__sizeline_USCORElist++;
					a->_ns1__controlLineOperation::line_USCORElist = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_ns1__controlLineOperation::line_USCORElist)
			soap_pop_block(soap, soap_blist_line_USCORElist1);
		if (a->_ns1__controlLineOperation::__sizeline_USCORElist)
			a->_ns1__controlLineOperation::line_USCORElist = (ns1__LINE_USCOREINFO_USCOREType **)soap_save_block(soap, soap_blist_line_USCORElist1, NULL, 1);
		else
		{	a->_ns1__controlLineOperation::line_USCORElist = NULL;
			if (soap_blist_line_USCORElist1)
				soap_end_block(soap, soap_blist_line_USCORElist1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__controlLineOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__controlLineOperation, 0, sizeof(_ns1__controlLineOperation), 0, soap_copy__ns1__controlLineOperation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_current_USCORElogin_USCOREinfo1 > 0 || soap_flag_dcu_USCOREid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__controlLineOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__controlLineOperation);
	if (this->soap_out(soap, tag?tag:"ns1:controlLineOperation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__controlLineOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__controlLineOperation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__controlLineOperation * SOAP_FMAC4 soap_get__ns1__controlLineOperation(struct soap *soap, _ns1__controlLineOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__controlLineOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__controlLineOperation * SOAP_FMAC2 soap_instantiate__ns1__controlLineOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__controlLineOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__controlLineOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__controlLineOperation);
		if (size)
			*size = sizeof(_ns1__controlLineOperation);
		((_ns1__controlLineOperation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__controlLineOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__controlLineOperation);
		for (int i = 0; i < n; i++)
			((_ns1__controlLineOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__controlLineOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__controlLineOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__controlLineOperation %p -> %p\n", q, p));
	*(_ns1__controlLineOperation*)p = *(_ns1__controlLineOperation*)q;
}

void _ns1__controlLcuOperationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, &this->_ns1__controlLcuOperationResponse::message_USCOREresult);
	this->_ns1__controlLcuOperationResponse::__sizelculist = 0;
	this->_ns1__controlLcuOperationResponse::lculist = NULL;
	/* transient soap skipped */
}

void _ns1__controlLcuOperationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->_ns1__controlLcuOperationResponse::lculist)
	{	int i;
		for (i = 0; i < this->_ns1__controlLcuOperationResponse::__sizelculist; i++)
		{
			soap_serialize_PointerTons1__LCU_USCOREINFO_USCOREType(soap, this->_ns1__controlLcuOperationResponse::lculist + i);
		}
	}
	/* transient soap skipped */
}

int _ns1__controlLcuOperationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__controlLcuOperationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__controlLcuOperationResponse(struct soap *soap, const char *tag, int id, const _ns1__controlLcuOperationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__controlLcuOperationResponse), type))
		return soap->error;
	if (soap_out_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", -1, &(a->_ns1__controlLcuOperationResponse::message_USCOREresult), ""))
		return soap->error;
	if (a->_ns1__controlLcuOperationResponse::lculist)
	{	int i;
		for (i = 0; i < a->_ns1__controlLcuOperationResponse::__sizelculist; i++)
			if (soap_out_PointerTons1__LCU_USCOREINFO_USCOREType(soap, "lculist", -1, a->_ns1__controlLcuOperationResponse::lculist + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__controlLcuOperationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__controlLcuOperationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__controlLcuOperationResponse * SOAP_FMAC4 soap_in__ns1__controlLcuOperationResponse(struct soap *soap, const char *tag, _ns1__controlLcuOperationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__controlLcuOperationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__controlLcuOperationResponse, sizeof(_ns1__controlLcuOperationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__controlLcuOperationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__controlLcuOperationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message_USCOREresult1 = 1;
	struct soap_blist *soap_blist_lculist1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message_USCOREresult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", &(a->_ns1__controlLcuOperationResponse::message_USCOREresult), "ns1:MESSAGE_RESULT_Enum"))
				{	soap_flag_message_USCOREresult1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "lculist", 1, NULL))
			{	if (a->_ns1__controlLcuOperationResponse::lculist == NULL)
				{	if (soap_blist_lculist1 == NULL)
						soap_blist_lculist1 = soap_new_block(soap);
					a->_ns1__controlLcuOperationResponse::lculist = (ns1__LCU_USCOREINFO_USCOREType **)soap_push_block(soap, soap_blist_lculist1, sizeof(ns1__LCU_USCOREINFO_USCOREType *));
					if (a->_ns1__controlLcuOperationResponse::lculist == NULL)
						return NULL;
					*a->_ns1__controlLcuOperationResponse::lculist = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__LCU_USCOREINFO_USCOREType(soap, "lculist", a->_ns1__controlLcuOperationResponse::lculist, "ns1:LCU_INFO_Type"))
				{	a->_ns1__controlLcuOperationResponse::__sizelculist++;
					a->_ns1__controlLcuOperationResponse::lculist = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_ns1__controlLcuOperationResponse::lculist)
			soap_pop_block(soap, soap_blist_lculist1);
		if (a->_ns1__controlLcuOperationResponse::__sizelculist)
			a->_ns1__controlLcuOperationResponse::lculist = (ns1__LCU_USCOREINFO_USCOREType **)soap_save_block(soap, soap_blist_lculist1, NULL, 1);
		else
		{	a->_ns1__controlLcuOperationResponse::lculist = NULL;
			if (soap_blist_lculist1)
				soap_end_block(soap, soap_blist_lculist1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__controlLcuOperationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__controlLcuOperationResponse, 0, sizeof(_ns1__controlLcuOperationResponse), 0, soap_copy__ns1__controlLcuOperationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_message_USCOREresult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__controlLcuOperationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__controlLcuOperationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:controlLcuOperationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__controlLcuOperationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__controlLcuOperationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__controlLcuOperationResponse * SOAP_FMAC4 soap_get__ns1__controlLcuOperationResponse(struct soap *soap, _ns1__controlLcuOperationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__controlLcuOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__controlLcuOperationResponse * SOAP_FMAC2 soap_instantiate__ns1__controlLcuOperationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__controlLcuOperationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__controlLcuOperationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__controlLcuOperationResponse);
		if (size)
			*size = sizeof(_ns1__controlLcuOperationResponse);
		((_ns1__controlLcuOperationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__controlLcuOperationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__controlLcuOperationResponse);
		for (int i = 0; i < n; i++)
			((_ns1__controlLcuOperationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__controlLcuOperationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__controlLcuOperationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__controlLcuOperationResponse %p -> %p\n", q, p));
	*(_ns1__controlLcuOperationResponse*)p = *(_ns1__controlLcuOperationResponse*)q;
}

void _ns1__controlLcuOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__controlLcuOperation::current_USCORElogin_USCOREinfo = NULL;
	this->_ns1__controlLcuOperation::__sizelculist = 0;
	this->_ns1__controlLcuOperation::lculist = NULL;
	soap_default_bool(soap, &this->_ns1__controlLcuOperation::istemp);
	soap_default_string(soap, &this->_ns1__controlLcuOperation::dcuid);
	soap_default_bool(soap, &this->_ns1__controlLcuOperation::is_USCOREProgram);
	/* transient soap skipped */
}

void _ns1__controlLcuOperation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, &this->_ns1__controlLcuOperation::current_USCORElogin_USCOREinfo);
	if (this->_ns1__controlLcuOperation::lculist)
	{	int i;
		for (i = 0; i < this->_ns1__controlLcuOperation::__sizelculist; i++)
		{
			soap_serialize_PointerTons1__LCU_USCOREINFO_USCOREType(soap, this->_ns1__controlLcuOperation::lculist + i);
		}
	}
	soap_serialize_string(soap, &this->_ns1__controlLcuOperation::dcuid);
	/* transient soap skipped */
}

int _ns1__controlLcuOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__controlLcuOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__controlLcuOperation(struct soap *soap, const char *tag, int id, const _ns1__controlLcuOperation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__controlLcuOperation), type))
		return soap->error;
	if (a->_ns1__controlLcuOperation::current_USCORElogin_USCOREinfo)
	{	if (soap_out_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", -1, &a->_ns1__controlLcuOperation::current_USCORElogin_USCOREinfo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "current_login_info"))
		return soap->error;
	if (a->_ns1__controlLcuOperation::lculist)
	{	int i;
		for (i = 0; i < a->_ns1__controlLcuOperation::__sizelculist; i++)
			if (soap_out_PointerTons1__LCU_USCOREINFO_USCOREType(soap, "lculist", -1, a->_ns1__controlLcuOperation::lculist + i, ""))
				return soap->error;
	}
	if (soap_out_bool(soap, "istemp", -1, &(a->_ns1__controlLcuOperation::istemp), ""))
		return soap->error;
	if (a->_ns1__controlLcuOperation::dcuid)
	{	if (soap_out_string(soap, "dcuid", -1, &a->_ns1__controlLcuOperation::dcuid, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "dcuid"))
		return soap->error;
	if (soap_out_bool(soap, "is_Program", -1, &(a->_ns1__controlLcuOperation::is_USCOREProgram), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__controlLcuOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__controlLcuOperation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__controlLcuOperation * SOAP_FMAC4 soap_in__ns1__controlLcuOperation(struct soap *soap, const char *tag, _ns1__controlLcuOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__controlLcuOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__controlLcuOperation, sizeof(_ns1__controlLcuOperation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__controlLcuOperation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__controlLcuOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_current_USCORElogin_USCOREinfo1 = 1;
	struct soap_blist *soap_blist_lculist1 = NULL;
	size_t soap_flag_istemp1 = 1;
	size_t soap_flag_dcuid1 = 1;
	size_t soap_flag_is_USCOREProgram1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_current_USCORElogin_USCOREinfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", &(a->_ns1__controlLcuOperation::current_USCORElogin_USCOREinfo), "ns1:CURR_LOGIN_INFO_Type"))
				{	soap_flag_current_USCORElogin_USCOREinfo1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "lculist", 1, NULL))
			{	if (a->_ns1__controlLcuOperation::lculist == NULL)
				{	if (soap_blist_lculist1 == NULL)
						soap_blist_lculist1 = soap_new_block(soap);
					a->_ns1__controlLcuOperation::lculist = (ns1__LCU_USCOREINFO_USCOREType **)soap_push_block(soap, soap_blist_lculist1, sizeof(ns1__LCU_USCOREINFO_USCOREType *));
					if (a->_ns1__controlLcuOperation::lculist == NULL)
						return NULL;
					*a->_ns1__controlLcuOperation::lculist = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__LCU_USCOREINFO_USCOREType(soap, "lculist", a->_ns1__controlLcuOperation::lculist, "ns1:LCU_INFO_Type"))
				{	a->_ns1__controlLcuOperation::__sizelculist++;
					a->_ns1__controlLcuOperation::lculist = NULL;
					continue;
				}
			}
			if (soap_flag_istemp1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "istemp", &(a->_ns1__controlLcuOperation::istemp), "xsd:boolean"))
				{	soap_flag_istemp1--;
					continue;
				}
			if (soap_flag_dcuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "dcuid", &(a->_ns1__controlLcuOperation::dcuid), "xsd:string"))
				{	soap_flag_dcuid1--;
					continue;
				}
			if (soap_flag_is_USCOREProgram1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "is_Program", &(a->_ns1__controlLcuOperation::is_USCOREProgram), "xsd:boolean"))
				{	soap_flag_is_USCOREProgram1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_ns1__controlLcuOperation::lculist)
			soap_pop_block(soap, soap_blist_lculist1);
		if (a->_ns1__controlLcuOperation::__sizelculist)
			a->_ns1__controlLcuOperation::lculist = (ns1__LCU_USCOREINFO_USCOREType **)soap_save_block(soap, soap_blist_lculist1, NULL, 1);
		else
		{	a->_ns1__controlLcuOperation::lculist = NULL;
			if (soap_blist_lculist1)
				soap_end_block(soap, soap_blist_lculist1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__controlLcuOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__controlLcuOperation, 0, sizeof(_ns1__controlLcuOperation), 0, soap_copy__ns1__controlLcuOperation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_current_USCORElogin_USCOREinfo1 > 0 || soap_flag_istemp1 > 0 || soap_flag_dcuid1 > 0 || soap_flag_is_USCOREProgram1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__controlLcuOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__controlLcuOperation);
	if (this->soap_out(soap, tag?tag:"ns1:controlLcuOperation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__controlLcuOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__controlLcuOperation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__controlLcuOperation * SOAP_FMAC4 soap_get__ns1__controlLcuOperation(struct soap *soap, _ns1__controlLcuOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__controlLcuOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__controlLcuOperation * SOAP_FMAC2 soap_instantiate__ns1__controlLcuOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__controlLcuOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__controlLcuOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__controlLcuOperation);
		if (size)
			*size = sizeof(_ns1__controlLcuOperation);
		((_ns1__controlLcuOperation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__controlLcuOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__controlLcuOperation);
		for (int i = 0; i < n; i++)
			((_ns1__controlLcuOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__controlLcuOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__controlLcuOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__controlLcuOperation %p -> %p\n", q, p));
	*(_ns1__controlLcuOperation*)p = *(_ns1__controlLcuOperation*)q;
}

void _ns1__removeProgramOperationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, &this->_ns1__removeProgramOperationResponse::message_USCOREresult);
	/* transient soap skipped */
}

void _ns1__removeProgramOperationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__removeProgramOperationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__removeProgramOperationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__removeProgramOperationResponse(struct soap *soap, const char *tag, int id, const _ns1__removeProgramOperationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__removeProgramOperationResponse), type))
		return soap->error;
	if (soap_out_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", -1, &(a->_ns1__removeProgramOperationResponse::message_USCOREresult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__removeProgramOperationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__removeProgramOperationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__removeProgramOperationResponse * SOAP_FMAC4 soap_in__ns1__removeProgramOperationResponse(struct soap *soap, const char *tag, _ns1__removeProgramOperationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__removeProgramOperationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__removeProgramOperationResponse, sizeof(_ns1__removeProgramOperationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__removeProgramOperationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__removeProgramOperationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message_USCOREresult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message_USCOREresult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", &(a->_ns1__removeProgramOperationResponse::message_USCOREresult), "ns1:MESSAGE_RESULT_Enum"))
				{	soap_flag_message_USCOREresult1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__removeProgramOperationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__removeProgramOperationResponse, 0, sizeof(_ns1__removeProgramOperationResponse), 0, soap_copy__ns1__removeProgramOperationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_message_USCOREresult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__removeProgramOperationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__removeProgramOperationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:removeProgramOperationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__removeProgramOperationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__removeProgramOperationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__removeProgramOperationResponse * SOAP_FMAC4 soap_get__ns1__removeProgramOperationResponse(struct soap *soap, _ns1__removeProgramOperationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__removeProgramOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__removeProgramOperationResponse * SOAP_FMAC2 soap_instantiate__ns1__removeProgramOperationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__removeProgramOperationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__removeProgramOperationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__removeProgramOperationResponse);
		if (size)
			*size = sizeof(_ns1__removeProgramOperationResponse);
		((_ns1__removeProgramOperationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__removeProgramOperationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__removeProgramOperationResponse);
		for (int i = 0; i < n; i++)
			((_ns1__removeProgramOperationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__removeProgramOperationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__removeProgramOperationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__removeProgramOperationResponse %p -> %p\n", q, p));
	*(_ns1__removeProgramOperationResponse*)p = *(_ns1__removeProgramOperationResponse*)q;
}

void _ns1__removeProgramOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__removeProgramOperation::current_USCORElogin_USCOREinfo = NULL;
	soap_default_int(soap, &this->_ns1__removeProgramOperation::program_USCOREid);
	/* transient soap skipped */
}

void _ns1__removeProgramOperation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, &this->_ns1__removeProgramOperation::current_USCORElogin_USCOREinfo);
	/* transient soap skipped */
}

int _ns1__removeProgramOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__removeProgramOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__removeProgramOperation(struct soap *soap, const char *tag, int id, const _ns1__removeProgramOperation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__removeProgramOperation), type))
		return soap->error;
	if (a->_ns1__removeProgramOperation::current_USCORElogin_USCOREinfo)
	{	if (soap_out_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", -1, &a->_ns1__removeProgramOperation::current_USCORElogin_USCOREinfo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "current_login_info"))
		return soap->error;
	if (soap_out_int(soap, "program_id", -1, &(a->_ns1__removeProgramOperation::program_USCOREid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__removeProgramOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__removeProgramOperation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__removeProgramOperation * SOAP_FMAC4 soap_in__ns1__removeProgramOperation(struct soap *soap, const char *tag, _ns1__removeProgramOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__removeProgramOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__removeProgramOperation, sizeof(_ns1__removeProgramOperation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__removeProgramOperation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__removeProgramOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_current_USCORElogin_USCOREinfo1 = 1;
	size_t soap_flag_program_USCOREid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_current_USCORElogin_USCOREinfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", &(a->_ns1__removeProgramOperation::current_USCORElogin_USCOREinfo), "ns1:CURR_LOGIN_INFO_Type"))
				{	soap_flag_current_USCORElogin_USCOREinfo1--;
					continue;
				}
			if (soap_flag_program_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "program_id", &(a->_ns1__removeProgramOperation::program_USCOREid), "xsd:int"))
				{	soap_flag_program_USCOREid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__removeProgramOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__removeProgramOperation, 0, sizeof(_ns1__removeProgramOperation), 0, soap_copy__ns1__removeProgramOperation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_current_USCORElogin_USCOREinfo1 > 0 || soap_flag_program_USCOREid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__removeProgramOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__removeProgramOperation);
	if (this->soap_out(soap, tag?tag:"ns1:removeProgramOperation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__removeProgramOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__removeProgramOperation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__removeProgramOperation * SOAP_FMAC4 soap_get__ns1__removeProgramOperation(struct soap *soap, _ns1__removeProgramOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__removeProgramOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__removeProgramOperation * SOAP_FMAC2 soap_instantiate__ns1__removeProgramOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__removeProgramOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__removeProgramOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__removeProgramOperation);
		if (size)
			*size = sizeof(_ns1__removeProgramOperation);
		((_ns1__removeProgramOperation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__removeProgramOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__removeProgramOperation);
		for (int i = 0; i < n; i++)
			((_ns1__removeProgramOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__removeProgramOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__removeProgramOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__removeProgramOperation %p -> %p\n", q, p));
	*(_ns1__removeProgramOperation*)p = *(_ns1__removeProgramOperation*)q;
}

void _ns1__addProgramOperationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__addProgramOperationResponse::program_USCOREid);
	soap_default_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, &this->_ns1__addProgramOperationResponse::message_USCOREresult);
	/* transient soap skipped */
}

void _ns1__addProgramOperationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__addProgramOperationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__addProgramOperationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__addProgramOperationResponse(struct soap *soap, const char *tag, int id, const _ns1__addProgramOperationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__addProgramOperationResponse), type))
		return soap->error;
	if (soap_out_int(soap, "program_id", -1, &(a->_ns1__addProgramOperationResponse::program_USCOREid), ""))
		return soap->error;
	if (soap_out_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", -1, &(a->_ns1__addProgramOperationResponse::message_USCOREresult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__addProgramOperationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__addProgramOperationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__addProgramOperationResponse * SOAP_FMAC4 soap_in__ns1__addProgramOperationResponse(struct soap *soap, const char *tag, _ns1__addProgramOperationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__addProgramOperationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__addProgramOperationResponse, sizeof(_ns1__addProgramOperationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__addProgramOperationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__addProgramOperationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_program_USCOREid1 = 1;
	size_t soap_flag_message_USCOREresult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_program_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "program_id", &(a->_ns1__addProgramOperationResponse::program_USCOREid), "xsd:int"))
				{	soap_flag_program_USCOREid1--;
					continue;
				}
			if (soap_flag_message_USCOREresult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", &(a->_ns1__addProgramOperationResponse::message_USCOREresult), "ns1:MESSAGE_RESULT_Enum"))
				{	soap_flag_message_USCOREresult1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__addProgramOperationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__addProgramOperationResponse, 0, sizeof(_ns1__addProgramOperationResponse), 0, soap_copy__ns1__addProgramOperationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_program_USCOREid1 > 0 || soap_flag_message_USCOREresult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__addProgramOperationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__addProgramOperationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:addProgramOperationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__addProgramOperationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__addProgramOperationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__addProgramOperationResponse * SOAP_FMAC4 soap_get__ns1__addProgramOperationResponse(struct soap *soap, _ns1__addProgramOperationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__addProgramOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__addProgramOperationResponse * SOAP_FMAC2 soap_instantiate__ns1__addProgramOperationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__addProgramOperationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__addProgramOperationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__addProgramOperationResponse);
		if (size)
			*size = sizeof(_ns1__addProgramOperationResponse);
		((_ns1__addProgramOperationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__addProgramOperationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__addProgramOperationResponse);
		for (int i = 0; i < n; i++)
			((_ns1__addProgramOperationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__addProgramOperationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__addProgramOperationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__addProgramOperationResponse %p -> %p\n", q, p));
	*(_ns1__addProgramOperationResponse*)p = *(_ns1__addProgramOperationResponse*)q;
}

void _ns1__addProgramOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__addProgramOperation::current_USCORElogin_USCOREinfo = NULL;
	soap_default_string(soap, &this->_ns1__addProgramOperation::program_USCOREname);
	soap_default_int(soap, &this->_ns1__addProgramOperation::program_USCOREzoneId);
	/* transient soap skipped */
}

void _ns1__addProgramOperation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, &this->_ns1__addProgramOperation::current_USCORElogin_USCOREinfo);
	soap_serialize_string(soap, &this->_ns1__addProgramOperation::program_USCOREname);
	/* transient soap skipped */
}

int _ns1__addProgramOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__addProgramOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__addProgramOperation(struct soap *soap, const char *tag, int id, const _ns1__addProgramOperation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__addProgramOperation), type))
		return soap->error;
	if (a->_ns1__addProgramOperation::current_USCORElogin_USCOREinfo)
	{	if (soap_out_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", -1, &a->_ns1__addProgramOperation::current_USCORElogin_USCOREinfo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "current_login_info"))
		return soap->error;
	if (a->_ns1__addProgramOperation::program_USCOREname)
	{	if (soap_out_string(soap, "program_name", -1, &a->_ns1__addProgramOperation::program_USCOREname, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "program_name"))
		return soap->error;
	if (soap_out_int(soap, "program_zoneId", -1, &(a->_ns1__addProgramOperation::program_USCOREzoneId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__addProgramOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__addProgramOperation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__addProgramOperation * SOAP_FMAC4 soap_in__ns1__addProgramOperation(struct soap *soap, const char *tag, _ns1__addProgramOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__addProgramOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__addProgramOperation, sizeof(_ns1__addProgramOperation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__addProgramOperation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__addProgramOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_current_USCORElogin_USCOREinfo1 = 1;
	size_t soap_flag_program_USCOREname1 = 1;
	size_t soap_flag_program_USCOREzoneId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_current_USCORElogin_USCOREinfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", &(a->_ns1__addProgramOperation::current_USCORElogin_USCOREinfo), "ns1:CURR_LOGIN_INFO_Type"))
				{	soap_flag_current_USCORElogin_USCOREinfo1--;
					continue;
				}
			if (soap_flag_program_USCOREname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "program_name", &(a->_ns1__addProgramOperation::program_USCOREname), "xsd:string"))
				{	soap_flag_program_USCOREname1--;
					continue;
				}
			if (soap_flag_program_USCOREzoneId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "program_zoneId", &(a->_ns1__addProgramOperation::program_USCOREzoneId), "xsd:int"))
				{	soap_flag_program_USCOREzoneId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__addProgramOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__addProgramOperation, 0, sizeof(_ns1__addProgramOperation), 0, soap_copy__ns1__addProgramOperation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_current_USCORElogin_USCOREinfo1 > 0 || soap_flag_program_USCOREname1 > 0 || soap_flag_program_USCOREzoneId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__addProgramOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__addProgramOperation);
	if (this->soap_out(soap, tag?tag:"ns1:addProgramOperation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__addProgramOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__addProgramOperation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__addProgramOperation * SOAP_FMAC4 soap_get__ns1__addProgramOperation(struct soap *soap, _ns1__addProgramOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__addProgramOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__addProgramOperation * SOAP_FMAC2 soap_instantiate__ns1__addProgramOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__addProgramOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__addProgramOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__addProgramOperation);
		if (size)
			*size = sizeof(_ns1__addProgramOperation);
		((_ns1__addProgramOperation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__addProgramOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__addProgramOperation);
		for (int i = 0; i < n; i++)
			((_ns1__addProgramOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__addProgramOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__addProgramOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__addProgramOperation %p -> %p\n", q, p));
	*(_ns1__addProgramOperation*)p = *(_ns1__addProgramOperation*)q;
}

void _ns1__editLineOperationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, &this->_ns1__editLineOperationResponse::message_USCOREresult);
	/* transient soap skipped */
}

void _ns1__editLineOperationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__editLineOperationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__editLineOperationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__editLineOperationResponse(struct soap *soap, const char *tag, int id, const _ns1__editLineOperationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__editLineOperationResponse), type))
		return soap->error;
	if (soap_out_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", -1, &(a->_ns1__editLineOperationResponse::message_USCOREresult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__editLineOperationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__editLineOperationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__editLineOperationResponse * SOAP_FMAC4 soap_in__ns1__editLineOperationResponse(struct soap *soap, const char *tag, _ns1__editLineOperationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__editLineOperationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__editLineOperationResponse, sizeof(_ns1__editLineOperationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__editLineOperationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__editLineOperationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message_USCOREresult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message_USCOREresult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", &(a->_ns1__editLineOperationResponse::message_USCOREresult), "ns1:MESSAGE_RESULT_Enum"))
				{	soap_flag_message_USCOREresult1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__editLineOperationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__editLineOperationResponse, 0, sizeof(_ns1__editLineOperationResponse), 0, soap_copy__ns1__editLineOperationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_message_USCOREresult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__editLineOperationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__editLineOperationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:editLineOperationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__editLineOperationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__editLineOperationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__editLineOperationResponse * SOAP_FMAC4 soap_get__ns1__editLineOperationResponse(struct soap *soap, _ns1__editLineOperationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__editLineOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__editLineOperationResponse * SOAP_FMAC2 soap_instantiate__ns1__editLineOperationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__editLineOperationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__editLineOperationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__editLineOperationResponse);
		if (size)
			*size = sizeof(_ns1__editLineOperationResponse);
		((_ns1__editLineOperationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__editLineOperationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__editLineOperationResponse);
		for (int i = 0; i < n; i++)
			((_ns1__editLineOperationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__editLineOperationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__editLineOperationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__editLineOperationResponse %p -> %p\n", q, p));
	*(_ns1__editLineOperationResponse*)p = *(_ns1__editLineOperationResponse*)q;
}

void _ns1__editLineOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__editLineOperation::current_USCORElogin_USCOREinfo = NULL;
	soap_default_int(soap, &this->_ns1__editLineOperation::line_USCOREid);
	this->_ns1__editLineOperation::line_USCOREdata = NULL;
	/* transient soap skipped */
}

void _ns1__editLineOperation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, &this->_ns1__editLineOperation::current_USCORElogin_USCOREinfo);
	soap_serialize_PointerTons1__LINE_USCOREINFO_USCOREType(soap, &this->_ns1__editLineOperation::line_USCOREdata);
	/* transient soap skipped */
}

int _ns1__editLineOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__editLineOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__editLineOperation(struct soap *soap, const char *tag, int id, const _ns1__editLineOperation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__editLineOperation), type))
		return soap->error;
	if (a->_ns1__editLineOperation::current_USCORElogin_USCOREinfo)
	{	if (soap_out_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", -1, &a->_ns1__editLineOperation::current_USCORElogin_USCOREinfo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "current_login_info"))
		return soap->error;
	if (soap_out_int(soap, "line_id", -1, &(a->_ns1__editLineOperation::line_USCOREid), ""))
		return soap->error;
	if (a->_ns1__editLineOperation::line_USCOREdata)
	{	if (soap_out_PointerTons1__LINE_USCOREINFO_USCOREType(soap, "line_data", -1, &a->_ns1__editLineOperation::line_USCOREdata, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "line_data"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__editLineOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__editLineOperation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__editLineOperation * SOAP_FMAC4 soap_in__ns1__editLineOperation(struct soap *soap, const char *tag, _ns1__editLineOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__editLineOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__editLineOperation, sizeof(_ns1__editLineOperation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__editLineOperation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__editLineOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_current_USCORElogin_USCOREinfo1 = 1;
	size_t soap_flag_line_USCOREid1 = 1;
	size_t soap_flag_line_USCOREdata1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_current_USCORElogin_USCOREinfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", &(a->_ns1__editLineOperation::current_USCORElogin_USCOREinfo), "ns1:CURR_LOGIN_INFO_Type"))
				{	soap_flag_current_USCORElogin_USCOREinfo1--;
					continue;
				}
			if (soap_flag_line_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "line_id", &(a->_ns1__editLineOperation::line_USCOREid), "xsd:int"))
				{	soap_flag_line_USCOREid1--;
					continue;
				}
			if (soap_flag_line_USCOREdata1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__LINE_USCOREINFO_USCOREType(soap, "line_data", &(a->_ns1__editLineOperation::line_USCOREdata), "ns1:LINE_INFO_Type"))
				{	soap_flag_line_USCOREdata1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__editLineOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__editLineOperation, 0, sizeof(_ns1__editLineOperation), 0, soap_copy__ns1__editLineOperation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_current_USCORElogin_USCOREinfo1 > 0 || soap_flag_line_USCOREid1 > 0 || soap_flag_line_USCOREdata1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__editLineOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__editLineOperation);
	if (this->soap_out(soap, tag?tag:"ns1:editLineOperation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__editLineOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__editLineOperation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__editLineOperation * SOAP_FMAC4 soap_get__ns1__editLineOperation(struct soap *soap, _ns1__editLineOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__editLineOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__editLineOperation * SOAP_FMAC2 soap_instantiate__ns1__editLineOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__editLineOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__editLineOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__editLineOperation);
		if (size)
			*size = sizeof(_ns1__editLineOperation);
		((_ns1__editLineOperation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__editLineOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__editLineOperation);
		for (int i = 0; i < n; i++)
			((_ns1__editLineOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__editLineOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__editLineOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__editLineOperation %p -> %p\n", q, p));
	*(_ns1__editLineOperation*)p = *(_ns1__editLineOperation*)q;
}

void _ns1__removeLineOperationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, &this->_ns1__removeLineOperationResponse::message_USCOREresult);
	/* transient soap skipped */
}

void _ns1__removeLineOperationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__removeLineOperationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__removeLineOperationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__removeLineOperationResponse(struct soap *soap, const char *tag, int id, const _ns1__removeLineOperationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__removeLineOperationResponse), type))
		return soap->error;
	if (soap_out_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", -1, &(a->_ns1__removeLineOperationResponse::message_USCOREresult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__removeLineOperationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__removeLineOperationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__removeLineOperationResponse * SOAP_FMAC4 soap_in__ns1__removeLineOperationResponse(struct soap *soap, const char *tag, _ns1__removeLineOperationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__removeLineOperationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__removeLineOperationResponse, sizeof(_ns1__removeLineOperationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__removeLineOperationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__removeLineOperationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message_USCOREresult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message_USCOREresult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", &(a->_ns1__removeLineOperationResponse::message_USCOREresult), "ns1:MESSAGE_RESULT_Enum"))
				{	soap_flag_message_USCOREresult1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__removeLineOperationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__removeLineOperationResponse, 0, sizeof(_ns1__removeLineOperationResponse), 0, soap_copy__ns1__removeLineOperationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_message_USCOREresult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__removeLineOperationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__removeLineOperationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:removeLineOperationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__removeLineOperationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__removeLineOperationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__removeLineOperationResponse * SOAP_FMAC4 soap_get__ns1__removeLineOperationResponse(struct soap *soap, _ns1__removeLineOperationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__removeLineOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__removeLineOperationResponse * SOAP_FMAC2 soap_instantiate__ns1__removeLineOperationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__removeLineOperationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__removeLineOperationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__removeLineOperationResponse);
		if (size)
			*size = sizeof(_ns1__removeLineOperationResponse);
		((_ns1__removeLineOperationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__removeLineOperationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__removeLineOperationResponse);
		for (int i = 0; i < n; i++)
			((_ns1__removeLineOperationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__removeLineOperationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__removeLineOperationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__removeLineOperationResponse %p -> %p\n", q, p));
	*(_ns1__removeLineOperationResponse*)p = *(_ns1__removeLineOperationResponse*)q;
}

void _ns1__removeLineOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__removeLineOperation::current_USCORElogin_USCOREinfo = NULL;
	soap_default_int(soap, &this->_ns1__removeLineOperation::line_USCOREid);
	soap_default_string(soap, &this->_ns1__removeLineOperation::dcu_USCOREid);
	/* transient soap skipped */
}

void _ns1__removeLineOperation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, &this->_ns1__removeLineOperation::current_USCORElogin_USCOREinfo);
	soap_serialize_string(soap, &this->_ns1__removeLineOperation::dcu_USCOREid);
	/* transient soap skipped */
}

int _ns1__removeLineOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__removeLineOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__removeLineOperation(struct soap *soap, const char *tag, int id, const _ns1__removeLineOperation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__removeLineOperation), type))
		return soap->error;
	if (a->_ns1__removeLineOperation::current_USCORElogin_USCOREinfo)
	{	if (soap_out_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", -1, &a->_ns1__removeLineOperation::current_USCORElogin_USCOREinfo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "current_login_info"))
		return soap->error;
	if (soap_out_int(soap, "line_id", -1, &(a->_ns1__removeLineOperation::line_USCOREid), ""))
		return soap->error;
	if (a->_ns1__removeLineOperation::dcu_USCOREid)
	{	if (soap_out_string(soap, "dcu_id", -1, &a->_ns1__removeLineOperation::dcu_USCOREid, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "dcu_id"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__removeLineOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__removeLineOperation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__removeLineOperation * SOAP_FMAC4 soap_in__ns1__removeLineOperation(struct soap *soap, const char *tag, _ns1__removeLineOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__removeLineOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__removeLineOperation, sizeof(_ns1__removeLineOperation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__removeLineOperation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__removeLineOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_current_USCORElogin_USCOREinfo1 = 1;
	size_t soap_flag_line_USCOREid1 = 1;
	size_t soap_flag_dcu_USCOREid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_current_USCORElogin_USCOREinfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", &(a->_ns1__removeLineOperation::current_USCORElogin_USCOREinfo), "ns1:CURR_LOGIN_INFO_Type"))
				{	soap_flag_current_USCORElogin_USCOREinfo1--;
					continue;
				}
			if (soap_flag_line_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "line_id", &(a->_ns1__removeLineOperation::line_USCOREid), "xsd:int"))
				{	soap_flag_line_USCOREid1--;
					continue;
				}
			if (soap_flag_dcu_USCOREid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "dcu_id", &(a->_ns1__removeLineOperation::dcu_USCOREid), "xsd:string"))
				{	soap_flag_dcu_USCOREid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__removeLineOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__removeLineOperation, 0, sizeof(_ns1__removeLineOperation), 0, soap_copy__ns1__removeLineOperation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_current_USCORElogin_USCOREinfo1 > 0 || soap_flag_line_USCOREid1 > 0 || soap_flag_dcu_USCOREid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__removeLineOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__removeLineOperation);
	if (this->soap_out(soap, tag?tag:"ns1:removeLineOperation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__removeLineOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__removeLineOperation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__removeLineOperation * SOAP_FMAC4 soap_get__ns1__removeLineOperation(struct soap *soap, _ns1__removeLineOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__removeLineOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__removeLineOperation * SOAP_FMAC2 soap_instantiate__ns1__removeLineOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__removeLineOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__removeLineOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__removeLineOperation);
		if (size)
			*size = sizeof(_ns1__removeLineOperation);
		((_ns1__removeLineOperation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__removeLineOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__removeLineOperation);
		for (int i = 0; i < n; i++)
			((_ns1__removeLineOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__removeLineOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__removeLineOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__removeLineOperation %p -> %p\n", q, p));
	*(_ns1__removeLineOperation*)p = *(_ns1__removeLineOperation*)q;
}

void _ns1__addLineOperationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, &this->_ns1__addLineOperationResponse::message_USCOREresult);
	/* transient soap skipped */
}

void _ns1__addLineOperationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__addLineOperationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__addLineOperationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__addLineOperationResponse(struct soap *soap, const char *tag, int id, const _ns1__addLineOperationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__addLineOperationResponse), type))
		return soap->error;
	if (soap_out_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", -1, &(a->_ns1__addLineOperationResponse::message_USCOREresult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__addLineOperationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__addLineOperationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__addLineOperationResponse * SOAP_FMAC4 soap_in__ns1__addLineOperationResponse(struct soap *soap, const char *tag, _ns1__addLineOperationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__addLineOperationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__addLineOperationResponse, sizeof(_ns1__addLineOperationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__addLineOperationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__addLineOperationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message_USCOREresult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message_USCOREresult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", &(a->_ns1__addLineOperationResponse::message_USCOREresult), "ns1:MESSAGE_RESULT_Enum"))
				{	soap_flag_message_USCOREresult1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__addLineOperationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__addLineOperationResponse, 0, sizeof(_ns1__addLineOperationResponse), 0, soap_copy__ns1__addLineOperationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_message_USCOREresult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__addLineOperationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__addLineOperationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:addLineOperationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__addLineOperationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__addLineOperationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__addLineOperationResponse * SOAP_FMAC4 soap_get__ns1__addLineOperationResponse(struct soap *soap, _ns1__addLineOperationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__addLineOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__addLineOperationResponse * SOAP_FMAC2 soap_instantiate__ns1__addLineOperationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__addLineOperationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__addLineOperationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__addLineOperationResponse);
		if (size)
			*size = sizeof(_ns1__addLineOperationResponse);
		((_ns1__addLineOperationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__addLineOperationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__addLineOperationResponse);
		for (int i = 0; i < n; i++)
			((_ns1__addLineOperationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__addLineOperationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__addLineOperationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__addLineOperationResponse %p -> %p\n", q, p));
	*(_ns1__addLineOperationResponse*)p = *(_ns1__addLineOperationResponse*)q;
}

void _ns1__addLineOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__addLineOperation::current_USCORElogin_USCOREinfo = NULL;
	this->_ns1__addLineOperation::line = NULL;
	/* transient soap skipped */
}

void _ns1__addLineOperation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, &this->_ns1__addLineOperation::current_USCORElogin_USCOREinfo);
	soap_serialize_PointerTons1__LINE_USCOREINFO_USCOREType(soap, &this->_ns1__addLineOperation::line);
	/* transient soap skipped */
}

int _ns1__addLineOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__addLineOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__addLineOperation(struct soap *soap, const char *tag, int id, const _ns1__addLineOperation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__addLineOperation), type))
		return soap->error;
	if (a->_ns1__addLineOperation::current_USCORElogin_USCOREinfo)
	{	if (soap_out_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", -1, &a->_ns1__addLineOperation::current_USCORElogin_USCOREinfo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "current_login_info"))
		return soap->error;
	if (a->_ns1__addLineOperation::line)
	{	if (soap_out_PointerTons1__LINE_USCOREINFO_USCOREType(soap, "line", -1, &a->_ns1__addLineOperation::line, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "line"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__addLineOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__addLineOperation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__addLineOperation * SOAP_FMAC4 soap_in__ns1__addLineOperation(struct soap *soap, const char *tag, _ns1__addLineOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__addLineOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__addLineOperation, sizeof(_ns1__addLineOperation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__addLineOperation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__addLineOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_current_USCORElogin_USCOREinfo1 = 1;
	size_t soap_flag_line1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_current_USCORElogin_USCOREinfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", &(a->_ns1__addLineOperation::current_USCORElogin_USCOREinfo), "ns1:CURR_LOGIN_INFO_Type"))
				{	soap_flag_current_USCORElogin_USCOREinfo1--;
					continue;
				}
			if (soap_flag_line1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__LINE_USCOREINFO_USCOREType(soap, "line", &(a->_ns1__addLineOperation::line), "ns1:LINE_INFO_Type"))
				{	soap_flag_line1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__addLineOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__addLineOperation, 0, sizeof(_ns1__addLineOperation), 0, soap_copy__ns1__addLineOperation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_current_USCORElogin_USCOREinfo1 > 0 || soap_flag_line1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__addLineOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__addLineOperation);
	if (this->soap_out(soap, tag?tag:"ns1:addLineOperation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__addLineOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__addLineOperation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__addLineOperation * SOAP_FMAC4 soap_get__ns1__addLineOperation(struct soap *soap, _ns1__addLineOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__addLineOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__addLineOperation * SOAP_FMAC2 soap_instantiate__ns1__addLineOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__addLineOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__addLineOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__addLineOperation);
		if (size)
			*size = sizeof(_ns1__addLineOperation);
		((_ns1__addLineOperation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__addLineOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__addLineOperation);
		for (int i = 0; i < n; i++)
			((_ns1__addLineOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__addLineOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__addLineOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__addLineOperation %p -> %p\n", q, p));
	*(_ns1__addLineOperation*)p = *(_ns1__addLineOperation*)q;
}

void _ns1__editLcuOperationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, &this->_ns1__editLcuOperationResponse::message_USCOREresult);
	/* transient soap skipped */
}

void _ns1__editLcuOperationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__editLcuOperationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__editLcuOperationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__editLcuOperationResponse(struct soap *soap, const char *tag, int id, const _ns1__editLcuOperationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__editLcuOperationResponse), type))
		return soap->error;
	if (soap_out_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", -1, &(a->_ns1__editLcuOperationResponse::message_USCOREresult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__editLcuOperationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__editLcuOperationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__editLcuOperationResponse * SOAP_FMAC4 soap_in__ns1__editLcuOperationResponse(struct soap *soap, const char *tag, _ns1__editLcuOperationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__editLcuOperationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__editLcuOperationResponse, sizeof(_ns1__editLcuOperationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__editLcuOperationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__editLcuOperationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message_USCOREresult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message_USCOREresult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", &(a->_ns1__editLcuOperationResponse::message_USCOREresult), "ns1:MESSAGE_RESULT_Enum"))
				{	soap_flag_message_USCOREresult1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__editLcuOperationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__editLcuOperationResponse, 0, sizeof(_ns1__editLcuOperationResponse), 0, soap_copy__ns1__editLcuOperationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_message_USCOREresult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__editLcuOperationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__editLcuOperationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:editLcuOperationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__editLcuOperationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__editLcuOperationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__editLcuOperationResponse * SOAP_FMAC4 soap_get__ns1__editLcuOperationResponse(struct soap *soap, _ns1__editLcuOperationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__editLcuOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__editLcuOperationResponse * SOAP_FMAC2 soap_instantiate__ns1__editLcuOperationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__editLcuOperationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__editLcuOperationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__editLcuOperationResponse);
		if (size)
			*size = sizeof(_ns1__editLcuOperationResponse);
		((_ns1__editLcuOperationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__editLcuOperationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__editLcuOperationResponse);
		for (int i = 0; i < n; i++)
			((_ns1__editLcuOperationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__editLcuOperationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__editLcuOperationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__editLcuOperationResponse %p -> %p\n", q, p));
	*(_ns1__editLcuOperationResponse*)p = *(_ns1__editLcuOperationResponse*)q;
}

void _ns1__editLcuOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__editLcuOperation::current_USCORElogin_USCOREinfo = NULL;
	soap_default_string(soap, &this->_ns1__editLcuOperation::lcu_USCOREid);
	this->_ns1__editLcuOperation::lcu_USCOREdata = NULL;
	/* transient soap skipped */
}

void _ns1__editLcuOperation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, &this->_ns1__editLcuOperation::current_USCORElogin_USCOREinfo);
	soap_serialize_string(soap, &this->_ns1__editLcuOperation::lcu_USCOREid);
	soap_serialize_PointerTons1__LCU_USCOREINFO_USCOREType(soap, &this->_ns1__editLcuOperation::lcu_USCOREdata);
	/* transient soap skipped */
}

int _ns1__editLcuOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__editLcuOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__editLcuOperation(struct soap *soap, const char *tag, int id, const _ns1__editLcuOperation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__editLcuOperation), type))
		return soap->error;
	if (a->_ns1__editLcuOperation::current_USCORElogin_USCOREinfo)
	{	if (soap_out_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", -1, &a->_ns1__editLcuOperation::current_USCORElogin_USCOREinfo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "current_login_info"))
		return soap->error;
	if (a->_ns1__editLcuOperation::lcu_USCOREid)
	{	if (soap_out_string(soap, "lcu_id", -1, &a->_ns1__editLcuOperation::lcu_USCOREid, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "lcu_id"))
		return soap->error;
	if (a->_ns1__editLcuOperation::lcu_USCOREdata)
	{	if (soap_out_PointerTons1__LCU_USCOREINFO_USCOREType(soap, "lcu_data", -1, &a->_ns1__editLcuOperation::lcu_USCOREdata, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "lcu_data"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__editLcuOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__editLcuOperation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__editLcuOperation * SOAP_FMAC4 soap_in__ns1__editLcuOperation(struct soap *soap, const char *tag, _ns1__editLcuOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__editLcuOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__editLcuOperation, sizeof(_ns1__editLcuOperation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__editLcuOperation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__editLcuOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_current_USCORElogin_USCOREinfo1 = 1;
	size_t soap_flag_lcu_USCOREid1 = 1;
	size_t soap_flag_lcu_USCOREdata1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_current_USCORElogin_USCOREinfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", &(a->_ns1__editLcuOperation::current_USCORElogin_USCOREinfo), "ns1:CURR_LOGIN_INFO_Type"))
				{	soap_flag_current_USCORElogin_USCOREinfo1--;
					continue;
				}
			if (soap_flag_lcu_USCOREid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "lcu_id", &(a->_ns1__editLcuOperation::lcu_USCOREid), "xsd:string"))
				{	soap_flag_lcu_USCOREid1--;
					continue;
				}
			if (soap_flag_lcu_USCOREdata1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__LCU_USCOREINFO_USCOREType(soap, "lcu_data", &(a->_ns1__editLcuOperation::lcu_USCOREdata), "ns1:LCU_INFO_Type"))
				{	soap_flag_lcu_USCOREdata1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__editLcuOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__editLcuOperation, 0, sizeof(_ns1__editLcuOperation), 0, soap_copy__ns1__editLcuOperation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_current_USCORElogin_USCOREinfo1 > 0 || soap_flag_lcu_USCOREid1 > 0 || soap_flag_lcu_USCOREdata1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__editLcuOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__editLcuOperation);
	if (this->soap_out(soap, tag?tag:"ns1:editLcuOperation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__editLcuOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__editLcuOperation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__editLcuOperation * SOAP_FMAC4 soap_get__ns1__editLcuOperation(struct soap *soap, _ns1__editLcuOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__editLcuOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__editLcuOperation * SOAP_FMAC2 soap_instantiate__ns1__editLcuOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__editLcuOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__editLcuOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__editLcuOperation);
		if (size)
			*size = sizeof(_ns1__editLcuOperation);
		((_ns1__editLcuOperation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__editLcuOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__editLcuOperation);
		for (int i = 0; i < n; i++)
			((_ns1__editLcuOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__editLcuOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__editLcuOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__editLcuOperation %p -> %p\n", q, p));
	*(_ns1__editLcuOperation*)p = *(_ns1__editLcuOperation*)q;
}

void _ns1__removeLcuOperationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, &this->_ns1__removeLcuOperationResponse::message_USCOREresult);
	/* transient soap skipped */
}

void _ns1__removeLcuOperationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__removeLcuOperationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__removeLcuOperationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__removeLcuOperationResponse(struct soap *soap, const char *tag, int id, const _ns1__removeLcuOperationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__removeLcuOperationResponse), type))
		return soap->error;
	if (soap_out_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", -1, &(a->_ns1__removeLcuOperationResponse::message_USCOREresult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__removeLcuOperationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__removeLcuOperationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__removeLcuOperationResponse * SOAP_FMAC4 soap_in__ns1__removeLcuOperationResponse(struct soap *soap, const char *tag, _ns1__removeLcuOperationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__removeLcuOperationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__removeLcuOperationResponse, sizeof(_ns1__removeLcuOperationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__removeLcuOperationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__removeLcuOperationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message_USCOREresult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message_USCOREresult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", &(a->_ns1__removeLcuOperationResponse::message_USCOREresult), "ns1:MESSAGE_RESULT_Enum"))
				{	soap_flag_message_USCOREresult1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__removeLcuOperationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__removeLcuOperationResponse, 0, sizeof(_ns1__removeLcuOperationResponse), 0, soap_copy__ns1__removeLcuOperationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_message_USCOREresult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__removeLcuOperationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__removeLcuOperationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:removeLcuOperationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__removeLcuOperationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__removeLcuOperationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__removeLcuOperationResponse * SOAP_FMAC4 soap_get__ns1__removeLcuOperationResponse(struct soap *soap, _ns1__removeLcuOperationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__removeLcuOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__removeLcuOperationResponse * SOAP_FMAC2 soap_instantiate__ns1__removeLcuOperationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__removeLcuOperationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__removeLcuOperationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__removeLcuOperationResponse);
		if (size)
			*size = sizeof(_ns1__removeLcuOperationResponse);
		((_ns1__removeLcuOperationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__removeLcuOperationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__removeLcuOperationResponse);
		for (int i = 0; i < n; i++)
			((_ns1__removeLcuOperationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__removeLcuOperationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__removeLcuOperationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__removeLcuOperationResponse %p -> %p\n", q, p));
	*(_ns1__removeLcuOperationResponse*)p = *(_ns1__removeLcuOperationResponse*)q;
}

void _ns1__removeLcuOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__removeLcuOperation::current_USCORElogin_USCOREinfo = NULL;
	soap_default_string(soap, &this->_ns1__removeLcuOperation::lcu_USCOREid);
	soap_default_string(soap, &this->_ns1__removeLcuOperation::dcu_USCOREid);
	soap_default_bool(soap, &this->_ns1__removeLcuOperation::is_USCOREall_USCORElcu);
	/* transient soap skipped */
}

void _ns1__removeLcuOperation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, &this->_ns1__removeLcuOperation::current_USCORElogin_USCOREinfo);
	soap_serialize_string(soap, &this->_ns1__removeLcuOperation::lcu_USCOREid);
	soap_serialize_string(soap, &this->_ns1__removeLcuOperation::dcu_USCOREid);
	/* transient soap skipped */
}

int _ns1__removeLcuOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__removeLcuOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__removeLcuOperation(struct soap *soap, const char *tag, int id, const _ns1__removeLcuOperation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__removeLcuOperation), type))
		return soap->error;
	if (a->_ns1__removeLcuOperation::current_USCORElogin_USCOREinfo)
	{	if (soap_out_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", -1, &a->_ns1__removeLcuOperation::current_USCORElogin_USCOREinfo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "current_login_info"))
		return soap->error;
	if (a->_ns1__removeLcuOperation::lcu_USCOREid)
	{	if (soap_out_string(soap, "lcu_id", -1, &a->_ns1__removeLcuOperation::lcu_USCOREid, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "lcu_id"))
		return soap->error;
	if (a->_ns1__removeLcuOperation::dcu_USCOREid)
	{	if (soap_out_string(soap, "dcu_id", -1, &a->_ns1__removeLcuOperation::dcu_USCOREid, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "dcu_id"))
		return soap->error;
	if (soap_out_bool(soap, "is_all_lcu", -1, &(a->_ns1__removeLcuOperation::is_USCOREall_USCORElcu), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__removeLcuOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__removeLcuOperation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__removeLcuOperation * SOAP_FMAC4 soap_in__ns1__removeLcuOperation(struct soap *soap, const char *tag, _ns1__removeLcuOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__removeLcuOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__removeLcuOperation, sizeof(_ns1__removeLcuOperation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__removeLcuOperation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__removeLcuOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_current_USCORElogin_USCOREinfo1 = 1;
	size_t soap_flag_lcu_USCOREid1 = 1;
	size_t soap_flag_dcu_USCOREid1 = 1;
	size_t soap_flag_is_USCOREall_USCORElcu1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_current_USCORElogin_USCOREinfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", &(a->_ns1__removeLcuOperation::current_USCORElogin_USCOREinfo), "ns1:CURR_LOGIN_INFO_Type"))
				{	soap_flag_current_USCORElogin_USCOREinfo1--;
					continue;
				}
			if (soap_flag_lcu_USCOREid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "lcu_id", &(a->_ns1__removeLcuOperation::lcu_USCOREid), "xsd:string"))
				{	soap_flag_lcu_USCOREid1--;
					continue;
				}
			if (soap_flag_dcu_USCOREid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "dcu_id", &(a->_ns1__removeLcuOperation::dcu_USCOREid), "xsd:string"))
				{	soap_flag_dcu_USCOREid1--;
					continue;
				}
			if (soap_flag_is_USCOREall_USCORElcu1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "is_all_lcu", &(a->_ns1__removeLcuOperation::is_USCOREall_USCORElcu), "xsd:boolean"))
				{	soap_flag_is_USCOREall_USCORElcu1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__removeLcuOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__removeLcuOperation, 0, sizeof(_ns1__removeLcuOperation), 0, soap_copy__ns1__removeLcuOperation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_current_USCORElogin_USCOREinfo1 > 0 || soap_flag_lcu_USCOREid1 > 0 || soap_flag_dcu_USCOREid1 > 0 || soap_flag_is_USCOREall_USCORElcu1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__removeLcuOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__removeLcuOperation);
	if (this->soap_out(soap, tag?tag:"ns1:removeLcuOperation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__removeLcuOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__removeLcuOperation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__removeLcuOperation * SOAP_FMAC4 soap_get__ns1__removeLcuOperation(struct soap *soap, _ns1__removeLcuOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__removeLcuOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__removeLcuOperation * SOAP_FMAC2 soap_instantiate__ns1__removeLcuOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__removeLcuOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__removeLcuOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__removeLcuOperation);
		if (size)
			*size = sizeof(_ns1__removeLcuOperation);
		((_ns1__removeLcuOperation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__removeLcuOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__removeLcuOperation);
		for (int i = 0; i < n; i++)
			((_ns1__removeLcuOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__removeLcuOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__removeLcuOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__removeLcuOperation %p -> %p\n", q, p));
	*(_ns1__removeLcuOperation*)p = *(_ns1__removeLcuOperation*)q;
}

void _ns1__addLcuOperationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, &this->_ns1__addLcuOperationResponse::message_USCOREresult);
	/* transient soap skipped */
}

void _ns1__addLcuOperationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__addLcuOperationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__addLcuOperationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__addLcuOperationResponse(struct soap *soap, const char *tag, int id, const _ns1__addLcuOperationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__addLcuOperationResponse), type))
		return soap->error;
	if (soap_out_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", -1, &(a->_ns1__addLcuOperationResponse::message_USCOREresult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__addLcuOperationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__addLcuOperationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__addLcuOperationResponse * SOAP_FMAC4 soap_in__ns1__addLcuOperationResponse(struct soap *soap, const char *tag, _ns1__addLcuOperationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__addLcuOperationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__addLcuOperationResponse, sizeof(_ns1__addLcuOperationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__addLcuOperationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__addLcuOperationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message_USCOREresult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message_USCOREresult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", &(a->_ns1__addLcuOperationResponse::message_USCOREresult), "ns1:MESSAGE_RESULT_Enum"))
				{	soap_flag_message_USCOREresult1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__addLcuOperationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__addLcuOperationResponse, 0, sizeof(_ns1__addLcuOperationResponse), 0, soap_copy__ns1__addLcuOperationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_message_USCOREresult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__addLcuOperationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__addLcuOperationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:addLcuOperationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__addLcuOperationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__addLcuOperationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__addLcuOperationResponse * SOAP_FMAC4 soap_get__ns1__addLcuOperationResponse(struct soap *soap, _ns1__addLcuOperationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__addLcuOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__addLcuOperationResponse * SOAP_FMAC2 soap_instantiate__ns1__addLcuOperationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__addLcuOperationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__addLcuOperationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__addLcuOperationResponse);
		if (size)
			*size = sizeof(_ns1__addLcuOperationResponse);
		((_ns1__addLcuOperationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__addLcuOperationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__addLcuOperationResponse);
		for (int i = 0; i < n; i++)
			((_ns1__addLcuOperationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__addLcuOperationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__addLcuOperationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__addLcuOperationResponse %p -> %p\n", q, p));
	*(_ns1__addLcuOperationResponse*)p = *(_ns1__addLcuOperationResponse*)q;
}

void _ns1__addLcuOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__addLcuOperation::current_USCORElogin_USCOREinfo = NULL;
	this->_ns1__addLcuOperation::lcu = NULL;
	/* transient soap skipped */
}

void _ns1__addLcuOperation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, &this->_ns1__addLcuOperation::current_USCORElogin_USCOREinfo);
	soap_serialize_PointerTons1__LCU_USCOREINFO_USCOREType(soap, &this->_ns1__addLcuOperation::lcu);
	/* transient soap skipped */
}

int _ns1__addLcuOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__addLcuOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__addLcuOperation(struct soap *soap, const char *tag, int id, const _ns1__addLcuOperation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__addLcuOperation), type))
		return soap->error;
	if (a->_ns1__addLcuOperation::current_USCORElogin_USCOREinfo)
	{	if (soap_out_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", -1, &a->_ns1__addLcuOperation::current_USCORElogin_USCOREinfo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "current_login_info"))
		return soap->error;
	if (a->_ns1__addLcuOperation::lcu)
	{	if (soap_out_PointerTons1__LCU_USCOREINFO_USCOREType(soap, "lcu", -1, &a->_ns1__addLcuOperation::lcu, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "lcu"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__addLcuOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__addLcuOperation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__addLcuOperation * SOAP_FMAC4 soap_in__ns1__addLcuOperation(struct soap *soap, const char *tag, _ns1__addLcuOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__addLcuOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__addLcuOperation, sizeof(_ns1__addLcuOperation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__addLcuOperation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__addLcuOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_current_USCORElogin_USCOREinfo1 = 1;
	size_t soap_flag_lcu1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_current_USCORElogin_USCOREinfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", &(a->_ns1__addLcuOperation::current_USCORElogin_USCOREinfo), "ns1:CURR_LOGIN_INFO_Type"))
				{	soap_flag_current_USCORElogin_USCOREinfo1--;
					continue;
				}
			if (soap_flag_lcu1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__LCU_USCOREINFO_USCOREType(soap, "lcu", &(a->_ns1__addLcuOperation::lcu), "ns1:LCU_INFO_Type"))
				{	soap_flag_lcu1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__addLcuOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__addLcuOperation, 0, sizeof(_ns1__addLcuOperation), 0, soap_copy__ns1__addLcuOperation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_current_USCORElogin_USCOREinfo1 > 0 || soap_flag_lcu1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__addLcuOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__addLcuOperation);
	if (this->soap_out(soap, tag?tag:"ns1:addLcuOperation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__addLcuOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__addLcuOperation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__addLcuOperation * SOAP_FMAC4 soap_get__ns1__addLcuOperation(struct soap *soap, _ns1__addLcuOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__addLcuOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__addLcuOperation * SOAP_FMAC2 soap_instantiate__ns1__addLcuOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__addLcuOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__addLcuOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__addLcuOperation);
		if (size)
			*size = sizeof(_ns1__addLcuOperation);
		((_ns1__addLcuOperation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__addLcuOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__addLcuOperation);
		for (int i = 0; i < n; i++)
			((_ns1__addLcuOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__addLcuOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__addLcuOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__addLcuOperation %p -> %p\n", q, p));
	*(_ns1__addLcuOperation*)p = *(_ns1__addLcuOperation*)q;
}

void _ns1__editDcuOperationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, &this->_ns1__editDcuOperationResponse::message_USCOREresult);
	/* transient soap skipped */
}

void _ns1__editDcuOperationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__editDcuOperationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__editDcuOperationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__editDcuOperationResponse(struct soap *soap, const char *tag, int id, const _ns1__editDcuOperationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__editDcuOperationResponse), type))
		return soap->error;
	if (soap_out_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", -1, &(a->_ns1__editDcuOperationResponse::message_USCOREresult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__editDcuOperationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__editDcuOperationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__editDcuOperationResponse * SOAP_FMAC4 soap_in__ns1__editDcuOperationResponse(struct soap *soap, const char *tag, _ns1__editDcuOperationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__editDcuOperationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__editDcuOperationResponse, sizeof(_ns1__editDcuOperationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__editDcuOperationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__editDcuOperationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message_USCOREresult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message_USCOREresult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", &(a->_ns1__editDcuOperationResponse::message_USCOREresult), "ns1:MESSAGE_RESULT_Enum"))
				{	soap_flag_message_USCOREresult1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__editDcuOperationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__editDcuOperationResponse, 0, sizeof(_ns1__editDcuOperationResponse), 0, soap_copy__ns1__editDcuOperationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_message_USCOREresult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__editDcuOperationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__editDcuOperationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:editDcuOperationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__editDcuOperationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__editDcuOperationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__editDcuOperationResponse * SOAP_FMAC4 soap_get__ns1__editDcuOperationResponse(struct soap *soap, _ns1__editDcuOperationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__editDcuOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__editDcuOperationResponse * SOAP_FMAC2 soap_instantiate__ns1__editDcuOperationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__editDcuOperationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__editDcuOperationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__editDcuOperationResponse);
		if (size)
			*size = sizeof(_ns1__editDcuOperationResponse);
		((_ns1__editDcuOperationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__editDcuOperationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__editDcuOperationResponse);
		for (int i = 0; i < n; i++)
			((_ns1__editDcuOperationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__editDcuOperationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__editDcuOperationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__editDcuOperationResponse %p -> %p\n", q, p));
	*(_ns1__editDcuOperationResponse*)p = *(_ns1__editDcuOperationResponse*)q;
}

void _ns1__editDcuOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__editDcuOperation::current_USCORElogin_USCOREinfo = NULL;
	soap_default_string(soap, &this->_ns1__editDcuOperation::dcu_USCOREid);
	this->_ns1__editDcuOperation::dcu_USCOREdata = NULL;
	/* transient soap skipped */
}

void _ns1__editDcuOperation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, &this->_ns1__editDcuOperation::current_USCORElogin_USCOREinfo);
	soap_serialize_string(soap, &this->_ns1__editDcuOperation::dcu_USCOREid);
	soap_serialize_PointerTons1__DCU_USCOREINFO_USCOREType(soap, &this->_ns1__editDcuOperation::dcu_USCOREdata);
	/* transient soap skipped */
}

int _ns1__editDcuOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__editDcuOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__editDcuOperation(struct soap *soap, const char *tag, int id, const _ns1__editDcuOperation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__editDcuOperation), type))
		return soap->error;
	if (a->_ns1__editDcuOperation::current_USCORElogin_USCOREinfo)
	{	if (soap_out_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", -1, &a->_ns1__editDcuOperation::current_USCORElogin_USCOREinfo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "current_login_info"))
		return soap->error;
	if (a->_ns1__editDcuOperation::dcu_USCOREid)
	{	if (soap_out_string(soap, "dcu_id", -1, &a->_ns1__editDcuOperation::dcu_USCOREid, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "dcu_id"))
		return soap->error;
	if (a->_ns1__editDcuOperation::dcu_USCOREdata)
	{	if (soap_out_PointerTons1__DCU_USCOREINFO_USCOREType(soap, "dcu_data", -1, &a->_ns1__editDcuOperation::dcu_USCOREdata, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "dcu_data"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__editDcuOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__editDcuOperation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__editDcuOperation * SOAP_FMAC4 soap_in__ns1__editDcuOperation(struct soap *soap, const char *tag, _ns1__editDcuOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__editDcuOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__editDcuOperation, sizeof(_ns1__editDcuOperation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__editDcuOperation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__editDcuOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_current_USCORElogin_USCOREinfo1 = 1;
	size_t soap_flag_dcu_USCOREid1 = 1;
	size_t soap_flag_dcu_USCOREdata1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_current_USCORElogin_USCOREinfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", &(a->_ns1__editDcuOperation::current_USCORElogin_USCOREinfo), "ns1:CURR_LOGIN_INFO_Type"))
				{	soap_flag_current_USCORElogin_USCOREinfo1--;
					continue;
				}
			if (soap_flag_dcu_USCOREid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "dcu_id", &(a->_ns1__editDcuOperation::dcu_USCOREid), "xsd:string"))
				{	soap_flag_dcu_USCOREid1--;
					continue;
				}
			if (soap_flag_dcu_USCOREdata1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__DCU_USCOREINFO_USCOREType(soap, "dcu_data", &(a->_ns1__editDcuOperation::dcu_USCOREdata), "ns1:DCU_INFO_Type"))
				{	soap_flag_dcu_USCOREdata1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__editDcuOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__editDcuOperation, 0, sizeof(_ns1__editDcuOperation), 0, soap_copy__ns1__editDcuOperation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_current_USCORElogin_USCOREinfo1 > 0 || soap_flag_dcu_USCOREid1 > 0 || soap_flag_dcu_USCOREdata1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__editDcuOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__editDcuOperation);
	if (this->soap_out(soap, tag?tag:"ns1:editDcuOperation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__editDcuOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__editDcuOperation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__editDcuOperation * SOAP_FMAC4 soap_get__ns1__editDcuOperation(struct soap *soap, _ns1__editDcuOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__editDcuOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__editDcuOperation * SOAP_FMAC2 soap_instantiate__ns1__editDcuOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__editDcuOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__editDcuOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__editDcuOperation);
		if (size)
			*size = sizeof(_ns1__editDcuOperation);
		((_ns1__editDcuOperation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__editDcuOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__editDcuOperation);
		for (int i = 0; i < n; i++)
			((_ns1__editDcuOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__editDcuOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__editDcuOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__editDcuOperation %p -> %p\n", q, p));
	*(_ns1__editDcuOperation*)p = *(_ns1__editDcuOperation*)q;
}

void _ns1__removeDcuOperationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, &this->_ns1__removeDcuOperationResponse::message_USCOREresult);
	/* transient soap skipped */
}

void _ns1__removeDcuOperationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__removeDcuOperationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__removeDcuOperationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__removeDcuOperationResponse(struct soap *soap, const char *tag, int id, const _ns1__removeDcuOperationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__removeDcuOperationResponse), type))
		return soap->error;
	if (soap_out_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", -1, &(a->_ns1__removeDcuOperationResponse::message_USCOREresult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__removeDcuOperationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__removeDcuOperationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__removeDcuOperationResponse * SOAP_FMAC4 soap_in__ns1__removeDcuOperationResponse(struct soap *soap, const char *tag, _ns1__removeDcuOperationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__removeDcuOperationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__removeDcuOperationResponse, sizeof(_ns1__removeDcuOperationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__removeDcuOperationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__removeDcuOperationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message_USCOREresult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message_USCOREresult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", &(a->_ns1__removeDcuOperationResponse::message_USCOREresult), "ns1:MESSAGE_RESULT_Enum"))
				{	soap_flag_message_USCOREresult1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__removeDcuOperationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__removeDcuOperationResponse, 0, sizeof(_ns1__removeDcuOperationResponse), 0, soap_copy__ns1__removeDcuOperationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_message_USCOREresult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__removeDcuOperationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__removeDcuOperationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:removeDcuOperationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__removeDcuOperationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__removeDcuOperationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__removeDcuOperationResponse * SOAP_FMAC4 soap_get__ns1__removeDcuOperationResponse(struct soap *soap, _ns1__removeDcuOperationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__removeDcuOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__removeDcuOperationResponse * SOAP_FMAC2 soap_instantiate__ns1__removeDcuOperationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__removeDcuOperationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__removeDcuOperationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__removeDcuOperationResponse);
		if (size)
			*size = sizeof(_ns1__removeDcuOperationResponse);
		((_ns1__removeDcuOperationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__removeDcuOperationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__removeDcuOperationResponse);
		for (int i = 0; i < n; i++)
			((_ns1__removeDcuOperationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__removeDcuOperationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__removeDcuOperationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__removeDcuOperationResponse %p -> %p\n", q, p));
	*(_ns1__removeDcuOperationResponse*)p = *(_ns1__removeDcuOperationResponse*)q;
}

void _ns1__removeDcuOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__removeDcuOperation::current_USCORElogin_USCOREinfo = NULL;
	soap_default_string(soap, &this->_ns1__removeDcuOperation::dcu_USCOREid);
	/* transient soap skipped */
}

void _ns1__removeDcuOperation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, &this->_ns1__removeDcuOperation::current_USCORElogin_USCOREinfo);
	soap_serialize_string(soap, &this->_ns1__removeDcuOperation::dcu_USCOREid);
	/* transient soap skipped */
}

int _ns1__removeDcuOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__removeDcuOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__removeDcuOperation(struct soap *soap, const char *tag, int id, const _ns1__removeDcuOperation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__removeDcuOperation), type))
		return soap->error;
	if (a->_ns1__removeDcuOperation::current_USCORElogin_USCOREinfo)
	{	if (soap_out_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", -1, &a->_ns1__removeDcuOperation::current_USCORElogin_USCOREinfo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "current_login_info"))
		return soap->error;
	if (a->_ns1__removeDcuOperation::dcu_USCOREid)
	{	if (soap_out_string(soap, "dcu_id", -1, &a->_ns1__removeDcuOperation::dcu_USCOREid, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "dcu_id"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__removeDcuOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__removeDcuOperation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__removeDcuOperation * SOAP_FMAC4 soap_in__ns1__removeDcuOperation(struct soap *soap, const char *tag, _ns1__removeDcuOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__removeDcuOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__removeDcuOperation, sizeof(_ns1__removeDcuOperation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__removeDcuOperation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__removeDcuOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_current_USCORElogin_USCOREinfo1 = 1;
	size_t soap_flag_dcu_USCOREid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_current_USCORElogin_USCOREinfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", &(a->_ns1__removeDcuOperation::current_USCORElogin_USCOREinfo), "ns1:CURR_LOGIN_INFO_Type"))
				{	soap_flag_current_USCORElogin_USCOREinfo1--;
					continue;
				}
			if (soap_flag_dcu_USCOREid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "dcu_id", &(a->_ns1__removeDcuOperation::dcu_USCOREid), "xsd:string"))
				{	soap_flag_dcu_USCOREid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__removeDcuOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__removeDcuOperation, 0, sizeof(_ns1__removeDcuOperation), 0, soap_copy__ns1__removeDcuOperation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_current_USCORElogin_USCOREinfo1 > 0 || soap_flag_dcu_USCOREid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__removeDcuOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__removeDcuOperation);
	if (this->soap_out(soap, tag?tag:"ns1:removeDcuOperation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__removeDcuOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__removeDcuOperation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__removeDcuOperation * SOAP_FMAC4 soap_get__ns1__removeDcuOperation(struct soap *soap, _ns1__removeDcuOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__removeDcuOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__removeDcuOperation * SOAP_FMAC2 soap_instantiate__ns1__removeDcuOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__removeDcuOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__removeDcuOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__removeDcuOperation);
		if (size)
			*size = sizeof(_ns1__removeDcuOperation);
		((_ns1__removeDcuOperation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__removeDcuOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__removeDcuOperation);
		for (int i = 0; i < n; i++)
			((_ns1__removeDcuOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__removeDcuOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__removeDcuOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__removeDcuOperation %p -> %p\n", q, p));
	*(_ns1__removeDcuOperation*)p = *(_ns1__removeDcuOperation*)q;
}

void _ns1__addDcuOperationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, &this->_ns1__addDcuOperationResponse::message_USCOREresult);
	/* transient soap skipped */
}

void _ns1__addDcuOperationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__addDcuOperationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__addDcuOperationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__addDcuOperationResponse(struct soap *soap, const char *tag, int id, const _ns1__addDcuOperationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__addDcuOperationResponse), type))
		return soap->error;
	if (soap_out_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", -1, &(a->_ns1__addDcuOperationResponse::message_USCOREresult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__addDcuOperationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__addDcuOperationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__addDcuOperationResponse * SOAP_FMAC4 soap_in__ns1__addDcuOperationResponse(struct soap *soap, const char *tag, _ns1__addDcuOperationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__addDcuOperationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__addDcuOperationResponse, sizeof(_ns1__addDcuOperationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__addDcuOperationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__addDcuOperationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message_USCOREresult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message_USCOREresult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", &(a->_ns1__addDcuOperationResponse::message_USCOREresult), "ns1:MESSAGE_RESULT_Enum"))
				{	soap_flag_message_USCOREresult1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__addDcuOperationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__addDcuOperationResponse, 0, sizeof(_ns1__addDcuOperationResponse), 0, soap_copy__ns1__addDcuOperationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_message_USCOREresult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__addDcuOperationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__addDcuOperationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:addDcuOperationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__addDcuOperationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__addDcuOperationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__addDcuOperationResponse * SOAP_FMAC4 soap_get__ns1__addDcuOperationResponse(struct soap *soap, _ns1__addDcuOperationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__addDcuOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__addDcuOperationResponse * SOAP_FMAC2 soap_instantiate__ns1__addDcuOperationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__addDcuOperationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__addDcuOperationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__addDcuOperationResponse);
		if (size)
			*size = sizeof(_ns1__addDcuOperationResponse);
		((_ns1__addDcuOperationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__addDcuOperationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__addDcuOperationResponse);
		for (int i = 0; i < n; i++)
			((_ns1__addDcuOperationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__addDcuOperationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__addDcuOperationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__addDcuOperationResponse %p -> %p\n", q, p));
	*(_ns1__addDcuOperationResponse*)p = *(_ns1__addDcuOperationResponse*)q;
}

void _ns1__addDcuOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__addDcuOperation::current_USCORElogin_USCOREinfo = NULL;
	this->_ns1__addDcuOperation::dcu = NULL;
	/* transient soap skipped */
}

void _ns1__addDcuOperation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, &this->_ns1__addDcuOperation::current_USCORElogin_USCOREinfo);
	soap_serialize_PointerTons1__DCU_USCOREINFO_USCOREType(soap, &this->_ns1__addDcuOperation::dcu);
	/* transient soap skipped */
}

int _ns1__addDcuOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__addDcuOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__addDcuOperation(struct soap *soap, const char *tag, int id, const _ns1__addDcuOperation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__addDcuOperation), type))
		return soap->error;
	if (a->_ns1__addDcuOperation::current_USCORElogin_USCOREinfo)
	{	if (soap_out_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", -1, &a->_ns1__addDcuOperation::current_USCORElogin_USCOREinfo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "current_login_info"))
		return soap->error;
	if (a->_ns1__addDcuOperation::dcu)
	{	if (soap_out_PointerTons1__DCU_USCOREINFO_USCOREType(soap, "dcu", -1, &a->_ns1__addDcuOperation::dcu, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "dcu"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__addDcuOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__addDcuOperation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__addDcuOperation * SOAP_FMAC4 soap_in__ns1__addDcuOperation(struct soap *soap, const char *tag, _ns1__addDcuOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__addDcuOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__addDcuOperation, sizeof(_ns1__addDcuOperation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__addDcuOperation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__addDcuOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_current_USCORElogin_USCOREinfo1 = 1;
	size_t soap_flag_dcu1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_current_USCORElogin_USCOREinfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", &(a->_ns1__addDcuOperation::current_USCORElogin_USCOREinfo), "ns1:CURR_LOGIN_INFO_Type"))
				{	soap_flag_current_USCORElogin_USCOREinfo1--;
					continue;
				}
			if (soap_flag_dcu1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__DCU_USCOREINFO_USCOREType(soap, "dcu", &(a->_ns1__addDcuOperation::dcu), "ns1:DCU_INFO_Type"))
				{	soap_flag_dcu1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__addDcuOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__addDcuOperation, 0, sizeof(_ns1__addDcuOperation), 0, soap_copy__ns1__addDcuOperation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_current_USCORElogin_USCOREinfo1 > 0 || soap_flag_dcu1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__addDcuOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__addDcuOperation);
	if (this->soap_out(soap, tag?tag:"ns1:addDcuOperation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__addDcuOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__addDcuOperation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__addDcuOperation * SOAP_FMAC4 soap_get__ns1__addDcuOperation(struct soap *soap, _ns1__addDcuOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__addDcuOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__addDcuOperation * SOAP_FMAC2 soap_instantiate__ns1__addDcuOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__addDcuOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__addDcuOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__addDcuOperation);
		if (size)
			*size = sizeof(_ns1__addDcuOperation);
		((_ns1__addDcuOperation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__addDcuOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__addDcuOperation);
		for (int i = 0; i < n; i++)
			((_ns1__addDcuOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__addDcuOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__addDcuOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__addDcuOperation %p -> %p\n", q, p));
	*(_ns1__addDcuOperation*)p = *(_ns1__addDcuOperation*)q;
}

void _ns1__getLineListOperationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, &this->_ns1__getLineListOperationResponse::message_USCOREresult);
	this->_ns1__getLineListOperationResponse::__sizeline_USCORElist = 0;
	this->_ns1__getLineListOperationResponse::line_USCORElist = NULL;
	/* transient soap skipped */
}

void _ns1__getLineListOperationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->_ns1__getLineListOperationResponse::line_USCORElist)
	{	int i;
		for (i = 0; i < this->_ns1__getLineListOperationResponse::__sizeline_USCORElist; i++)
		{
			soap_serialize_PointerTons1__LINE_USCOREINFO_USCOREType(soap, this->_ns1__getLineListOperationResponse::line_USCORElist + i);
		}
	}
	/* transient soap skipped */
}

int _ns1__getLineListOperationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getLineListOperationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getLineListOperationResponse(struct soap *soap, const char *tag, int id, const _ns1__getLineListOperationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getLineListOperationResponse), type))
		return soap->error;
	if (soap_out_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", -1, &(a->_ns1__getLineListOperationResponse::message_USCOREresult), ""))
		return soap->error;
	if (a->_ns1__getLineListOperationResponse::line_USCORElist)
	{	int i;
		for (i = 0; i < a->_ns1__getLineListOperationResponse::__sizeline_USCORElist; i++)
			if (soap_out_PointerTons1__LINE_USCOREINFO_USCOREType(soap, "line_list", -1, a->_ns1__getLineListOperationResponse::line_USCORElist + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getLineListOperationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getLineListOperationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getLineListOperationResponse * SOAP_FMAC4 soap_in__ns1__getLineListOperationResponse(struct soap *soap, const char *tag, _ns1__getLineListOperationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getLineListOperationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getLineListOperationResponse, sizeof(_ns1__getLineListOperationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getLineListOperationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getLineListOperationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message_USCOREresult1 = 1;
	struct soap_blist *soap_blist_line_USCORElist1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message_USCOREresult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", &(a->_ns1__getLineListOperationResponse::message_USCOREresult), "ns1:MESSAGE_RESULT_Enum"))
				{	soap_flag_message_USCOREresult1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "line_list", 1, NULL))
			{	if (a->_ns1__getLineListOperationResponse::line_USCORElist == NULL)
				{	if (soap_blist_line_USCORElist1 == NULL)
						soap_blist_line_USCORElist1 = soap_new_block(soap);
					a->_ns1__getLineListOperationResponse::line_USCORElist = (ns1__LINE_USCOREINFO_USCOREType **)soap_push_block(soap, soap_blist_line_USCORElist1, sizeof(ns1__LINE_USCOREINFO_USCOREType *));
					if (a->_ns1__getLineListOperationResponse::line_USCORElist == NULL)
						return NULL;
					*a->_ns1__getLineListOperationResponse::line_USCORElist = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__LINE_USCOREINFO_USCOREType(soap, "line_list", a->_ns1__getLineListOperationResponse::line_USCORElist, "ns1:LINE_INFO_Type"))
				{	a->_ns1__getLineListOperationResponse::__sizeline_USCORElist++;
					a->_ns1__getLineListOperationResponse::line_USCORElist = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_ns1__getLineListOperationResponse::line_USCORElist)
			soap_pop_block(soap, soap_blist_line_USCORElist1);
		if (a->_ns1__getLineListOperationResponse::__sizeline_USCORElist)
			a->_ns1__getLineListOperationResponse::line_USCORElist = (ns1__LINE_USCOREINFO_USCOREType **)soap_save_block(soap, soap_blist_line_USCORElist1, NULL, 1);
		else
		{	a->_ns1__getLineListOperationResponse::line_USCORElist = NULL;
			if (soap_blist_line_USCORElist1)
				soap_end_block(soap, soap_blist_line_USCORElist1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getLineListOperationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getLineListOperationResponse, 0, sizeof(_ns1__getLineListOperationResponse), 0, soap_copy__ns1__getLineListOperationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_message_USCOREresult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getLineListOperationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getLineListOperationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getLineListOperationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getLineListOperationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getLineListOperationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getLineListOperationResponse * SOAP_FMAC4 soap_get__ns1__getLineListOperationResponse(struct soap *soap, _ns1__getLineListOperationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getLineListOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getLineListOperationResponse * SOAP_FMAC2 soap_instantiate__ns1__getLineListOperationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getLineListOperationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getLineListOperationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getLineListOperationResponse);
		if (size)
			*size = sizeof(_ns1__getLineListOperationResponse);
		((_ns1__getLineListOperationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getLineListOperationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getLineListOperationResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getLineListOperationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getLineListOperationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getLineListOperationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getLineListOperationResponse %p -> %p\n", q, p));
	*(_ns1__getLineListOperationResponse*)p = *(_ns1__getLineListOperationResponse*)q;
}

void _ns1__getLineListOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__getLineListOperation::dcu_USCOREid);
	this->_ns1__getLineListOperation::current_USCORElogin_USCOREinfo = NULL;
	/* transient soap skipped */
}

void _ns1__getLineListOperation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__getLineListOperation::dcu_USCOREid);
	soap_serialize_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, &this->_ns1__getLineListOperation::current_USCORElogin_USCOREinfo);
	/* transient soap skipped */
}

int _ns1__getLineListOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getLineListOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getLineListOperation(struct soap *soap, const char *tag, int id, const _ns1__getLineListOperation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getLineListOperation), type))
		return soap->error;
	if (a->_ns1__getLineListOperation::dcu_USCOREid)
	{	if (soap_out_string(soap, "dcu_id", -1, &a->_ns1__getLineListOperation::dcu_USCOREid, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "dcu_id"))
		return soap->error;
	if (a->_ns1__getLineListOperation::current_USCORElogin_USCOREinfo)
	{	if (soap_out_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", -1, &a->_ns1__getLineListOperation::current_USCORElogin_USCOREinfo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "current_login_info"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getLineListOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getLineListOperation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getLineListOperation * SOAP_FMAC4 soap_in__ns1__getLineListOperation(struct soap *soap, const char *tag, _ns1__getLineListOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getLineListOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getLineListOperation, sizeof(_ns1__getLineListOperation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getLineListOperation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getLineListOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_dcu_USCOREid1 = 1;
	size_t soap_flag_current_USCORElogin_USCOREinfo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dcu_USCOREid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "dcu_id", &(a->_ns1__getLineListOperation::dcu_USCOREid), "xsd:string"))
				{	soap_flag_dcu_USCOREid1--;
					continue;
				}
			if (soap_flag_current_USCORElogin_USCOREinfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", &(a->_ns1__getLineListOperation::current_USCORElogin_USCOREinfo), "ns1:CURR_LOGIN_INFO_Type"))
				{	soap_flag_current_USCORElogin_USCOREinfo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getLineListOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getLineListOperation, 0, sizeof(_ns1__getLineListOperation), 0, soap_copy__ns1__getLineListOperation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_dcu_USCOREid1 > 0 || soap_flag_current_USCORElogin_USCOREinfo1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getLineListOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getLineListOperation);
	if (this->soap_out(soap, tag?tag:"ns1:getLineListOperation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getLineListOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getLineListOperation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getLineListOperation * SOAP_FMAC4 soap_get__ns1__getLineListOperation(struct soap *soap, _ns1__getLineListOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getLineListOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getLineListOperation * SOAP_FMAC2 soap_instantiate__ns1__getLineListOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getLineListOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getLineListOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getLineListOperation);
		if (size)
			*size = sizeof(_ns1__getLineListOperation);
		((_ns1__getLineListOperation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getLineListOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getLineListOperation);
		for (int i = 0; i < n; i++)
			((_ns1__getLineListOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getLineListOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getLineListOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getLineListOperation %p -> %p\n", q, p));
	*(_ns1__getLineListOperation*)p = *(_ns1__getLineListOperation*)q;
}

void _ns1__updateRuntimeForUserOperationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, &this->_ns1__updateRuntimeForUserOperationResponse::message_USCOREresult);
	this->_ns1__updateRuntimeForUserOperationResponse::__sizelcu_USCORElist = 0;
	this->_ns1__updateRuntimeForUserOperationResponse::lcu_USCORElist = NULL;
	this->_ns1__updateRuntimeForUserOperationResponse::__sizedcu_USCORElist = 0;
	this->_ns1__updateRuntimeForUserOperationResponse::dcu_USCORElist = NULL;
	this->_ns1__updateRuntimeForUserOperationResponse::__sizeeventlog_USCORElist = 0;
	this->_ns1__updateRuntimeForUserOperationResponse::eventlog_USCORElist = NULL;
	/* transient soap skipped */
}

void _ns1__updateRuntimeForUserOperationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->_ns1__updateRuntimeForUserOperationResponse::lcu_USCORElist)
	{	int i;
		for (i = 0; i < this->_ns1__updateRuntimeForUserOperationResponse::__sizelcu_USCORElist; i++)
		{
			soap_serialize_PointerTons1__LCU_USCOREINFO_USCOREType(soap, this->_ns1__updateRuntimeForUserOperationResponse::lcu_USCORElist + i);
		}
	}
	if (this->_ns1__updateRuntimeForUserOperationResponse::dcu_USCORElist)
	{	int i;
		for (i = 0; i < this->_ns1__updateRuntimeForUserOperationResponse::__sizedcu_USCORElist; i++)
		{
			soap_serialize_PointerTons1__DCU_USCOREINFO_USCOREType(soap, this->_ns1__updateRuntimeForUserOperationResponse::dcu_USCORElist + i);
		}
	}
	if (this->_ns1__updateRuntimeForUserOperationResponse::eventlog_USCORElist)
	{	int i;
		for (i = 0; i < this->_ns1__updateRuntimeForUserOperationResponse::__sizeeventlog_USCORElist; i++)
		{
			soap_serialize_PointerTons1__EVENT_USCORELOG_USCOREINFO_USCOREType(soap, this->_ns1__updateRuntimeForUserOperationResponse::eventlog_USCORElist + i);
		}
	}
	/* transient soap skipped */
}

int _ns1__updateRuntimeForUserOperationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__updateRuntimeForUserOperationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__updateRuntimeForUserOperationResponse(struct soap *soap, const char *tag, int id, const _ns1__updateRuntimeForUserOperationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__updateRuntimeForUserOperationResponse), type))
		return soap->error;
	if (soap_out_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", -1, &(a->_ns1__updateRuntimeForUserOperationResponse::message_USCOREresult), ""))
		return soap->error;
	if (a->_ns1__updateRuntimeForUserOperationResponse::lcu_USCORElist)
	{	int i;
		for (i = 0; i < a->_ns1__updateRuntimeForUserOperationResponse::__sizelcu_USCORElist; i++)
			if (soap_out_PointerTons1__LCU_USCOREINFO_USCOREType(soap, "lcu_list", -1, a->_ns1__updateRuntimeForUserOperationResponse::lcu_USCORElist + i, ""))
				return soap->error;
	}
	if (a->_ns1__updateRuntimeForUserOperationResponse::dcu_USCORElist)
	{	int i;
		for (i = 0; i < a->_ns1__updateRuntimeForUserOperationResponse::__sizedcu_USCORElist; i++)
			if (soap_out_PointerTons1__DCU_USCOREINFO_USCOREType(soap, "dcu_list", -1, a->_ns1__updateRuntimeForUserOperationResponse::dcu_USCORElist + i, ""))
				return soap->error;
	}
	if (a->_ns1__updateRuntimeForUserOperationResponse::eventlog_USCORElist)
	{	int i;
		for (i = 0; i < a->_ns1__updateRuntimeForUserOperationResponse::__sizeeventlog_USCORElist; i++)
			if (soap_out_PointerTons1__EVENT_USCORELOG_USCOREINFO_USCOREType(soap, "eventlog_list", -1, a->_ns1__updateRuntimeForUserOperationResponse::eventlog_USCORElist + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__updateRuntimeForUserOperationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__updateRuntimeForUserOperationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__updateRuntimeForUserOperationResponse * SOAP_FMAC4 soap_in__ns1__updateRuntimeForUserOperationResponse(struct soap *soap, const char *tag, _ns1__updateRuntimeForUserOperationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__updateRuntimeForUserOperationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__updateRuntimeForUserOperationResponse, sizeof(_ns1__updateRuntimeForUserOperationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__updateRuntimeForUserOperationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__updateRuntimeForUserOperationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message_USCOREresult1 = 1;
	struct soap_blist *soap_blist_lcu_USCORElist1 = NULL;
	struct soap_blist *soap_blist_dcu_USCORElist1 = NULL;
	struct soap_blist *soap_blist_eventlog_USCORElist1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message_USCOREresult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", &(a->_ns1__updateRuntimeForUserOperationResponse::message_USCOREresult), "ns1:MESSAGE_RESULT_Enum"))
				{	soap_flag_message_USCOREresult1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "lcu_list", 1, NULL))
			{	if (a->_ns1__updateRuntimeForUserOperationResponse::lcu_USCORElist == NULL)
				{	if (soap_blist_lcu_USCORElist1 == NULL)
						soap_blist_lcu_USCORElist1 = soap_new_block(soap);
					a->_ns1__updateRuntimeForUserOperationResponse::lcu_USCORElist = (ns1__LCU_USCOREINFO_USCOREType **)soap_push_block(soap, soap_blist_lcu_USCORElist1, sizeof(ns1__LCU_USCOREINFO_USCOREType *));
					if (a->_ns1__updateRuntimeForUserOperationResponse::lcu_USCORElist == NULL)
						return NULL;
					*a->_ns1__updateRuntimeForUserOperationResponse::lcu_USCORElist = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__LCU_USCOREINFO_USCOREType(soap, "lcu_list", a->_ns1__updateRuntimeForUserOperationResponse::lcu_USCORElist, "ns1:LCU_INFO_Type"))
				{	a->_ns1__updateRuntimeForUserOperationResponse::__sizelcu_USCORElist++;
					a->_ns1__updateRuntimeForUserOperationResponse::lcu_USCORElist = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "dcu_list", 1, NULL))
			{	if (a->_ns1__updateRuntimeForUserOperationResponse::dcu_USCORElist == NULL)
				{	if (soap_blist_dcu_USCORElist1 == NULL)
						soap_blist_dcu_USCORElist1 = soap_new_block(soap);
					a->_ns1__updateRuntimeForUserOperationResponse::dcu_USCORElist = (ns1__DCU_USCOREINFO_USCOREType **)soap_push_block(soap, soap_blist_dcu_USCORElist1, sizeof(ns1__DCU_USCOREINFO_USCOREType *));
					if (a->_ns1__updateRuntimeForUserOperationResponse::dcu_USCORElist == NULL)
						return NULL;
					*a->_ns1__updateRuntimeForUserOperationResponse::dcu_USCORElist = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__DCU_USCOREINFO_USCOREType(soap, "dcu_list", a->_ns1__updateRuntimeForUserOperationResponse::dcu_USCORElist, "ns1:DCU_INFO_Type"))
				{	a->_ns1__updateRuntimeForUserOperationResponse::__sizedcu_USCORElist++;
					a->_ns1__updateRuntimeForUserOperationResponse::dcu_USCORElist = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "eventlog_list", 1, NULL))
			{	if (a->_ns1__updateRuntimeForUserOperationResponse::eventlog_USCORElist == NULL)
				{	if (soap_blist_eventlog_USCORElist1 == NULL)
						soap_blist_eventlog_USCORElist1 = soap_new_block(soap);
					a->_ns1__updateRuntimeForUserOperationResponse::eventlog_USCORElist = (ns1__EVENT_USCORELOG_USCOREINFO_USCOREType **)soap_push_block(soap, soap_blist_eventlog_USCORElist1, sizeof(ns1__EVENT_USCORELOG_USCOREINFO_USCOREType *));
					if (a->_ns1__updateRuntimeForUserOperationResponse::eventlog_USCORElist == NULL)
						return NULL;
					*a->_ns1__updateRuntimeForUserOperationResponse::eventlog_USCORElist = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__EVENT_USCORELOG_USCOREINFO_USCOREType(soap, "eventlog_list", a->_ns1__updateRuntimeForUserOperationResponse::eventlog_USCORElist, "ns1:EVENT_LOG_INFO_Type"))
				{	a->_ns1__updateRuntimeForUserOperationResponse::__sizeeventlog_USCORElist++;
					a->_ns1__updateRuntimeForUserOperationResponse::eventlog_USCORElist = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_ns1__updateRuntimeForUserOperationResponse::lcu_USCORElist)
			soap_pop_block(soap, soap_blist_lcu_USCORElist1);
		if (a->_ns1__updateRuntimeForUserOperationResponse::__sizelcu_USCORElist)
			a->_ns1__updateRuntimeForUserOperationResponse::lcu_USCORElist = (ns1__LCU_USCOREINFO_USCOREType **)soap_save_block(soap, soap_blist_lcu_USCORElist1, NULL, 1);
		else
		{	a->_ns1__updateRuntimeForUserOperationResponse::lcu_USCORElist = NULL;
			if (soap_blist_lcu_USCORElist1)
				soap_end_block(soap, soap_blist_lcu_USCORElist1);
		}
		if (a->_ns1__updateRuntimeForUserOperationResponse::dcu_USCORElist)
			soap_pop_block(soap, soap_blist_dcu_USCORElist1);
		if (a->_ns1__updateRuntimeForUserOperationResponse::__sizedcu_USCORElist)
			a->_ns1__updateRuntimeForUserOperationResponse::dcu_USCORElist = (ns1__DCU_USCOREINFO_USCOREType **)soap_save_block(soap, soap_blist_dcu_USCORElist1, NULL, 1);
		else
		{	a->_ns1__updateRuntimeForUserOperationResponse::dcu_USCORElist = NULL;
			if (soap_blist_dcu_USCORElist1)
				soap_end_block(soap, soap_blist_dcu_USCORElist1);
		}
		if (a->_ns1__updateRuntimeForUserOperationResponse::eventlog_USCORElist)
			soap_pop_block(soap, soap_blist_eventlog_USCORElist1);
		if (a->_ns1__updateRuntimeForUserOperationResponse::__sizeeventlog_USCORElist)
			a->_ns1__updateRuntimeForUserOperationResponse::eventlog_USCORElist = (ns1__EVENT_USCORELOG_USCOREINFO_USCOREType **)soap_save_block(soap, soap_blist_eventlog_USCORElist1, NULL, 1);
		else
		{	a->_ns1__updateRuntimeForUserOperationResponse::eventlog_USCORElist = NULL;
			if (soap_blist_eventlog_USCORElist1)
				soap_end_block(soap, soap_blist_eventlog_USCORElist1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__updateRuntimeForUserOperationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__updateRuntimeForUserOperationResponse, 0, sizeof(_ns1__updateRuntimeForUserOperationResponse), 0, soap_copy__ns1__updateRuntimeForUserOperationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_message_USCOREresult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__updateRuntimeForUserOperationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__updateRuntimeForUserOperationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:updateRuntimeForUserOperationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__updateRuntimeForUserOperationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__updateRuntimeForUserOperationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__updateRuntimeForUserOperationResponse * SOAP_FMAC4 soap_get__ns1__updateRuntimeForUserOperationResponse(struct soap *soap, _ns1__updateRuntimeForUserOperationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__updateRuntimeForUserOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__updateRuntimeForUserOperationResponse * SOAP_FMAC2 soap_instantiate__ns1__updateRuntimeForUserOperationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__updateRuntimeForUserOperationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__updateRuntimeForUserOperationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__updateRuntimeForUserOperationResponse);
		if (size)
			*size = sizeof(_ns1__updateRuntimeForUserOperationResponse);
		((_ns1__updateRuntimeForUserOperationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__updateRuntimeForUserOperationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__updateRuntimeForUserOperationResponse);
		for (int i = 0; i < n; i++)
			((_ns1__updateRuntimeForUserOperationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__updateRuntimeForUserOperationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__updateRuntimeForUserOperationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__updateRuntimeForUserOperationResponse %p -> %p\n", q, p));
	*(_ns1__updateRuntimeForUserOperationResponse*)p = *(_ns1__updateRuntimeForUserOperationResponse*)q;
}

void _ns1__updateRuntimeForUserOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__updateRuntimeForUserOperation::current_USCORElogin_USCOREinfo = NULL;
	/* transient soap skipped */
}

void _ns1__updateRuntimeForUserOperation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, &this->_ns1__updateRuntimeForUserOperation::current_USCORElogin_USCOREinfo);
	/* transient soap skipped */
}

int _ns1__updateRuntimeForUserOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__updateRuntimeForUserOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__updateRuntimeForUserOperation(struct soap *soap, const char *tag, int id, const _ns1__updateRuntimeForUserOperation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__updateRuntimeForUserOperation), type))
		return soap->error;
	if (a->_ns1__updateRuntimeForUserOperation::current_USCORElogin_USCOREinfo)
	{	if (soap_out_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", -1, &a->_ns1__updateRuntimeForUserOperation::current_USCORElogin_USCOREinfo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "current_login_info"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__updateRuntimeForUserOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__updateRuntimeForUserOperation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__updateRuntimeForUserOperation * SOAP_FMAC4 soap_in__ns1__updateRuntimeForUserOperation(struct soap *soap, const char *tag, _ns1__updateRuntimeForUserOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__updateRuntimeForUserOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__updateRuntimeForUserOperation, sizeof(_ns1__updateRuntimeForUserOperation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__updateRuntimeForUserOperation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__updateRuntimeForUserOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_current_USCORElogin_USCOREinfo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_current_USCORElogin_USCOREinfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", &(a->_ns1__updateRuntimeForUserOperation::current_USCORElogin_USCOREinfo), "ns1:CURR_LOGIN_INFO_Type"))
				{	soap_flag_current_USCORElogin_USCOREinfo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__updateRuntimeForUserOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__updateRuntimeForUserOperation, 0, sizeof(_ns1__updateRuntimeForUserOperation), 0, soap_copy__ns1__updateRuntimeForUserOperation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_current_USCORElogin_USCOREinfo1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__updateRuntimeForUserOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__updateRuntimeForUserOperation);
	if (this->soap_out(soap, tag?tag:"ns1:updateRuntimeForUserOperation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__updateRuntimeForUserOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__updateRuntimeForUserOperation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__updateRuntimeForUserOperation * SOAP_FMAC4 soap_get__ns1__updateRuntimeForUserOperation(struct soap *soap, _ns1__updateRuntimeForUserOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__updateRuntimeForUserOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__updateRuntimeForUserOperation * SOAP_FMAC2 soap_instantiate__ns1__updateRuntimeForUserOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__updateRuntimeForUserOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__updateRuntimeForUserOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__updateRuntimeForUserOperation);
		if (size)
			*size = sizeof(_ns1__updateRuntimeForUserOperation);
		((_ns1__updateRuntimeForUserOperation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__updateRuntimeForUserOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__updateRuntimeForUserOperation);
		for (int i = 0; i < n; i++)
			((_ns1__updateRuntimeForUserOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__updateRuntimeForUserOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__updateRuntimeForUserOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__updateRuntimeForUserOperation %p -> %p\n", q, p));
	*(_ns1__updateRuntimeForUserOperation*)p = *(_ns1__updateRuntimeForUserOperation*)q;
}

void _ns1__getLcuListOperationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, &this->_ns1__getLcuListOperationResponse::message_USCOREresult);
	this->_ns1__getLcuListOperationResponse::__sizelcu_USCORElist = 0;
	this->_ns1__getLcuListOperationResponse::lcu_USCORElist = NULL;
	/* transient soap skipped */
}

void _ns1__getLcuListOperationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->_ns1__getLcuListOperationResponse::lcu_USCORElist)
	{	int i;
		for (i = 0; i < this->_ns1__getLcuListOperationResponse::__sizelcu_USCORElist; i++)
		{
			soap_serialize_PointerTons1__LCU_USCOREINFO_USCOREType(soap, this->_ns1__getLcuListOperationResponse::lcu_USCORElist + i);
		}
	}
	/* transient soap skipped */
}

int _ns1__getLcuListOperationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getLcuListOperationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getLcuListOperationResponse(struct soap *soap, const char *tag, int id, const _ns1__getLcuListOperationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getLcuListOperationResponse), type))
		return soap->error;
	if (soap_out_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", -1, &(a->_ns1__getLcuListOperationResponse::message_USCOREresult), ""))
		return soap->error;
	if (a->_ns1__getLcuListOperationResponse::lcu_USCORElist)
	{	int i;
		for (i = 0; i < a->_ns1__getLcuListOperationResponse::__sizelcu_USCORElist; i++)
			if (soap_out_PointerTons1__LCU_USCOREINFO_USCOREType(soap, "lcu_list", -1, a->_ns1__getLcuListOperationResponse::lcu_USCORElist + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getLcuListOperationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getLcuListOperationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getLcuListOperationResponse * SOAP_FMAC4 soap_in__ns1__getLcuListOperationResponse(struct soap *soap, const char *tag, _ns1__getLcuListOperationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getLcuListOperationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getLcuListOperationResponse, sizeof(_ns1__getLcuListOperationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getLcuListOperationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getLcuListOperationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message_USCOREresult1 = 1;
	struct soap_blist *soap_blist_lcu_USCORElist1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message_USCOREresult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", &(a->_ns1__getLcuListOperationResponse::message_USCOREresult), "ns1:MESSAGE_RESULT_Enum"))
				{	soap_flag_message_USCOREresult1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "lcu_list", 1, NULL))
			{	if (a->_ns1__getLcuListOperationResponse::lcu_USCORElist == NULL)
				{	if (soap_blist_lcu_USCORElist1 == NULL)
						soap_blist_lcu_USCORElist1 = soap_new_block(soap);
					a->_ns1__getLcuListOperationResponse::lcu_USCORElist = (ns1__LCU_USCOREINFO_USCOREType **)soap_push_block(soap, soap_blist_lcu_USCORElist1, sizeof(ns1__LCU_USCOREINFO_USCOREType *));
					if (a->_ns1__getLcuListOperationResponse::lcu_USCORElist == NULL)
						return NULL;
					*a->_ns1__getLcuListOperationResponse::lcu_USCORElist = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__LCU_USCOREINFO_USCOREType(soap, "lcu_list", a->_ns1__getLcuListOperationResponse::lcu_USCORElist, "ns1:LCU_INFO_Type"))
				{	a->_ns1__getLcuListOperationResponse::__sizelcu_USCORElist++;
					a->_ns1__getLcuListOperationResponse::lcu_USCORElist = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_ns1__getLcuListOperationResponse::lcu_USCORElist)
			soap_pop_block(soap, soap_blist_lcu_USCORElist1);
		if (a->_ns1__getLcuListOperationResponse::__sizelcu_USCORElist)
			a->_ns1__getLcuListOperationResponse::lcu_USCORElist = (ns1__LCU_USCOREINFO_USCOREType **)soap_save_block(soap, soap_blist_lcu_USCORElist1, NULL, 1);
		else
		{	a->_ns1__getLcuListOperationResponse::lcu_USCORElist = NULL;
			if (soap_blist_lcu_USCORElist1)
				soap_end_block(soap, soap_blist_lcu_USCORElist1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getLcuListOperationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getLcuListOperationResponse, 0, sizeof(_ns1__getLcuListOperationResponse), 0, soap_copy__ns1__getLcuListOperationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_message_USCOREresult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getLcuListOperationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getLcuListOperationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getLcuListOperationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getLcuListOperationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getLcuListOperationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getLcuListOperationResponse * SOAP_FMAC4 soap_get__ns1__getLcuListOperationResponse(struct soap *soap, _ns1__getLcuListOperationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getLcuListOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getLcuListOperationResponse * SOAP_FMAC2 soap_instantiate__ns1__getLcuListOperationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getLcuListOperationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getLcuListOperationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getLcuListOperationResponse);
		if (size)
			*size = sizeof(_ns1__getLcuListOperationResponse);
		((_ns1__getLcuListOperationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getLcuListOperationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getLcuListOperationResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getLcuListOperationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getLcuListOperationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getLcuListOperationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getLcuListOperationResponse %p -> %p\n", q, p));
	*(_ns1__getLcuListOperationResponse*)p = *(_ns1__getLcuListOperationResponse*)q;
}

void _ns1__getLcuListOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__getLcuListOperation::dcu_USCOREid);
	this->_ns1__getLcuListOperation::current_USCORElogin_USCOREinfo = NULL;
	/* transient soap skipped */
}

void _ns1__getLcuListOperation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__getLcuListOperation::dcu_USCOREid);
	soap_serialize_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, &this->_ns1__getLcuListOperation::current_USCORElogin_USCOREinfo);
	/* transient soap skipped */
}

int _ns1__getLcuListOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getLcuListOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getLcuListOperation(struct soap *soap, const char *tag, int id, const _ns1__getLcuListOperation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getLcuListOperation), type))
		return soap->error;
	if (a->_ns1__getLcuListOperation::dcu_USCOREid)
	{	if (soap_out_string(soap, "dcu_id", -1, &a->_ns1__getLcuListOperation::dcu_USCOREid, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "dcu_id"))
		return soap->error;
	if (a->_ns1__getLcuListOperation::current_USCORElogin_USCOREinfo)
	{	if (soap_out_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", -1, &a->_ns1__getLcuListOperation::current_USCORElogin_USCOREinfo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "current_login_info"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getLcuListOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getLcuListOperation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getLcuListOperation * SOAP_FMAC4 soap_in__ns1__getLcuListOperation(struct soap *soap, const char *tag, _ns1__getLcuListOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getLcuListOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getLcuListOperation, sizeof(_ns1__getLcuListOperation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getLcuListOperation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getLcuListOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_dcu_USCOREid1 = 1;
	size_t soap_flag_current_USCORElogin_USCOREinfo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dcu_USCOREid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "dcu_id", &(a->_ns1__getLcuListOperation::dcu_USCOREid), "xsd:string"))
				{	soap_flag_dcu_USCOREid1--;
					continue;
				}
			if (soap_flag_current_USCORElogin_USCOREinfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", &(a->_ns1__getLcuListOperation::current_USCORElogin_USCOREinfo), "ns1:CURR_LOGIN_INFO_Type"))
				{	soap_flag_current_USCORElogin_USCOREinfo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getLcuListOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getLcuListOperation, 0, sizeof(_ns1__getLcuListOperation), 0, soap_copy__ns1__getLcuListOperation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_dcu_USCOREid1 > 0 || soap_flag_current_USCORElogin_USCOREinfo1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getLcuListOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getLcuListOperation);
	if (this->soap_out(soap, tag?tag:"ns1:getLcuListOperation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getLcuListOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getLcuListOperation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getLcuListOperation * SOAP_FMAC4 soap_get__ns1__getLcuListOperation(struct soap *soap, _ns1__getLcuListOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getLcuListOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getLcuListOperation * SOAP_FMAC2 soap_instantiate__ns1__getLcuListOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getLcuListOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getLcuListOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getLcuListOperation);
		if (size)
			*size = sizeof(_ns1__getLcuListOperation);
		((_ns1__getLcuListOperation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getLcuListOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getLcuListOperation);
		for (int i = 0; i < n; i++)
			((_ns1__getLcuListOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getLcuListOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getLcuListOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getLcuListOperation %p -> %p\n", q, p));
	*(_ns1__getLcuListOperation*)p = *(_ns1__getLcuListOperation*)q;
}

void _ns1__getDcuListOperationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, &this->_ns1__getDcuListOperationResponse::message_USCOREresult);
	this->_ns1__getDcuListOperationResponse::__sizedcu_USCORElist = 0;
	this->_ns1__getDcuListOperationResponse::dcu_USCORElist = NULL;
	/* transient soap skipped */
}

void _ns1__getDcuListOperationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->_ns1__getDcuListOperationResponse::dcu_USCORElist)
	{	int i;
		for (i = 0; i < this->_ns1__getDcuListOperationResponse::__sizedcu_USCORElist; i++)
		{
			soap_serialize_PointerTons1__DCU_USCOREINFO_USCOREType(soap, this->_ns1__getDcuListOperationResponse::dcu_USCORElist + i);
		}
	}
	/* transient soap skipped */
}

int _ns1__getDcuListOperationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getDcuListOperationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getDcuListOperationResponse(struct soap *soap, const char *tag, int id, const _ns1__getDcuListOperationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getDcuListOperationResponse), type))
		return soap->error;
	if (soap_out_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", -1, &(a->_ns1__getDcuListOperationResponse::message_USCOREresult), ""))
		return soap->error;
	if (a->_ns1__getDcuListOperationResponse::dcu_USCORElist)
	{	int i;
		for (i = 0; i < a->_ns1__getDcuListOperationResponse::__sizedcu_USCORElist; i++)
			if (soap_out_PointerTons1__DCU_USCOREINFO_USCOREType(soap, "dcu_list", -1, a->_ns1__getDcuListOperationResponse::dcu_USCORElist + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getDcuListOperationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getDcuListOperationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getDcuListOperationResponse * SOAP_FMAC4 soap_in__ns1__getDcuListOperationResponse(struct soap *soap, const char *tag, _ns1__getDcuListOperationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getDcuListOperationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getDcuListOperationResponse, sizeof(_ns1__getDcuListOperationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getDcuListOperationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getDcuListOperationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message_USCOREresult1 = 1;
	struct soap_blist *soap_blist_dcu_USCORElist1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message_USCOREresult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", &(a->_ns1__getDcuListOperationResponse::message_USCOREresult), "ns1:MESSAGE_RESULT_Enum"))
				{	soap_flag_message_USCOREresult1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "dcu_list", 1, NULL))
			{	if (a->_ns1__getDcuListOperationResponse::dcu_USCORElist == NULL)
				{	if (soap_blist_dcu_USCORElist1 == NULL)
						soap_blist_dcu_USCORElist1 = soap_new_block(soap);
					a->_ns1__getDcuListOperationResponse::dcu_USCORElist = (ns1__DCU_USCOREINFO_USCOREType **)soap_push_block(soap, soap_blist_dcu_USCORElist1, sizeof(ns1__DCU_USCOREINFO_USCOREType *));
					if (a->_ns1__getDcuListOperationResponse::dcu_USCORElist == NULL)
						return NULL;
					*a->_ns1__getDcuListOperationResponse::dcu_USCORElist = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__DCU_USCOREINFO_USCOREType(soap, "dcu_list", a->_ns1__getDcuListOperationResponse::dcu_USCORElist, "ns1:DCU_INFO_Type"))
				{	a->_ns1__getDcuListOperationResponse::__sizedcu_USCORElist++;
					a->_ns1__getDcuListOperationResponse::dcu_USCORElist = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_ns1__getDcuListOperationResponse::dcu_USCORElist)
			soap_pop_block(soap, soap_blist_dcu_USCORElist1);
		if (a->_ns1__getDcuListOperationResponse::__sizedcu_USCORElist)
			a->_ns1__getDcuListOperationResponse::dcu_USCORElist = (ns1__DCU_USCOREINFO_USCOREType **)soap_save_block(soap, soap_blist_dcu_USCORElist1, NULL, 1);
		else
		{	a->_ns1__getDcuListOperationResponse::dcu_USCORElist = NULL;
			if (soap_blist_dcu_USCORElist1)
				soap_end_block(soap, soap_blist_dcu_USCORElist1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getDcuListOperationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getDcuListOperationResponse, 0, sizeof(_ns1__getDcuListOperationResponse), 0, soap_copy__ns1__getDcuListOperationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_message_USCOREresult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getDcuListOperationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getDcuListOperationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getDcuListOperationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getDcuListOperationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getDcuListOperationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getDcuListOperationResponse * SOAP_FMAC4 soap_get__ns1__getDcuListOperationResponse(struct soap *soap, _ns1__getDcuListOperationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getDcuListOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getDcuListOperationResponse * SOAP_FMAC2 soap_instantiate__ns1__getDcuListOperationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getDcuListOperationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getDcuListOperationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getDcuListOperationResponse);
		if (size)
			*size = sizeof(_ns1__getDcuListOperationResponse);
		((_ns1__getDcuListOperationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getDcuListOperationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getDcuListOperationResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getDcuListOperationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getDcuListOperationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getDcuListOperationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getDcuListOperationResponse %p -> %p\n", q, p));
	*(_ns1__getDcuListOperationResponse*)p = *(_ns1__getDcuListOperationResponse*)q;
}

void _ns1__getDcuListOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getDcuListOperation::current_USCORElogin_USCOREinfo = NULL;
	soap_default_int(soap, &this->_ns1__getDcuListOperation::zone_USCOREid);
	soap_default_int(soap, &this->_ns1__getDcuListOperation::program_USCOREid);
	/* transient soap skipped */
}

void _ns1__getDcuListOperation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, &this->_ns1__getDcuListOperation::current_USCORElogin_USCOREinfo);
	/* transient soap skipped */
}

int _ns1__getDcuListOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getDcuListOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getDcuListOperation(struct soap *soap, const char *tag, int id, const _ns1__getDcuListOperation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getDcuListOperation), type))
		return soap->error;
	if (a->_ns1__getDcuListOperation::current_USCORElogin_USCOREinfo)
	{	if (soap_out_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", -1, &a->_ns1__getDcuListOperation::current_USCORElogin_USCOREinfo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "current_login_info"))
		return soap->error;
	if (soap_out_int(soap, "zone_id", -1, &(a->_ns1__getDcuListOperation::zone_USCOREid), ""))
		return soap->error;
	if (soap_out_int(soap, "program_id", -1, &(a->_ns1__getDcuListOperation::program_USCOREid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getDcuListOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getDcuListOperation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getDcuListOperation * SOAP_FMAC4 soap_in__ns1__getDcuListOperation(struct soap *soap, const char *tag, _ns1__getDcuListOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getDcuListOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getDcuListOperation, sizeof(_ns1__getDcuListOperation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getDcuListOperation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getDcuListOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_current_USCORElogin_USCOREinfo1 = 1;
	size_t soap_flag_zone_USCOREid1 = 1;
	size_t soap_flag_program_USCOREid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_current_USCORElogin_USCOREinfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", &(a->_ns1__getDcuListOperation::current_USCORElogin_USCOREinfo), "ns1:CURR_LOGIN_INFO_Type"))
				{	soap_flag_current_USCORElogin_USCOREinfo1--;
					continue;
				}
			if (soap_flag_zone_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "zone_id", &(a->_ns1__getDcuListOperation::zone_USCOREid), "xsd:int"))
				{	soap_flag_zone_USCOREid1--;
					continue;
				}
			if (soap_flag_program_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "program_id", &(a->_ns1__getDcuListOperation::program_USCOREid), "xsd:int"))
				{	soap_flag_program_USCOREid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getDcuListOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getDcuListOperation, 0, sizeof(_ns1__getDcuListOperation), 0, soap_copy__ns1__getDcuListOperation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_current_USCORElogin_USCOREinfo1 > 0 || soap_flag_zone_USCOREid1 > 0 || soap_flag_program_USCOREid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getDcuListOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getDcuListOperation);
	if (this->soap_out(soap, tag?tag:"ns1:getDcuListOperation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getDcuListOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getDcuListOperation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getDcuListOperation * SOAP_FMAC4 soap_get__ns1__getDcuListOperation(struct soap *soap, _ns1__getDcuListOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getDcuListOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getDcuListOperation * SOAP_FMAC2 soap_instantiate__ns1__getDcuListOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getDcuListOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getDcuListOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getDcuListOperation);
		if (size)
			*size = sizeof(_ns1__getDcuListOperation);
		((_ns1__getDcuListOperation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getDcuListOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getDcuListOperation);
		for (int i = 0; i < n; i++)
			((_ns1__getDcuListOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getDcuListOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getDcuListOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getDcuListOperation %p -> %p\n", q, p));
	*(_ns1__getDcuListOperation*)p = *(_ns1__getDcuListOperation*)q;
}

void _ns1__LogoutOperationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, &this->_ns1__LogoutOperationResponse::message_USCOREresult);
	/* transient soap skipped */
}

void _ns1__LogoutOperationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__LogoutOperationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__LogoutOperationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__LogoutOperationResponse(struct soap *soap, const char *tag, int id, const _ns1__LogoutOperationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__LogoutOperationResponse), type))
		return soap->error;
	if (soap_out_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", -1, &(a->_ns1__LogoutOperationResponse::message_USCOREresult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__LogoutOperationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__LogoutOperationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__LogoutOperationResponse * SOAP_FMAC4 soap_in__ns1__LogoutOperationResponse(struct soap *soap, const char *tag, _ns1__LogoutOperationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__LogoutOperationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__LogoutOperationResponse, sizeof(_ns1__LogoutOperationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__LogoutOperationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__LogoutOperationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message_USCOREresult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message_USCOREresult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "message_result", &(a->_ns1__LogoutOperationResponse::message_USCOREresult), "ns1:MESSAGE_RESULT_Enum"))
				{	soap_flag_message_USCOREresult1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__LogoutOperationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__LogoutOperationResponse, 0, sizeof(_ns1__LogoutOperationResponse), 0, soap_copy__ns1__LogoutOperationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_message_USCOREresult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__LogoutOperationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__LogoutOperationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:LogoutOperationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__LogoutOperationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__LogoutOperationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__LogoutOperationResponse * SOAP_FMAC4 soap_get__ns1__LogoutOperationResponse(struct soap *soap, _ns1__LogoutOperationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__LogoutOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__LogoutOperationResponse * SOAP_FMAC2 soap_instantiate__ns1__LogoutOperationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__LogoutOperationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__LogoutOperationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__LogoutOperationResponse);
		if (size)
			*size = sizeof(_ns1__LogoutOperationResponse);
		((_ns1__LogoutOperationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__LogoutOperationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__LogoutOperationResponse);
		for (int i = 0; i < n; i++)
			((_ns1__LogoutOperationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__LogoutOperationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__LogoutOperationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__LogoutOperationResponse %p -> %p\n", q, p));
	*(_ns1__LogoutOperationResponse*)p = *(_ns1__LogoutOperationResponse*)q;
}

void _ns1__LogoutOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__LogoutOperation::current_USCORElogin_USCOREinfo = NULL;
	/* transient soap skipped */
}

void _ns1__LogoutOperation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, &this->_ns1__LogoutOperation::current_USCORElogin_USCOREinfo);
	/* transient soap skipped */
}

int _ns1__LogoutOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__LogoutOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__LogoutOperation(struct soap *soap, const char *tag, int id, const _ns1__LogoutOperation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__LogoutOperation), type))
		return soap->error;
	if (a->_ns1__LogoutOperation::current_USCORElogin_USCOREinfo)
	{	if (soap_out_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", -1, &a->_ns1__LogoutOperation::current_USCORElogin_USCOREinfo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "current_login_info"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__LogoutOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__LogoutOperation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__LogoutOperation * SOAP_FMAC4 soap_in__ns1__LogoutOperation(struct soap *soap, const char *tag, _ns1__LogoutOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__LogoutOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__LogoutOperation, sizeof(_ns1__LogoutOperation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__LogoutOperation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__LogoutOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_current_USCORElogin_USCOREinfo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_current_USCORElogin_USCOREinfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, "current_login_info", &(a->_ns1__LogoutOperation::current_USCORElogin_USCOREinfo), "ns1:CURR_LOGIN_INFO_Type"))
				{	soap_flag_current_USCORElogin_USCOREinfo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__LogoutOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__LogoutOperation, 0, sizeof(_ns1__LogoutOperation), 0, soap_copy__ns1__LogoutOperation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_current_USCORElogin_USCOREinfo1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__LogoutOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__LogoutOperation);
	if (this->soap_out(soap, tag?tag:"ns1:LogoutOperation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__LogoutOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__LogoutOperation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__LogoutOperation * SOAP_FMAC4 soap_get__ns1__LogoutOperation(struct soap *soap, _ns1__LogoutOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__LogoutOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__LogoutOperation * SOAP_FMAC2 soap_instantiate__ns1__LogoutOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__LogoutOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__LogoutOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__LogoutOperation);
		if (size)
			*size = sizeof(_ns1__LogoutOperation);
		((_ns1__LogoutOperation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__LogoutOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__LogoutOperation);
		for (int i = 0; i < n; i++)
			((_ns1__LogoutOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__LogoutOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__LogoutOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__LogoutOperation %p -> %p\n", q, p));
	*(_ns1__LogoutOperation*)p = *(_ns1__LogoutOperation*)q;
}

void _ns1__LoginPcOperationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, &this->_ns1__LoginPcOperationResponse::login_USCOREresult);
	soap_default_int(soap, &this->_ns1__LoginPcOperationResponse::session_USCOREID);
	soap_default_bool(soap, &this->_ns1__LoginPcOperationResponse::admin_USCOREprivilege);
	this->_ns1__LoginPcOperationResponse::user = NULL;
	/* transient soap skipped */
}

void _ns1__LoginPcOperationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__USER_USCOREINFO_USCOREType(soap, &this->_ns1__LoginPcOperationResponse::user);
	/* transient soap skipped */
}

int _ns1__LoginPcOperationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__LoginPcOperationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__LoginPcOperationResponse(struct soap *soap, const char *tag, int id, const _ns1__LoginPcOperationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__LoginPcOperationResponse), type))
		return soap->error;
	if (soap_out_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "login_result", -1, &(a->_ns1__LoginPcOperationResponse::login_USCOREresult), ""))
		return soap->error;
	if (soap_out_int(soap, "session_ID", -1, &(a->_ns1__LoginPcOperationResponse::session_USCOREID), ""))
		return soap->error;
	if (soap_out_bool(soap, "admin_privilege", -1, &(a->_ns1__LoginPcOperationResponse::admin_USCOREprivilege), ""))
		return soap->error;
	if (a->_ns1__LoginPcOperationResponse::user)
	{	if (soap_out_PointerTons1__USER_USCOREINFO_USCOREType(soap, "user", -1, &a->_ns1__LoginPcOperationResponse::user, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "user"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__LoginPcOperationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__LoginPcOperationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__LoginPcOperationResponse * SOAP_FMAC4 soap_in__ns1__LoginPcOperationResponse(struct soap *soap, const char *tag, _ns1__LoginPcOperationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__LoginPcOperationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__LoginPcOperationResponse, sizeof(_ns1__LoginPcOperationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__LoginPcOperationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__LoginPcOperationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_login_USCOREresult1 = 1;
	size_t soap_flag_session_USCOREID1 = 1;
	size_t soap_flag_admin_USCOREprivilege1 = 1;
	size_t soap_flag_user1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_login_USCOREresult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "login_result", &(a->_ns1__LoginPcOperationResponse::login_USCOREresult), "ns1:MESSAGE_RESULT_Enum"))
				{	soap_flag_login_USCOREresult1--;
					continue;
				}
			if (soap_flag_session_USCOREID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "session_ID", &(a->_ns1__LoginPcOperationResponse::session_USCOREID), "xsd:int"))
				{	soap_flag_session_USCOREID1--;
					continue;
				}
			if (soap_flag_admin_USCOREprivilege1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "admin_privilege", &(a->_ns1__LoginPcOperationResponse::admin_USCOREprivilege), "xsd:boolean"))
				{	soap_flag_admin_USCOREprivilege1--;
					continue;
				}
			if (soap_flag_user1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__USER_USCOREINFO_USCOREType(soap, "user", &(a->_ns1__LoginPcOperationResponse::user), "ns1:USER_INFO_Type"))
				{	soap_flag_user1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__LoginPcOperationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__LoginPcOperationResponse, 0, sizeof(_ns1__LoginPcOperationResponse), 0, soap_copy__ns1__LoginPcOperationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_login_USCOREresult1 > 0 || soap_flag_session_USCOREID1 > 0 || soap_flag_admin_USCOREprivilege1 > 0 || soap_flag_user1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__LoginPcOperationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__LoginPcOperationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:LoginPcOperationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__LoginPcOperationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__LoginPcOperationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__LoginPcOperationResponse * SOAP_FMAC4 soap_get__ns1__LoginPcOperationResponse(struct soap *soap, _ns1__LoginPcOperationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__LoginPcOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__LoginPcOperationResponse * SOAP_FMAC2 soap_instantiate__ns1__LoginPcOperationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__LoginPcOperationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__LoginPcOperationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__LoginPcOperationResponse);
		if (size)
			*size = sizeof(_ns1__LoginPcOperationResponse);
		((_ns1__LoginPcOperationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__LoginPcOperationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__LoginPcOperationResponse);
		for (int i = 0; i < n; i++)
			((_ns1__LoginPcOperationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__LoginPcOperationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__LoginPcOperationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__LoginPcOperationResponse %p -> %p\n", q, p));
	*(_ns1__LoginPcOperationResponse*)p = *(_ns1__LoginPcOperationResponse*)q;
}

void _ns1__LoginPcOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__LoginPcOperation::login_USCOREusername);
	soap_default_string(soap, &this->_ns1__LoginPcOperation::login_USCOREpassword);
	/* transient soap skipped */
}

void _ns1__LoginPcOperation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__LoginPcOperation::login_USCOREusername);
	soap_serialize_string(soap, &this->_ns1__LoginPcOperation::login_USCOREpassword);
	/* transient soap skipped */
}

int _ns1__LoginPcOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__LoginPcOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__LoginPcOperation(struct soap *soap, const char *tag, int id, const _ns1__LoginPcOperation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__LoginPcOperation), type))
		return soap->error;
	if (a->_ns1__LoginPcOperation::login_USCOREusername)
	{	if (soap_out_string(soap, "login_username", -1, &a->_ns1__LoginPcOperation::login_USCOREusername, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "login_username"))
		return soap->error;
	if (a->_ns1__LoginPcOperation::login_USCOREpassword)
	{	if (soap_out_string(soap, "login_password", -1, &a->_ns1__LoginPcOperation::login_USCOREpassword, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "login_password"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__LoginPcOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__LoginPcOperation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__LoginPcOperation * SOAP_FMAC4 soap_in__ns1__LoginPcOperation(struct soap *soap, const char *tag, _ns1__LoginPcOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__LoginPcOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__LoginPcOperation, sizeof(_ns1__LoginPcOperation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__LoginPcOperation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__LoginPcOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_login_USCOREusername1 = 1;
	size_t soap_flag_login_USCOREpassword1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_login_USCOREusername1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "login_username", &(a->_ns1__LoginPcOperation::login_USCOREusername), "xsd:string"))
				{	soap_flag_login_USCOREusername1--;
					continue;
				}
			if (soap_flag_login_USCOREpassword1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "login_password", &(a->_ns1__LoginPcOperation::login_USCOREpassword), "xsd:string"))
				{	soap_flag_login_USCOREpassword1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__LoginPcOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__LoginPcOperation, 0, sizeof(_ns1__LoginPcOperation), 0, soap_copy__ns1__LoginPcOperation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_login_USCOREusername1 > 0 || soap_flag_login_USCOREpassword1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__LoginPcOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__LoginPcOperation);
	if (this->soap_out(soap, tag?tag:"ns1:LoginPcOperation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__LoginPcOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__LoginPcOperation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__LoginPcOperation * SOAP_FMAC4 soap_get__ns1__LoginPcOperation(struct soap *soap, _ns1__LoginPcOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__LoginPcOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__LoginPcOperation * SOAP_FMAC2 soap_instantiate__ns1__LoginPcOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__LoginPcOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__LoginPcOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__LoginPcOperation);
		if (size)
			*size = sizeof(_ns1__LoginPcOperation);
		((_ns1__LoginPcOperation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__LoginPcOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__LoginPcOperation);
		for (int i = 0; i < n; i++)
			((_ns1__LoginPcOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__LoginPcOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__LoginPcOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__LoginPcOperation %p -> %p\n", q, p));
	*(_ns1__LoginPcOperation*)p = *(_ns1__LoginPcOperation*)q;
}

void _ns1__LoginOperationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, &this->_ns1__LoginOperationResponse::login_USCOREresult);
	soap_default_int(soap, &this->_ns1__LoginOperationResponse::session_USCOREID);
	soap_default_string(soap, &this->_ns1__LoginOperationResponse::phone);
	soap_default_string(soap, &this->_ns1__LoginOperationResponse::email);
	/* transient soap skipped */
}

void _ns1__LoginOperationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__LoginOperationResponse::phone);
	soap_serialize_string(soap, &this->_ns1__LoginOperationResponse::email);
	/* transient soap skipped */
}

int _ns1__LoginOperationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__LoginOperationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__LoginOperationResponse(struct soap *soap, const char *tag, int id, const _ns1__LoginOperationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__LoginOperationResponse), type))
		return soap->error;
	if (soap_out_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "login_result", -1, &(a->_ns1__LoginOperationResponse::login_USCOREresult), ""))
		return soap->error;
	if (soap_out_int(soap, "session_ID", -1, &(a->_ns1__LoginOperationResponse::session_USCOREID), ""))
		return soap->error;
	if (a->_ns1__LoginOperationResponse::phone)
	{	if (soap_out_string(soap, "phone", -1, &a->_ns1__LoginOperationResponse::phone, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "phone"))
		return soap->error;
	if (a->_ns1__LoginOperationResponse::email)
	{	if (soap_out_string(soap, "email", -1, &a->_ns1__LoginOperationResponse::email, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "email"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__LoginOperationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__LoginOperationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__LoginOperationResponse * SOAP_FMAC4 soap_in__ns1__LoginOperationResponse(struct soap *soap, const char *tag, _ns1__LoginOperationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__LoginOperationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__LoginOperationResponse, sizeof(_ns1__LoginOperationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__LoginOperationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__LoginOperationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_login_USCOREresult1 = 1;
	size_t soap_flag_session_USCOREID1 = 1;
	size_t soap_flag_phone1 = 1;
	size_t soap_flag_email1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_login_USCOREresult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MESSAGE_USCORERESULT_USCOREEnum(soap, "login_result", &(a->_ns1__LoginOperationResponse::login_USCOREresult), "ns1:MESSAGE_RESULT_Enum"))
				{	soap_flag_login_USCOREresult1--;
					continue;
				}
			if (soap_flag_session_USCOREID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "session_ID", &(a->_ns1__LoginOperationResponse::session_USCOREID), "xsd:int"))
				{	soap_flag_session_USCOREID1--;
					continue;
				}
			if (soap_flag_phone1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "phone", &(a->_ns1__LoginOperationResponse::phone), "xsd:string"))
				{	soap_flag_phone1--;
					continue;
				}
			if (soap_flag_email1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "email", &(a->_ns1__LoginOperationResponse::email), "xsd:string"))
				{	soap_flag_email1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__LoginOperationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__LoginOperationResponse, 0, sizeof(_ns1__LoginOperationResponse), 0, soap_copy__ns1__LoginOperationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_login_USCOREresult1 > 0 || soap_flag_session_USCOREID1 > 0 || soap_flag_phone1 > 0 || soap_flag_email1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__LoginOperationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__LoginOperationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:LoginOperationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__LoginOperationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__LoginOperationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__LoginOperationResponse * SOAP_FMAC4 soap_get__ns1__LoginOperationResponse(struct soap *soap, _ns1__LoginOperationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__LoginOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__LoginOperationResponse * SOAP_FMAC2 soap_instantiate__ns1__LoginOperationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__LoginOperationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__LoginOperationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__LoginOperationResponse);
		if (size)
			*size = sizeof(_ns1__LoginOperationResponse);
		((_ns1__LoginOperationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__LoginOperationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__LoginOperationResponse);
		for (int i = 0; i < n; i++)
			((_ns1__LoginOperationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__LoginOperationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__LoginOperationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__LoginOperationResponse %p -> %p\n", q, p));
	*(_ns1__LoginOperationResponse*)p = *(_ns1__LoginOperationResponse*)q;
}

void _ns1__LoginOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__LoginOperation::login_USCOREusername);
	soap_default_string(soap, &this->_ns1__LoginOperation::login_USCOREpassword);
	/* transient soap skipped */
}

void _ns1__LoginOperation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__LoginOperation::login_USCOREusername);
	soap_serialize_string(soap, &this->_ns1__LoginOperation::login_USCOREpassword);
	/* transient soap skipped */
}

int _ns1__LoginOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__LoginOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__LoginOperation(struct soap *soap, const char *tag, int id, const _ns1__LoginOperation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__LoginOperation), type))
		return soap->error;
	if (a->_ns1__LoginOperation::login_USCOREusername)
	{	if (soap_out_string(soap, "login_username", -1, &a->_ns1__LoginOperation::login_USCOREusername, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "login_username"))
		return soap->error;
	if (a->_ns1__LoginOperation::login_USCOREpassword)
	{	if (soap_out_string(soap, "login_password", -1, &a->_ns1__LoginOperation::login_USCOREpassword, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "login_password"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__LoginOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__LoginOperation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__LoginOperation * SOAP_FMAC4 soap_in__ns1__LoginOperation(struct soap *soap, const char *tag, _ns1__LoginOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__LoginOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__LoginOperation, sizeof(_ns1__LoginOperation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__LoginOperation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__LoginOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_login_USCOREusername1 = 1;
	size_t soap_flag_login_USCOREpassword1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_login_USCOREusername1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "login_username", &(a->_ns1__LoginOperation::login_USCOREusername), "xsd:string"))
				{	soap_flag_login_USCOREusername1--;
					continue;
				}
			if (soap_flag_login_USCOREpassword1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "login_password", &(a->_ns1__LoginOperation::login_USCOREpassword), "xsd:string"))
				{	soap_flag_login_USCOREpassword1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__LoginOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__LoginOperation, 0, sizeof(_ns1__LoginOperation), 0, soap_copy__ns1__LoginOperation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_login_USCOREusername1 > 0 || soap_flag_login_USCOREpassword1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__LoginOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__LoginOperation);
	if (this->soap_out(soap, tag?tag:"ns1:LoginOperation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__LoginOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__LoginOperation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__LoginOperation * SOAP_FMAC4 soap_get__ns1__LoginOperation(struct soap *soap, _ns1__LoginOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__LoginOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__LoginOperation * SOAP_FMAC2 soap_instantiate__ns1__LoginOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__LoginOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__LoginOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__LoginOperation);
		if (size)
			*size = sizeof(_ns1__LoginOperation);
		((_ns1__LoginOperation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__LoginOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__LoginOperation);
		for (int i = 0; i < n; i++)
			((_ns1__LoginOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__LoginOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__LoginOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__LoginOperation %p -> %p\n", q, p));
	*(_ns1__LoginOperation*)p = *(_ns1__LoginOperation*)q;
}

void ns1__SCHEDULE_USCOREINFO_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__SCHEDULE_USCOREINFO_USCOREType::scheduleId);
	soap_default_int(soap, &this->ns1__SCHEDULE_USCOREINFO_USCOREType::scheduleListscheduleId);
	soap_default_int(soap, &this->ns1__SCHEDULE_USCOREINFO_USCOREType::scheduleStarttime);
	soap_default_int(soap, &this->ns1__SCHEDULE_USCOREINFO_USCOREType::scheduleOntime);
	soap_default_int(soap, &this->ns1__SCHEDULE_USCOREINFO_USCOREType::scheduleLevel);
	/* transient soap skipped */
}

void ns1__SCHEDULE_USCOREINFO_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__SCHEDULE_USCOREINFO_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SCHEDULE_USCOREINFO_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SCHEDULE_USCOREINFO_USCOREType(struct soap *soap, const char *tag, int id, const ns1__SCHEDULE_USCOREINFO_USCOREType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SCHEDULE_USCOREINFO_USCOREType), type))
		return soap->error;
	if (soap_out_int(soap, "scheduleId", -1, &(a->ns1__SCHEDULE_USCOREINFO_USCOREType::scheduleId), ""))
		return soap->error;
	if (soap_out_int(soap, "scheduleListscheduleId", -1, &(a->ns1__SCHEDULE_USCOREINFO_USCOREType::scheduleListscheduleId), ""))
		return soap->error;
	if (soap_out_int(soap, "scheduleStarttime", -1, &(a->ns1__SCHEDULE_USCOREINFO_USCOREType::scheduleStarttime), ""))
		return soap->error;
	if (soap_out_int(soap, "scheduleOntime", -1, &(a->ns1__SCHEDULE_USCOREINFO_USCOREType::scheduleOntime), ""))
		return soap->error;
	if (soap_out_int(soap, "scheduleLevel", -1, &(a->ns1__SCHEDULE_USCOREINFO_USCOREType::scheduleLevel), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__SCHEDULE_USCOREINFO_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SCHEDULE_USCOREINFO_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SCHEDULE_USCOREINFO_USCOREType * SOAP_FMAC4 soap_in_ns1__SCHEDULE_USCOREINFO_USCOREType(struct soap *soap, const char *tag, ns1__SCHEDULE_USCOREINFO_USCOREType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SCHEDULE_USCOREINFO_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SCHEDULE_USCOREINFO_USCOREType, sizeof(ns1__SCHEDULE_USCOREINFO_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__SCHEDULE_USCOREINFO_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__SCHEDULE_USCOREINFO_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_scheduleId1 = 1;
	size_t soap_flag_scheduleListscheduleId1 = 1;
	size_t soap_flag_scheduleStarttime1 = 1;
	size_t soap_flag_scheduleOntime1 = 1;
	size_t soap_flag_scheduleLevel1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_scheduleId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "scheduleId", &(a->ns1__SCHEDULE_USCOREINFO_USCOREType::scheduleId), "xsd:int"))
				{	soap_flag_scheduleId1--;
					continue;
				}
			if (soap_flag_scheduleListscheduleId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "scheduleListscheduleId", &(a->ns1__SCHEDULE_USCOREINFO_USCOREType::scheduleListscheduleId), "xsd:int"))
				{	soap_flag_scheduleListscheduleId1--;
					continue;
				}
			if (soap_flag_scheduleStarttime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "scheduleStarttime", &(a->ns1__SCHEDULE_USCOREINFO_USCOREType::scheduleStarttime), "xsd:int"))
				{	soap_flag_scheduleStarttime1--;
					continue;
				}
			if (soap_flag_scheduleOntime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "scheduleOntime", &(a->ns1__SCHEDULE_USCOREINFO_USCOREType::scheduleOntime), "xsd:int"))
				{	soap_flag_scheduleOntime1--;
					continue;
				}
			if (soap_flag_scheduleLevel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "scheduleLevel", &(a->ns1__SCHEDULE_USCOREINFO_USCOREType::scheduleLevel), "xsd:int"))
				{	soap_flag_scheduleLevel1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__SCHEDULE_USCOREINFO_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SCHEDULE_USCOREINFO_USCOREType, 0, sizeof(ns1__SCHEDULE_USCOREINFO_USCOREType), 0, soap_copy_ns1__SCHEDULE_USCOREINFO_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_scheduleId1 > 0 || soap_flag_scheduleListscheduleId1 > 0 || soap_flag_scheduleStarttime1 > 0 || soap_flag_scheduleOntime1 > 0 || soap_flag_scheduleLevel1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__SCHEDULE_USCOREINFO_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__SCHEDULE_USCOREINFO_USCOREType);
	if (this->soap_out(soap, tag?tag:"ns1:SCHEDULE_INFO_Type", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SCHEDULE_USCOREINFO_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SCHEDULE_USCOREINFO_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SCHEDULE_USCOREINFO_USCOREType * SOAP_FMAC4 soap_get_ns1__SCHEDULE_USCOREINFO_USCOREType(struct soap *soap, ns1__SCHEDULE_USCOREINFO_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SCHEDULE_USCOREINFO_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__SCHEDULE_USCOREINFO_USCOREType * SOAP_FMAC2 soap_instantiate_ns1__SCHEDULE_USCOREINFO_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SCHEDULE_USCOREINFO_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SCHEDULE_USCOREINFO_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__SCHEDULE_USCOREINFO_USCOREType);
		if (size)
			*size = sizeof(ns1__SCHEDULE_USCOREINFO_USCOREType);
		((ns1__SCHEDULE_USCOREINFO_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__SCHEDULE_USCOREINFO_USCOREType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__SCHEDULE_USCOREINFO_USCOREType);
		for (int i = 0; i < n; i++)
			((ns1__SCHEDULE_USCOREINFO_USCOREType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__SCHEDULE_USCOREINFO_USCOREType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SCHEDULE_USCOREINFO_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__SCHEDULE_USCOREINFO_USCOREType %p -> %p\n", q, p));
	*(ns1__SCHEDULE_USCOREINFO_USCOREType*)p = *(ns1__SCHEDULE_USCOREINFO_USCOREType*)q;
}

void ns1__LISTSCHEDULE_USCOREINFO_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__LISTSCHEDULE_USCOREINFO_USCOREType::listscheduleName);
	soap_default_int(soap, &this->ns1__LISTSCHEDULE_USCOREINFO_USCOREType::listscheduleId);
	soap_default_int(soap, &this->ns1__LISTSCHEDULE_USCOREINFO_USCOREType::listscheduleProgramId);
	this->ns1__LISTSCHEDULE_USCOREINFO_USCOREType::__sizesheduleList = 0;
	this->ns1__LISTSCHEDULE_USCOREINFO_USCOREType::sheduleList = NULL;
	/* transient soap skipped */
}

void ns1__LISTSCHEDULE_USCOREINFO_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__LISTSCHEDULE_USCOREINFO_USCOREType::listscheduleName);
	if (this->ns1__LISTSCHEDULE_USCOREINFO_USCOREType::sheduleList)
	{	int i;
		for (i = 0; i < this->ns1__LISTSCHEDULE_USCOREINFO_USCOREType::__sizesheduleList; i++)
		{
			soap_serialize_PointerTons1__SCHEDULE_USCOREINFO_USCOREType(soap, this->ns1__LISTSCHEDULE_USCOREINFO_USCOREType::sheduleList + i);
		}
	}
	/* transient soap skipped */
}

int ns1__LISTSCHEDULE_USCOREINFO_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__LISTSCHEDULE_USCOREINFO_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__LISTSCHEDULE_USCOREINFO_USCOREType(struct soap *soap, const char *tag, int id, const ns1__LISTSCHEDULE_USCOREINFO_USCOREType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__LISTSCHEDULE_USCOREINFO_USCOREType), type))
		return soap->error;
	if (a->ns1__LISTSCHEDULE_USCOREINFO_USCOREType::listscheduleName)
	{	if (soap_out_string(soap, "listscheduleName", -1, &a->ns1__LISTSCHEDULE_USCOREINFO_USCOREType::listscheduleName, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "listscheduleName"))
		return soap->error;
	if (soap_out_int(soap, "listscheduleId", -1, &(a->ns1__LISTSCHEDULE_USCOREINFO_USCOREType::listscheduleId), ""))
		return soap->error;
	if (soap_out_int(soap, "listscheduleProgramId", -1, &(a->ns1__LISTSCHEDULE_USCOREINFO_USCOREType::listscheduleProgramId), ""))
		return soap->error;
	if (a->ns1__LISTSCHEDULE_USCOREINFO_USCOREType::sheduleList)
	{	int i;
		for (i = 0; i < a->ns1__LISTSCHEDULE_USCOREINFO_USCOREType::__sizesheduleList; i++)
			if (soap_out_PointerTons1__SCHEDULE_USCOREINFO_USCOREType(soap, "sheduleList", -1, a->ns1__LISTSCHEDULE_USCOREINFO_USCOREType::sheduleList + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__LISTSCHEDULE_USCOREINFO_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__LISTSCHEDULE_USCOREINFO_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__LISTSCHEDULE_USCOREINFO_USCOREType * SOAP_FMAC4 soap_in_ns1__LISTSCHEDULE_USCOREINFO_USCOREType(struct soap *soap, const char *tag, ns1__LISTSCHEDULE_USCOREINFO_USCOREType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__LISTSCHEDULE_USCOREINFO_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__LISTSCHEDULE_USCOREINFO_USCOREType, sizeof(ns1__LISTSCHEDULE_USCOREINFO_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__LISTSCHEDULE_USCOREINFO_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__LISTSCHEDULE_USCOREINFO_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_listscheduleName1 = 1;
	size_t soap_flag_listscheduleId1 = 1;
	size_t soap_flag_listscheduleProgramId1 = 1;
	struct soap_blist *soap_blist_sheduleList1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_listscheduleName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "listscheduleName", &(a->ns1__LISTSCHEDULE_USCOREINFO_USCOREType::listscheduleName), "xsd:string"))
				{	soap_flag_listscheduleName1--;
					continue;
				}
			if (soap_flag_listscheduleId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "listscheduleId", &(a->ns1__LISTSCHEDULE_USCOREINFO_USCOREType::listscheduleId), "xsd:int"))
				{	soap_flag_listscheduleId1--;
					continue;
				}
			if (soap_flag_listscheduleProgramId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "listscheduleProgramId", &(a->ns1__LISTSCHEDULE_USCOREINFO_USCOREType::listscheduleProgramId), "xsd:int"))
				{	soap_flag_listscheduleProgramId1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "sheduleList", 1, NULL))
			{	if (a->ns1__LISTSCHEDULE_USCOREINFO_USCOREType::sheduleList == NULL)
				{	if (soap_blist_sheduleList1 == NULL)
						soap_blist_sheduleList1 = soap_new_block(soap);
					a->ns1__LISTSCHEDULE_USCOREINFO_USCOREType::sheduleList = (ns1__SCHEDULE_USCOREINFO_USCOREType **)soap_push_block(soap, soap_blist_sheduleList1, sizeof(ns1__SCHEDULE_USCOREINFO_USCOREType *));
					if (a->ns1__LISTSCHEDULE_USCOREINFO_USCOREType::sheduleList == NULL)
						return NULL;
					*a->ns1__LISTSCHEDULE_USCOREINFO_USCOREType::sheduleList = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__SCHEDULE_USCOREINFO_USCOREType(soap, "sheduleList", a->ns1__LISTSCHEDULE_USCOREINFO_USCOREType::sheduleList, "ns1:SCHEDULE_INFO_Type"))
				{	a->ns1__LISTSCHEDULE_USCOREINFO_USCOREType::__sizesheduleList++;
					a->ns1__LISTSCHEDULE_USCOREINFO_USCOREType::sheduleList = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__LISTSCHEDULE_USCOREINFO_USCOREType::sheduleList)
			soap_pop_block(soap, soap_blist_sheduleList1);
		if (a->ns1__LISTSCHEDULE_USCOREINFO_USCOREType::__sizesheduleList)
			a->ns1__LISTSCHEDULE_USCOREINFO_USCOREType::sheduleList = (ns1__SCHEDULE_USCOREINFO_USCOREType **)soap_save_block(soap, soap_blist_sheduleList1, NULL, 1);
		else
		{	a->ns1__LISTSCHEDULE_USCOREINFO_USCOREType::sheduleList = NULL;
			if (soap_blist_sheduleList1)
				soap_end_block(soap, soap_blist_sheduleList1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__LISTSCHEDULE_USCOREINFO_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__LISTSCHEDULE_USCOREINFO_USCOREType, 0, sizeof(ns1__LISTSCHEDULE_USCOREINFO_USCOREType), 0, soap_copy_ns1__LISTSCHEDULE_USCOREINFO_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_listscheduleName1 > 0 || soap_flag_listscheduleId1 > 0 || soap_flag_listscheduleProgramId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__LISTSCHEDULE_USCOREINFO_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__LISTSCHEDULE_USCOREINFO_USCOREType);
	if (this->soap_out(soap, tag?tag:"ns1:LISTSCHEDULE_INFO_Type", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__LISTSCHEDULE_USCOREINFO_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__LISTSCHEDULE_USCOREINFO_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__LISTSCHEDULE_USCOREINFO_USCOREType * SOAP_FMAC4 soap_get_ns1__LISTSCHEDULE_USCOREINFO_USCOREType(struct soap *soap, ns1__LISTSCHEDULE_USCOREINFO_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__LISTSCHEDULE_USCOREINFO_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__LISTSCHEDULE_USCOREINFO_USCOREType * SOAP_FMAC2 soap_instantiate_ns1__LISTSCHEDULE_USCOREINFO_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__LISTSCHEDULE_USCOREINFO_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__LISTSCHEDULE_USCOREINFO_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__LISTSCHEDULE_USCOREINFO_USCOREType);
		if (size)
			*size = sizeof(ns1__LISTSCHEDULE_USCOREINFO_USCOREType);
		((ns1__LISTSCHEDULE_USCOREINFO_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__LISTSCHEDULE_USCOREINFO_USCOREType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__LISTSCHEDULE_USCOREINFO_USCOREType);
		for (int i = 0; i < n; i++)
			((ns1__LISTSCHEDULE_USCOREINFO_USCOREType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__LISTSCHEDULE_USCOREINFO_USCOREType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__LISTSCHEDULE_USCOREINFO_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__LISTSCHEDULE_USCOREINFO_USCOREType %p -> %p\n", q, p));
	*(ns1__LISTSCHEDULE_USCOREINFO_USCOREType*)p = *(ns1__LISTSCHEDULE_USCOREINFO_USCOREType*)q;
}

void ns1__DAYSCHEDULE_USCOREINFO_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__DAYSCHEDULE_USCOREINFO_USCOREType::dayschedule_USCOREid);
	soap_default_int(soap, &this->ns1__DAYSCHEDULE_USCOREINFO_USCOREType::dayschedule_USCORElistScheduel_USCOREid);
	soap_default_int(soap, &this->ns1__DAYSCHEDULE_USCOREINFO_USCOREType::dayschedule_USCOREprogram_USCOREid);
	soap_default_int(soap, &this->ns1__DAYSCHEDULE_USCOREINFO_USCOREType::dayschedule_USCOREmonth);
	/* transient soap skipped */
}

void ns1__DAYSCHEDULE_USCOREINFO_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__DAYSCHEDULE_USCOREINFO_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__DAYSCHEDULE_USCOREINFO_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DAYSCHEDULE_USCOREINFO_USCOREType(struct soap *soap, const char *tag, int id, const ns1__DAYSCHEDULE_USCOREINFO_USCOREType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DAYSCHEDULE_USCOREINFO_USCOREType), type))
		return soap->error;
	if (soap_out_int(soap, "dayschedule_id", -1, &(a->ns1__DAYSCHEDULE_USCOREINFO_USCOREType::dayschedule_USCOREid), ""))
		return soap->error;
	if (soap_out_int(soap, "dayschedule_listScheduel_id", -1, &(a->ns1__DAYSCHEDULE_USCOREINFO_USCOREType::dayschedule_USCORElistScheduel_USCOREid), ""))
		return soap->error;
	if (soap_out_int(soap, "dayschedule_program_id", -1, &(a->ns1__DAYSCHEDULE_USCOREINFO_USCOREType::dayschedule_USCOREprogram_USCOREid), ""))
		return soap->error;
	if (soap_out_int(soap, "dayschedule_month", -1, &(a->ns1__DAYSCHEDULE_USCOREINFO_USCOREType::dayschedule_USCOREmonth), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__DAYSCHEDULE_USCOREINFO_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__DAYSCHEDULE_USCOREINFO_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__DAYSCHEDULE_USCOREINFO_USCOREType * SOAP_FMAC4 soap_in_ns1__DAYSCHEDULE_USCOREINFO_USCOREType(struct soap *soap, const char *tag, ns1__DAYSCHEDULE_USCOREINFO_USCOREType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__DAYSCHEDULE_USCOREINFO_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DAYSCHEDULE_USCOREINFO_USCOREType, sizeof(ns1__DAYSCHEDULE_USCOREINFO_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__DAYSCHEDULE_USCOREINFO_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__DAYSCHEDULE_USCOREINFO_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_dayschedule_USCOREid1 = 1;
	size_t soap_flag_dayschedule_USCORElistScheduel_USCOREid1 = 1;
	size_t soap_flag_dayschedule_USCOREprogram_USCOREid1 = 1;
	size_t soap_flag_dayschedule_USCOREmonth1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dayschedule_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "dayschedule_id", &(a->ns1__DAYSCHEDULE_USCOREINFO_USCOREType::dayschedule_USCOREid), "xsd:int"))
				{	soap_flag_dayschedule_USCOREid1--;
					continue;
				}
			if (soap_flag_dayschedule_USCORElistScheduel_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "dayschedule_listScheduel_id", &(a->ns1__DAYSCHEDULE_USCOREINFO_USCOREType::dayschedule_USCORElistScheduel_USCOREid), "xsd:int"))
				{	soap_flag_dayschedule_USCORElistScheduel_USCOREid1--;
					continue;
				}
			if (soap_flag_dayschedule_USCOREprogram_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "dayschedule_program_id", &(a->ns1__DAYSCHEDULE_USCOREINFO_USCOREType::dayschedule_USCOREprogram_USCOREid), "xsd:int"))
				{	soap_flag_dayschedule_USCOREprogram_USCOREid1--;
					continue;
				}
			if (soap_flag_dayschedule_USCOREmonth1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "dayschedule_month", &(a->ns1__DAYSCHEDULE_USCOREINFO_USCOREType::dayschedule_USCOREmonth), "xsd:int"))
				{	soap_flag_dayschedule_USCOREmonth1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__DAYSCHEDULE_USCOREINFO_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DAYSCHEDULE_USCOREINFO_USCOREType, 0, sizeof(ns1__DAYSCHEDULE_USCOREINFO_USCOREType), 0, soap_copy_ns1__DAYSCHEDULE_USCOREINFO_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_dayschedule_USCOREid1 > 0 || soap_flag_dayschedule_USCORElistScheduel_USCOREid1 > 0 || soap_flag_dayschedule_USCOREprogram_USCOREid1 > 0 || soap_flag_dayschedule_USCOREmonth1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__DAYSCHEDULE_USCOREINFO_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__DAYSCHEDULE_USCOREINFO_USCOREType);
	if (this->soap_out(soap, tag?tag:"ns1:DAYSCHEDULE_INFO_Type", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__DAYSCHEDULE_USCOREINFO_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__DAYSCHEDULE_USCOREINFO_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__DAYSCHEDULE_USCOREINFO_USCOREType * SOAP_FMAC4 soap_get_ns1__DAYSCHEDULE_USCOREINFO_USCOREType(struct soap *soap, ns1__DAYSCHEDULE_USCOREINFO_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DAYSCHEDULE_USCOREINFO_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__DAYSCHEDULE_USCOREINFO_USCOREType * SOAP_FMAC2 soap_instantiate_ns1__DAYSCHEDULE_USCOREINFO_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DAYSCHEDULE_USCOREINFO_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__DAYSCHEDULE_USCOREINFO_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__DAYSCHEDULE_USCOREINFO_USCOREType);
		if (size)
			*size = sizeof(ns1__DAYSCHEDULE_USCOREINFO_USCOREType);
		((ns1__DAYSCHEDULE_USCOREINFO_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__DAYSCHEDULE_USCOREINFO_USCOREType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__DAYSCHEDULE_USCOREINFO_USCOREType);
		for (int i = 0; i < n; i++)
			((ns1__DAYSCHEDULE_USCOREINFO_USCOREType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__DAYSCHEDULE_USCOREINFO_USCOREType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__DAYSCHEDULE_USCOREINFO_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__DAYSCHEDULE_USCOREINFO_USCOREType %p -> %p\n", q, p));
	*(ns1__DAYSCHEDULE_USCOREINFO_USCOREType*)p = *(ns1__DAYSCHEDULE_USCOREINFO_USCOREType*)q;
}

void ns1__PROGRAM_USCOREINFO_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__PROGRAM_USCOREINFO_USCOREType::program_USCOREname);
	soap_default_int(soap, &this->ns1__PROGRAM_USCOREINFO_USCOREType::program_USCOREid);
	soap_default_int(soap, &this->ns1__PROGRAM_USCOREINFO_USCOREType::zone_USCOREid);
	/* transient soap skipped */
}

void ns1__PROGRAM_USCOREINFO_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__PROGRAM_USCOREINFO_USCOREType::program_USCOREname);
	/* transient soap skipped */
}

int ns1__PROGRAM_USCOREINFO_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__PROGRAM_USCOREINFO_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PROGRAM_USCOREINFO_USCOREType(struct soap *soap, const char *tag, int id, const ns1__PROGRAM_USCOREINFO_USCOREType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PROGRAM_USCOREINFO_USCOREType), type))
		return soap->error;
	if (a->ns1__PROGRAM_USCOREINFO_USCOREType::program_USCOREname)
	{	if (soap_out_string(soap, "program_name", -1, &a->ns1__PROGRAM_USCOREINFO_USCOREType::program_USCOREname, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "program_name"))
		return soap->error;
	if (soap_out_int(soap, "program_id", -1, &(a->ns1__PROGRAM_USCOREINFO_USCOREType::program_USCOREid), ""))
		return soap->error;
	if (soap_out_int(soap, "zone_id", -1, &(a->ns1__PROGRAM_USCOREINFO_USCOREType::zone_USCOREid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__PROGRAM_USCOREINFO_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__PROGRAM_USCOREINFO_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__PROGRAM_USCOREINFO_USCOREType * SOAP_FMAC4 soap_in_ns1__PROGRAM_USCOREINFO_USCOREType(struct soap *soap, const char *tag, ns1__PROGRAM_USCOREINFO_USCOREType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__PROGRAM_USCOREINFO_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PROGRAM_USCOREINFO_USCOREType, sizeof(ns1__PROGRAM_USCOREINFO_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__PROGRAM_USCOREINFO_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__PROGRAM_USCOREINFO_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_program_USCOREname1 = 1;
	size_t soap_flag_program_USCOREid1 = 1;
	size_t soap_flag_zone_USCOREid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_program_USCOREname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "program_name", &(a->ns1__PROGRAM_USCOREINFO_USCOREType::program_USCOREname), "xsd:string"))
				{	soap_flag_program_USCOREname1--;
					continue;
				}
			if (soap_flag_program_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "program_id", &(a->ns1__PROGRAM_USCOREINFO_USCOREType::program_USCOREid), "xsd:int"))
				{	soap_flag_program_USCOREid1--;
					continue;
				}
			if (soap_flag_zone_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "zone_id", &(a->ns1__PROGRAM_USCOREINFO_USCOREType::zone_USCOREid), "xsd:int"))
				{	soap_flag_zone_USCOREid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__PROGRAM_USCOREINFO_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__PROGRAM_USCOREINFO_USCOREType, 0, sizeof(ns1__PROGRAM_USCOREINFO_USCOREType), 0, soap_copy_ns1__PROGRAM_USCOREINFO_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_program_USCOREname1 > 0 || soap_flag_program_USCOREid1 > 0 || soap_flag_zone_USCOREid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__PROGRAM_USCOREINFO_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__PROGRAM_USCOREINFO_USCOREType);
	if (this->soap_out(soap, tag?tag:"ns1:PROGRAM_INFO_Type", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__PROGRAM_USCOREINFO_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__PROGRAM_USCOREINFO_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__PROGRAM_USCOREINFO_USCOREType * SOAP_FMAC4 soap_get_ns1__PROGRAM_USCOREINFO_USCOREType(struct soap *soap, ns1__PROGRAM_USCOREINFO_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PROGRAM_USCOREINFO_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__PROGRAM_USCOREINFO_USCOREType * SOAP_FMAC2 soap_instantiate_ns1__PROGRAM_USCOREINFO_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__PROGRAM_USCOREINFO_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__PROGRAM_USCOREINFO_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__PROGRAM_USCOREINFO_USCOREType);
		if (size)
			*size = sizeof(ns1__PROGRAM_USCOREINFO_USCOREType);
		((ns1__PROGRAM_USCOREINFO_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__PROGRAM_USCOREINFO_USCOREType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__PROGRAM_USCOREINFO_USCOREType);
		for (int i = 0; i < n; i++)
			((ns1__PROGRAM_USCOREINFO_USCOREType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__PROGRAM_USCOREINFO_USCOREType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__PROGRAM_USCOREINFO_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__PROGRAM_USCOREINFO_USCOREType %p -> %p\n", q, p));
	*(ns1__PROGRAM_USCOREINFO_USCOREType*)p = *(ns1__PROGRAM_USCOREINFO_USCOREType*)q;
}

void ns1__USER_USCOREINFO_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__USER_USCOREINFO_USCOREType::user_USCOREid);
	soap_default_string(soap, &this->ns1__USER_USCOREINFO_USCOREType::user_USCOREaccount);
	soap_default_string(soap, &this->ns1__USER_USCOREINFO_USCOREType::user_USCOREpass);
	soap_default_string(soap, &this->ns1__USER_USCOREINFO_USCOREType::user_USCOREphone);
	soap_default_string(soap, &this->ns1__USER_USCOREINFO_USCOREType::user_USCOREemail);
	soap_default_bool(soap, &this->ns1__USER_USCOREINFO_USCOREType::user_USCOREmanage_USCOREdcu_USCOREprivilege);
	soap_default_bool(soap, &this->ns1__USER_USCOREINFO_USCOREType::user_USCOREmanage_USCORElculine_USCOREprivilege);
	soap_default_bool(soap, &this->ns1__USER_USCOREINFO_USCOREType::user_USCOREcontrol_USCORElculine_USCOREprivilege);
	soap_default_bool(soap, &this->ns1__USER_USCOREINFO_USCOREType::user_USCOREsetup_USCOREdevice_USCOREprivilege);
	soap_default_bool(soap, &this->ns1__USER_USCOREINFO_USCOREType::user_USCOREprogram_USCOREprivilege);
	soap_default_bool(soap, &this->ns1__USER_USCOREINFO_USCOREType::user_USCOREnotify_USCOREmail_USCOREprivilege);
	soap_default_bool(soap, &this->ns1__USER_USCOREINFO_USCOREType::user_USCOREnotify_USCOREsms_USCOREprivilege);
	soap_default_bool(soap, &this->ns1__USER_USCOREINFO_USCOREType::user_USCOREnotify_USCOREmail_USCOREenable);
	soap_default_bool(soap, &this->ns1__USER_USCOREINFO_USCOREType::user_USCOREnotify_USCOREsms_USCOREenable);
	this->ns1__USER_USCOREINFO_USCOREType::__sizezone_USCORElist = 0;
	this->ns1__USER_USCOREINFO_USCOREType::zone_USCORElist = NULL;
	/* transient soap skipped */
}

void ns1__USER_USCOREINFO_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__USER_USCOREINFO_USCOREType::user_USCOREaccount);
	soap_serialize_string(soap, &this->ns1__USER_USCOREINFO_USCOREType::user_USCOREpass);
	soap_serialize_string(soap, &this->ns1__USER_USCOREINFO_USCOREType::user_USCOREphone);
	soap_serialize_string(soap, &this->ns1__USER_USCOREINFO_USCOREType::user_USCOREemail);
	if (this->ns1__USER_USCOREINFO_USCOREType::zone_USCORElist)
	{	int i;
		for (i = 0; i < this->ns1__USER_USCOREINFO_USCOREType::__sizezone_USCORElist; i++)
		{
			soap_serialize_PointerTons1__ZONE_USCOREINFO_USCOREType(soap, this->ns1__USER_USCOREINFO_USCOREType::zone_USCORElist + i);
		}
	}
	/* transient soap skipped */
}

int ns1__USER_USCOREINFO_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__USER_USCOREINFO_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__USER_USCOREINFO_USCOREType(struct soap *soap, const char *tag, int id, const ns1__USER_USCOREINFO_USCOREType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__USER_USCOREINFO_USCOREType), type))
		return soap->error;
	if (soap_out_int(soap, "user_id", -1, &(a->ns1__USER_USCOREINFO_USCOREType::user_USCOREid), ""))
		return soap->error;
	if (a->ns1__USER_USCOREINFO_USCOREType::user_USCOREaccount)
	{	if (soap_out_string(soap, "user_account", -1, &a->ns1__USER_USCOREINFO_USCOREType::user_USCOREaccount, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "user_account"))
		return soap->error;
	if (a->ns1__USER_USCOREINFO_USCOREType::user_USCOREpass)
	{	if (soap_out_string(soap, "user_pass", -1, &a->ns1__USER_USCOREINFO_USCOREType::user_USCOREpass, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "user_pass"))
		return soap->error;
	if (a->ns1__USER_USCOREINFO_USCOREType::user_USCOREphone)
	{	if (soap_out_string(soap, "user_phone", -1, &a->ns1__USER_USCOREINFO_USCOREType::user_USCOREphone, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "user_phone"))
		return soap->error;
	if (a->ns1__USER_USCOREINFO_USCOREType::user_USCOREemail)
	{	if (soap_out_string(soap, "user_email", -1, &a->ns1__USER_USCOREINFO_USCOREType::user_USCOREemail, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "user_email"))
		return soap->error;
	if (soap_out_bool(soap, "user_manage_dcu_privilege", -1, &(a->ns1__USER_USCOREINFO_USCOREType::user_USCOREmanage_USCOREdcu_USCOREprivilege), ""))
		return soap->error;
	if (soap_out_bool(soap, "user_manage_lculine_privilege", -1, &(a->ns1__USER_USCOREINFO_USCOREType::user_USCOREmanage_USCORElculine_USCOREprivilege), ""))
		return soap->error;
	if (soap_out_bool(soap, "user_control_lculine_privilege", -1, &(a->ns1__USER_USCOREINFO_USCOREType::user_USCOREcontrol_USCORElculine_USCOREprivilege), ""))
		return soap->error;
	if (soap_out_bool(soap, "user_setup_device_privilege", -1, &(a->ns1__USER_USCOREINFO_USCOREType::user_USCOREsetup_USCOREdevice_USCOREprivilege), ""))
		return soap->error;
	if (soap_out_bool(soap, "user_program_privilege", -1, &(a->ns1__USER_USCOREINFO_USCOREType::user_USCOREprogram_USCOREprivilege), ""))
		return soap->error;
	if (soap_out_bool(soap, "user_notify_mail_privilege", -1, &(a->ns1__USER_USCOREINFO_USCOREType::user_USCOREnotify_USCOREmail_USCOREprivilege), ""))
		return soap->error;
	if (soap_out_bool(soap, "user_notify_sms_privilege", -1, &(a->ns1__USER_USCOREINFO_USCOREType::user_USCOREnotify_USCOREsms_USCOREprivilege), ""))
		return soap->error;
	if (soap_out_bool(soap, "user_notify_mail_enable", -1, &(a->ns1__USER_USCOREINFO_USCOREType::user_USCOREnotify_USCOREmail_USCOREenable), ""))
		return soap->error;
	if (soap_out_bool(soap, "user_notify_sms_enable", -1, &(a->ns1__USER_USCOREINFO_USCOREType::user_USCOREnotify_USCOREsms_USCOREenable), ""))
		return soap->error;
	if (a->ns1__USER_USCOREINFO_USCOREType::zone_USCORElist)
	{	int i;
		for (i = 0; i < a->ns1__USER_USCOREINFO_USCOREType::__sizezone_USCORElist; i++)
			if (soap_out_PointerTons1__ZONE_USCOREINFO_USCOREType(soap, "zone_list", -1, a->ns1__USER_USCOREINFO_USCOREType::zone_USCORElist + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__USER_USCOREINFO_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__USER_USCOREINFO_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__USER_USCOREINFO_USCOREType * SOAP_FMAC4 soap_in_ns1__USER_USCOREINFO_USCOREType(struct soap *soap, const char *tag, ns1__USER_USCOREINFO_USCOREType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__USER_USCOREINFO_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__USER_USCOREINFO_USCOREType, sizeof(ns1__USER_USCOREINFO_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__USER_USCOREINFO_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__USER_USCOREINFO_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_user_USCOREid1 = 1;
	size_t soap_flag_user_USCOREaccount1 = 1;
	size_t soap_flag_user_USCOREpass1 = 1;
	size_t soap_flag_user_USCOREphone1 = 1;
	size_t soap_flag_user_USCOREemail1 = 1;
	size_t soap_flag_user_USCOREmanage_USCOREdcu_USCOREprivilege1 = 1;
	size_t soap_flag_user_USCOREmanage_USCORElculine_USCOREprivilege1 = 1;
	size_t soap_flag_user_USCOREcontrol_USCORElculine_USCOREprivilege1 = 1;
	size_t soap_flag_user_USCOREsetup_USCOREdevice_USCOREprivilege1 = 1;
	size_t soap_flag_user_USCOREprogram_USCOREprivilege1 = 1;
	size_t soap_flag_user_USCOREnotify_USCOREmail_USCOREprivilege1 = 1;
	size_t soap_flag_user_USCOREnotify_USCOREsms_USCOREprivilege1 = 1;
	size_t soap_flag_user_USCOREnotify_USCOREmail_USCOREenable1 = 1;
	size_t soap_flag_user_USCOREnotify_USCOREsms_USCOREenable1 = 1;
	struct soap_blist *soap_blist_zone_USCORElist1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_user_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "user_id", &(a->ns1__USER_USCOREINFO_USCOREType::user_USCOREid), "xsd:int"))
				{	soap_flag_user_USCOREid1--;
					continue;
				}
			if (soap_flag_user_USCOREaccount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "user_account", &(a->ns1__USER_USCOREINFO_USCOREType::user_USCOREaccount), "xsd:string"))
				{	soap_flag_user_USCOREaccount1--;
					continue;
				}
			if (soap_flag_user_USCOREpass1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "user_pass", &(a->ns1__USER_USCOREINFO_USCOREType::user_USCOREpass), "xsd:string"))
				{	soap_flag_user_USCOREpass1--;
					continue;
				}
			if (soap_flag_user_USCOREphone1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "user_phone", &(a->ns1__USER_USCOREINFO_USCOREType::user_USCOREphone), "xsd:string"))
				{	soap_flag_user_USCOREphone1--;
					continue;
				}
			if (soap_flag_user_USCOREemail1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "user_email", &(a->ns1__USER_USCOREINFO_USCOREType::user_USCOREemail), "xsd:string"))
				{	soap_flag_user_USCOREemail1--;
					continue;
				}
			if (soap_flag_user_USCOREmanage_USCOREdcu_USCOREprivilege1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "user_manage_dcu_privilege", &(a->ns1__USER_USCOREINFO_USCOREType::user_USCOREmanage_USCOREdcu_USCOREprivilege), "xsd:boolean"))
				{	soap_flag_user_USCOREmanage_USCOREdcu_USCOREprivilege1--;
					continue;
				}
			if (soap_flag_user_USCOREmanage_USCORElculine_USCOREprivilege1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "user_manage_lculine_privilege", &(a->ns1__USER_USCOREINFO_USCOREType::user_USCOREmanage_USCORElculine_USCOREprivilege), "xsd:boolean"))
				{	soap_flag_user_USCOREmanage_USCORElculine_USCOREprivilege1--;
					continue;
				}
			if (soap_flag_user_USCOREcontrol_USCORElculine_USCOREprivilege1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "user_control_lculine_privilege", &(a->ns1__USER_USCOREINFO_USCOREType::user_USCOREcontrol_USCORElculine_USCOREprivilege), "xsd:boolean"))
				{	soap_flag_user_USCOREcontrol_USCORElculine_USCOREprivilege1--;
					continue;
				}
			if (soap_flag_user_USCOREsetup_USCOREdevice_USCOREprivilege1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "user_setup_device_privilege", &(a->ns1__USER_USCOREINFO_USCOREType::user_USCOREsetup_USCOREdevice_USCOREprivilege), "xsd:boolean"))
				{	soap_flag_user_USCOREsetup_USCOREdevice_USCOREprivilege1--;
					continue;
				}
			if (soap_flag_user_USCOREprogram_USCOREprivilege1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "user_program_privilege", &(a->ns1__USER_USCOREINFO_USCOREType::user_USCOREprogram_USCOREprivilege), "xsd:boolean"))
				{	soap_flag_user_USCOREprogram_USCOREprivilege1--;
					continue;
				}
			if (soap_flag_user_USCOREnotify_USCOREmail_USCOREprivilege1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "user_notify_mail_privilege", &(a->ns1__USER_USCOREINFO_USCOREType::user_USCOREnotify_USCOREmail_USCOREprivilege), "xsd:boolean"))
				{	soap_flag_user_USCOREnotify_USCOREmail_USCOREprivilege1--;
					continue;
				}
			if (soap_flag_user_USCOREnotify_USCOREsms_USCOREprivilege1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "user_notify_sms_privilege", &(a->ns1__USER_USCOREINFO_USCOREType::user_USCOREnotify_USCOREsms_USCOREprivilege), "xsd:boolean"))
				{	soap_flag_user_USCOREnotify_USCOREsms_USCOREprivilege1--;
					continue;
				}
			if (soap_flag_user_USCOREnotify_USCOREmail_USCOREenable1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "user_notify_mail_enable", &(a->ns1__USER_USCOREINFO_USCOREType::user_USCOREnotify_USCOREmail_USCOREenable), "xsd:boolean"))
				{	soap_flag_user_USCOREnotify_USCOREmail_USCOREenable1--;
					continue;
				}
			if (soap_flag_user_USCOREnotify_USCOREsms_USCOREenable1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "user_notify_sms_enable", &(a->ns1__USER_USCOREINFO_USCOREType::user_USCOREnotify_USCOREsms_USCOREenable), "xsd:boolean"))
				{	soap_flag_user_USCOREnotify_USCOREsms_USCOREenable1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "zone_list", 1, NULL))
			{	if (a->ns1__USER_USCOREINFO_USCOREType::zone_USCORElist == NULL)
				{	if (soap_blist_zone_USCORElist1 == NULL)
						soap_blist_zone_USCORElist1 = soap_new_block(soap);
					a->ns1__USER_USCOREINFO_USCOREType::zone_USCORElist = (ns1__ZONE_USCOREINFO_USCOREType **)soap_push_block(soap, soap_blist_zone_USCORElist1, sizeof(ns1__ZONE_USCOREINFO_USCOREType *));
					if (a->ns1__USER_USCOREINFO_USCOREType::zone_USCORElist == NULL)
						return NULL;
					*a->ns1__USER_USCOREINFO_USCOREType::zone_USCORElist = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__ZONE_USCOREINFO_USCOREType(soap, "zone_list", a->ns1__USER_USCOREINFO_USCOREType::zone_USCORElist, "ns1:ZONE_INFO_Type"))
				{	a->ns1__USER_USCOREINFO_USCOREType::__sizezone_USCORElist++;
					a->ns1__USER_USCOREINFO_USCOREType::zone_USCORElist = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__USER_USCOREINFO_USCOREType::zone_USCORElist)
			soap_pop_block(soap, soap_blist_zone_USCORElist1);
		if (a->ns1__USER_USCOREINFO_USCOREType::__sizezone_USCORElist)
			a->ns1__USER_USCOREINFO_USCOREType::zone_USCORElist = (ns1__ZONE_USCOREINFO_USCOREType **)soap_save_block(soap, soap_blist_zone_USCORElist1, NULL, 1);
		else
		{	a->ns1__USER_USCOREINFO_USCOREType::zone_USCORElist = NULL;
			if (soap_blist_zone_USCORElist1)
				soap_end_block(soap, soap_blist_zone_USCORElist1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__USER_USCOREINFO_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__USER_USCOREINFO_USCOREType, 0, sizeof(ns1__USER_USCOREINFO_USCOREType), 0, soap_copy_ns1__USER_USCOREINFO_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_user_USCOREid1 > 0 || soap_flag_user_USCOREaccount1 > 0 || soap_flag_user_USCOREpass1 > 0 || soap_flag_user_USCOREphone1 > 0 || soap_flag_user_USCOREemail1 > 0 || soap_flag_user_USCOREmanage_USCOREdcu_USCOREprivilege1 > 0 || soap_flag_user_USCOREmanage_USCORElculine_USCOREprivilege1 > 0 || soap_flag_user_USCOREcontrol_USCORElculine_USCOREprivilege1 > 0 || soap_flag_user_USCOREsetup_USCOREdevice_USCOREprivilege1 > 0 || soap_flag_user_USCOREprogram_USCOREprivilege1 > 0 || soap_flag_user_USCOREnotify_USCOREmail_USCOREprivilege1 > 0 || soap_flag_user_USCOREnotify_USCOREsms_USCOREprivilege1 > 0 || soap_flag_user_USCOREnotify_USCOREmail_USCOREenable1 > 0 || soap_flag_user_USCOREnotify_USCOREsms_USCOREenable1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__USER_USCOREINFO_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__USER_USCOREINFO_USCOREType);
	if (this->soap_out(soap, tag?tag:"ns1:USER_INFO_Type", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__USER_USCOREINFO_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__USER_USCOREINFO_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__USER_USCOREINFO_USCOREType * SOAP_FMAC4 soap_get_ns1__USER_USCOREINFO_USCOREType(struct soap *soap, ns1__USER_USCOREINFO_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__USER_USCOREINFO_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__USER_USCOREINFO_USCOREType * SOAP_FMAC2 soap_instantiate_ns1__USER_USCOREINFO_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__USER_USCOREINFO_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__USER_USCOREINFO_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__USER_USCOREINFO_USCOREType);
		if (size)
			*size = sizeof(ns1__USER_USCOREINFO_USCOREType);
		((ns1__USER_USCOREINFO_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__USER_USCOREINFO_USCOREType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__USER_USCOREINFO_USCOREType);
		for (int i = 0; i < n; i++)
			((ns1__USER_USCOREINFO_USCOREType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__USER_USCOREINFO_USCOREType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__USER_USCOREINFO_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__USER_USCOREINFO_USCOREType %p -> %p\n", q, p));
	*(ns1__USER_USCOREINFO_USCOREType*)p = *(ns1__USER_USCOREINFO_USCOREType*)q;
}

void ns1__ZONE_USCOREINFO_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__ZONE_USCOREINFO_USCOREType::zone_USCOREid);
	soap_default_string(soap, &this->ns1__ZONE_USCOREINFO_USCOREType::zone_USCOREnote);
	soap_default_string(soap, &this->ns1__ZONE_USCOREINFO_USCOREType::zone_USCOREname);
	/* transient soap skipped */
}

void ns1__ZONE_USCOREINFO_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__ZONE_USCOREINFO_USCOREType::zone_USCOREnote);
	soap_serialize_string(soap, &this->ns1__ZONE_USCOREINFO_USCOREType::zone_USCOREname);
	/* transient soap skipped */
}

int ns1__ZONE_USCOREINFO_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ZONE_USCOREINFO_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ZONE_USCOREINFO_USCOREType(struct soap *soap, const char *tag, int id, const ns1__ZONE_USCOREINFO_USCOREType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ZONE_USCOREINFO_USCOREType), type))
		return soap->error;
	if (soap_out_int(soap, "zone_id", -1, &(a->ns1__ZONE_USCOREINFO_USCOREType::zone_USCOREid), ""))
		return soap->error;
	if (a->ns1__ZONE_USCOREINFO_USCOREType::zone_USCOREnote)
	{	if (soap_out_string(soap, "zone_note", -1, &a->ns1__ZONE_USCOREINFO_USCOREType::zone_USCOREnote, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "zone_note"))
		return soap->error;
	if (a->ns1__ZONE_USCOREINFO_USCOREType::zone_USCOREname)
	{	if (soap_out_string(soap, "zone_name", -1, &a->ns1__ZONE_USCOREINFO_USCOREType::zone_USCOREname, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "zone_name"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ZONE_USCOREINFO_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ZONE_USCOREINFO_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ZONE_USCOREINFO_USCOREType * SOAP_FMAC4 soap_in_ns1__ZONE_USCOREINFO_USCOREType(struct soap *soap, const char *tag, ns1__ZONE_USCOREINFO_USCOREType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ZONE_USCOREINFO_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ZONE_USCOREINFO_USCOREType, sizeof(ns1__ZONE_USCOREINFO_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ZONE_USCOREINFO_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ZONE_USCOREINFO_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_zone_USCOREid1 = 1;
	size_t soap_flag_zone_USCOREnote1 = 1;
	size_t soap_flag_zone_USCOREname1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_zone_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "zone_id", &(a->ns1__ZONE_USCOREINFO_USCOREType::zone_USCOREid), "xsd:int"))
				{	soap_flag_zone_USCOREid1--;
					continue;
				}
			if (soap_flag_zone_USCOREnote1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "zone_note", &(a->ns1__ZONE_USCOREINFO_USCOREType::zone_USCOREnote), "xsd:string"))
				{	soap_flag_zone_USCOREnote1--;
					continue;
				}
			if (soap_flag_zone_USCOREname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "zone_name", &(a->ns1__ZONE_USCOREINFO_USCOREType::zone_USCOREname), "xsd:string"))
				{	soap_flag_zone_USCOREname1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ZONE_USCOREINFO_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ZONE_USCOREINFO_USCOREType, 0, sizeof(ns1__ZONE_USCOREINFO_USCOREType), 0, soap_copy_ns1__ZONE_USCOREINFO_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_zone_USCOREid1 > 0 || soap_flag_zone_USCOREnote1 > 0 || soap_flag_zone_USCOREname1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__ZONE_USCOREINFO_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ZONE_USCOREINFO_USCOREType);
	if (this->soap_out(soap, tag?tag:"ns1:ZONE_INFO_Type", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ZONE_USCOREINFO_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ZONE_USCOREINFO_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ZONE_USCOREINFO_USCOREType * SOAP_FMAC4 soap_get_ns1__ZONE_USCOREINFO_USCOREType(struct soap *soap, ns1__ZONE_USCOREINFO_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ZONE_USCOREINFO_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ZONE_USCOREINFO_USCOREType * SOAP_FMAC2 soap_instantiate_ns1__ZONE_USCOREINFO_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ZONE_USCOREINFO_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ZONE_USCOREINFO_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ZONE_USCOREINFO_USCOREType);
		if (size)
			*size = sizeof(ns1__ZONE_USCOREINFO_USCOREType);
		((ns1__ZONE_USCOREINFO_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ZONE_USCOREINFO_USCOREType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ZONE_USCOREINFO_USCOREType);
		for (int i = 0; i < n; i++)
			((ns1__ZONE_USCOREINFO_USCOREType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ZONE_USCOREINFO_USCOREType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ZONE_USCOREINFO_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ZONE_USCOREINFO_USCOREType %p -> %p\n", q, p));
	*(ns1__ZONE_USCOREINFO_USCOREType*)p = *(ns1__ZONE_USCOREINFO_USCOREType*)q;
}

void ns1__USER_USCORELOG_USCOREINFO_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__USER_USCORELOG_USCOREINFO_USCOREType::userlog_USCOREid);
	soap_default_string(soap, &this->ns1__USER_USCORELOG_USCOREINFO_USCOREType::userlog_USCOREusername);
	soap_default_string(soap, &this->ns1__USER_USCORELOG_USCOREINFO_USCOREType::eventlog_USCOREcontent);
	soap_default_string(soap, &this->ns1__USER_USCORELOG_USCOREINFO_USCOREType::eventlog_USCOREtime);
	/* transient soap skipped */
}

void ns1__USER_USCORELOG_USCOREINFO_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__USER_USCORELOG_USCOREINFO_USCOREType::userlog_USCOREusername);
	soap_serialize_string(soap, &this->ns1__USER_USCORELOG_USCOREINFO_USCOREType::eventlog_USCOREcontent);
	soap_serialize_string(soap, &this->ns1__USER_USCORELOG_USCOREINFO_USCOREType::eventlog_USCOREtime);
	/* transient soap skipped */
}

int ns1__USER_USCORELOG_USCOREINFO_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__USER_USCORELOG_USCOREINFO_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__USER_USCORELOG_USCOREINFO_USCOREType(struct soap *soap, const char *tag, int id, const ns1__USER_USCORELOG_USCOREINFO_USCOREType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__USER_USCORELOG_USCOREINFO_USCOREType), type))
		return soap->error;
	if (soap_out_int(soap, "userlog_id", -1, &(a->ns1__USER_USCORELOG_USCOREINFO_USCOREType::userlog_USCOREid), ""))
		return soap->error;
	if (a->ns1__USER_USCORELOG_USCOREINFO_USCOREType::userlog_USCOREusername)
	{	if (soap_out_string(soap, "userlog_username", -1, &a->ns1__USER_USCORELOG_USCOREINFO_USCOREType::userlog_USCOREusername, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "userlog_username"))
		return soap->error;
	if (a->ns1__USER_USCORELOG_USCOREINFO_USCOREType::eventlog_USCOREcontent)
	{	if (soap_out_string(soap, "eventlog_content", -1, &a->ns1__USER_USCORELOG_USCOREINFO_USCOREType::eventlog_USCOREcontent, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "eventlog_content"))
		return soap->error;
	if (a->ns1__USER_USCORELOG_USCOREINFO_USCOREType::eventlog_USCOREtime)
	{	if (soap_out_string(soap, "eventlog_time", -1, &a->ns1__USER_USCORELOG_USCOREINFO_USCOREType::eventlog_USCOREtime, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "eventlog_time"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__USER_USCORELOG_USCOREINFO_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__USER_USCORELOG_USCOREINFO_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__USER_USCORELOG_USCOREINFO_USCOREType * SOAP_FMAC4 soap_in_ns1__USER_USCORELOG_USCOREINFO_USCOREType(struct soap *soap, const char *tag, ns1__USER_USCORELOG_USCOREINFO_USCOREType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__USER_USCORELOG_USCOREINFO_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__USER_USCORELOG_USCOREINFO_USCOREType, sizeof(ns1__USER_USCORELOG_USCOREINFO_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__USER_USCORELOG_USCOREINFO_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__USER_USCORELOG_USCOREINFO_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_userlog_USCOREid1 = 1;
	size_t soap_flag_userlog_USCOREusername1 = 1;
	size_t soap_flag_eventlog_USCOREcontent1 = 1;
	size_t soap_flag_eventlog_USCOREtime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_userlog_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "userlog_id", &(a->ns1__USER_USCORELOG_USCOREINFO_USCOREType::userlog_USCOREid), "xsd:int"))
				{	soap_flag_userlog_USCOREid1--;
					continue;
				}
			if (soap_flag_userlog_USCOREusername1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userlog_username", &(a->ns1__USER_USCORELOG_USCOREINFO_USCOREType::userlog_USCOREusername), "xsd:string"))
				{	soap_flag_userlog_USCOREusername1--;
					continue;
				}
			if (soap_flag_eventlog_USCOREcontent1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "eventlog_content", &(a->ns1__USER_USCORELOG_USCOREINFO_USCOREType::eventlog_USCOREcontent), "xsd:string"))
				{	soap_flag_eventlog_USCOREcontent1--;
					continue;
				}
			if (soap_flag_eventlog_USCOREtime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "eventlog_time", &(a->ns1__USER_USCORELOG_USCOREINFO_USCOREType::eventlog_USCOREtime), "xsd:string"))
				{	soap_flag_eventlog_USCOREtime1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__USER_USCORELOG_USCOREINFO_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__USER_USCORELOG_USCOREINFO_USCOREType, 0, sizeof(ns1__USER_USCORELOG_USCOREINFO_USCOREType), 0, soap_copy_ns1__USER_USCORELOG_USCOREINFO_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_userlog_USCOREid1 > 0 || soap_flag_userlog_USCOREusername1 > 0 || soap_flag_eventlog_USCOREcontent1 > 0 || soap_flag_eventlog_USCOREtime1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__USER_USCORELOG_USCOREINFO_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__USER_USCORELOG_USCOREINFO_USCOREType);
	if (this->soap_out(soap, tag?tag:"ns1:USER_LOG_INFO_Type", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__USER_USCORELOG_USCOREINFO_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__USER_USCORELOG_USCOREINFO_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__USER_USCORELOG_USCOREINFO_USCOREType * SOAP_FMAC4 soap_get_ns1__USER_USCORELOG_USCOREINFO_USCOREType(struct soap *soap, ns1__USER_USCORELOG_USCOREINFO_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__USER_USCORELOG_USCOREINFO_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__USER_USCORELOG_USCOREINFO_USCOREType * SOAP_FMAC2 soap_instantiate_ns1__USER_USCORELOG_USCOREINFO_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__USER_USCORELOG_USCOREINFO_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__USER_USCORELOG_USCOREINFO_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__USER_USCORELOG_USCOREINFO_USCOREType);
		if (size)
			*size = sizeof(ns1__USER_USCORELOG_USCOREINFO_USCOREType);
		((ns1__USER_USCORELOG_USCOREINFO_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__USER_USCORELOG_USCOREINFO_USCOREType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__USER_USCORELOG_USCOREINFO_USCOREType);
		for (int i = 0; i < n; i++)
			((ns1__USER_USCORELOG_USCOREINFO_USCOREType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__USER_USCORELOG_USCOREINFO_USCOREType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__USER_USCORELOG_USCOREINFO_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__USER_USCORELOG_USCOREINFO_USCOREType %p -> %p\n", q, p));
	*(ns1__USER_USCORELOG_USCOREINFO_USCOREType*)p = *(ns1__USER_USCORELOG_USCOREINFO_USCOREType*)q;
}

void ns1__EVENT_USCORELOG_USCOREINFO_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__EVENT_USCORELOG_USCOREINFO_USCOREType::eventlog_USCOREid);
	soap_default_string(soap, &this->ns1__EVENT_USCORELOG_USCOREINFO_USCOREType::eventlog_USCOREdcuid);
	soap_default_ns1__EVENTLOG_USCORETYPE_USCOREEnum(soap, &this->ns1__EVENT_USCORELOG_USCOREINFO_USCOREType::eventlog_USCOREtype);
	soap_default_string(soap, &this->ns1__EVENT_USCORELOG_USCOREINFO_USCOREType::eventlog_USCOREcontent);
	soap_default_string(soap, &this->ns1__EVENT_USCORELOG_USCOREINFO_USCOREType::eventlog_USCOREtime);
	/* transient soap skipped */
}

void ns1__EVENT_USCORELOG_USCOREINFO_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__EVENT_USCORELOG_USCOREINFO_USCOREType::eventlog_USCOREdcuid);
	soap_serialize_string(soap, &this->ns1__EVENT_USCORELOG_USCOREINFO_USCOREType::eventlog_USCOREcontent);
	soap_serialize_string(soap, &this->ns1__EVENT_USCORELOG_USCOREINFO_USCOREType::eventlog_USCOREtime);
	/* transient soap skipped */
}

int ns1__EVENT_USCORELOG_USCOREINFO_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__EVENT_USCORELOG_USCOREINFO_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__EVENT_USCORELOG_USCOREINFO_USCOREType(struct soap *soap, const char *tag, int id, const ns1__EVENT_USCORELOG_USCOREINFO_USCOREType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__EVENT_USCORELOG_USCOREINFO_USCOREType), type))
		return soap->error;
	if (soap_out_int(soap, "eventlog_id", -1, &(a->ns1__EVENT_USCORELOG_USCOREINFO_USCOREType::eventlog_USCOREid), ""))
		return soap->error;
	if (a->ns1__EVENT_USCORELOG_USCOREINFO_USCOREType::eventlog_USCOREdcuid)
	{	if (soap_out_string(soap, "eventlog_dcuid", -1, &a->ns1__EVENT_USCORELOG_USCOREINFO_USCOREType::eventlog_USCOREdcuid, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "eventlog_dcuid"))
		return soap->error;
	if (soap_out_ns1__EVENTLOG_USCORETYPE_USCOREEnum(soap, "eventlog_type", -1, &(a->ns1__EVENT_USCORELOG_USCOREINFO_USCOREType::eventlog_USCOREtype), ""))
		return soap->error;
	if (a->ns1__EVENT_USCORELOG_USCOREINFO_USCOREType::eventlog_USCOREcontent)
	{	if (soap_out_string(soap, "eventlog_content", -1, &a->ns1__EVENT_USCORELOG_USCOREINFO_USCOREType::eventlog_USCOREcontent, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "eventlog_content"))
		return soap->error;
	if (a->ns1__EVENT_USCORELOG_USCOREINFO_USCOREType::eventlog_USCOREtime)
	{	if (soap_out_string(soap, "eventlog_time", -1, &a->ns1__EVENT_USCORELOG_USCOREINFO_USCOREType::eventlog_USCOREtime, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "eventlog_time"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__EVENT_USCORELOG_USCOREINFO_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__EVENT_USCORELOG_USCOREINFO_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__EVENT_USCORELOG_USCOREINFO_USCOREType * SOAP_FMAC4 soap_in_ns1__EVENT_USCORELOG_USCOREINFO_USCOREType(struct soap *soap, const char *tag, ns1__EVENT_USCORELOG_USCOREINFO_USCOREType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__EVENT_USCORELOG_USCOREINFO_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__EVENT_USCORELOG_USCOREINFO_USCOREType, sizeof(ns1__EVENT_USCORELOG_USCOREINFO_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__EVENT_USCORELOG_USCOREINFO_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__EVENT_USCORELOG_USCOREINFO_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_eventlog_USCOREid1 = 1;
	size_t soap_flag_eventlog_USCOREdcuid1 = 1;
	size_t soap_flag_eventlog_USCOREtype1 = 1;
	size_t soap_flag_eventlog_USCOREcontent1 = 1;
	size_t soap_flag_eventlog_USCOREtime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eventlog_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "eventlog_id", &(a->ns1__EVENT_USCORELOG_USCOREINFO_USCOREType::eventlog_USCOREid), "xsd:int"))
				{	soap_flag_eventlog_USCOREid1--;
					continue;
				}
			if (soap_flag_eventlog_USCOREdcuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "eventlog_dcuid", &(a->ns1__EVENT_USCORELOG_USCOREINFO_USCOREType::eventlog_USCOREdcuid), "xsd:string"))
				{	soap_flag_eventlog_USCOREdcuid1--;
					continue;
				}
			if (soap_flag_eventlog_USCOREtype1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__EVENTLOG_USCORETYPE_USCOREEnum(soap, "eventlog_type", &(a->ns1__EVENT_USCORELOG_USCOREINFO_USCOREType::eventlog_USCOREtype), "ns1:EVENTLOG_TYPE_Enum"))
				{	soap_flag_eventlog_USCOREtype1--;
					continue;
				}
			if (soap_flag_eventlog_USCOREcontent1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "eventlog_content", &(a->ns1__EVENT_USCORELOG_USCOREINFO_USCOREType::eventlog_USCOREcontent), "xsd:string"))
				{	soap_flag_eventlog_USCOREcontent1--;
					continue;
				}
			if (soap_flag_eventlog_USCOREtime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "eventlog_time", &(a->ns1__EVENT_USCORELOG_USCOREINFO_USCOREType::eventlog_USCOREtime), "xsd:string"))
				{	soap_flag_eventlog_USCOREtime1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__EVENT_USCORELOG_USCOREINFO_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__EVENT_USCORELOG_USCOREINFO_USCOREType, 0, sizeof(ns1__EVENT_USCORELOG_USCOREINFO_USCOREType), 0, soap_copy_ns1__EVENT_USCORELOG_USCOREINFO_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_eventlog_USCOREid1 > 0 || soap_flag_eventlog_USCOREdcuid1 > 0 || soap_flag_eventlog_USCOREtype1 > 0 || soap_flag_eventlog_USCOREcontent1 > 0 || soap_flag_eventlog_USCOREtime1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__EVENT_USCORELOG_USCOREINFO_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__EVENT_USCORELOG_USCOREINFO_USCOREType);
	if (this->soap_out(soap, tag?tag:"ns1:EVENT_LOG_INFO_Type", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__EVENT_USCORELOG_USCOREINFO_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__EVENT_USCORELOG_USCOREINFO_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__EVENT_USCORELOG_USCOREINFO_USCOREType * SOAP_FMAC4 soap_get_ns1__EVENT_USCORELOG_USCOREINFO_USCOREType(struct soap *soap, ns1__EVENT_USCORELOG_USCOREINFO_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__EVENT_USCORELOG_USCOREINFO_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__EVENT_USCORELOG_USCOREINFO_USCOREType * SOAP_FMAC2 soap_instantiate_ns1__EVENT_USCORELOG_USCOREINFO_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__EVENT_USCORELOG_USCOREINFO_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__EVENT_USCORELOG_USCOREINFO_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__EVENT_USCORELOG_USCOREINFO_USCOREType);
		if (size)
			*size = sizeof(ns1__EVENT_USCORELOG_USCOREINFO_USCOREType);
		((ns1__EVENT_USCORELOG_USCOREINFO_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__EVENT_USCORELOG_USCOREINFO_USCOREType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__EVENT_USCORELOG_USCOREINFO_USCOREType);
		for (int i = 0; i < n; i++)
			((ns1__EVENT_USCORELOG_USCOREINFO_USCOREType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__EVENT_USCORELOG_USCOREINFO_USCOREType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__EVENT_USCORELOG_USCOREINFO_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__EVENT_USCORELOG_USCOREINFO_USCOREType %p -> %p\n", q, p));
	*(ns1__EVENT_USCORELOG_USCOREINFO_USCOREType*)p = *(ns1__EVENT_USCORELOG_USCOREINFO_USCOREType*)q;
}

void ns1__LINE_USCOREINFO_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__LINE_USCOREINFO_USCOREType::line_USCOREid);
	soap_default_string(soap, &this->ns1__LINE_USCOREINFO_USCOREType::line_USCOREdcuid);
	soap_default_int(soap, &this->ns1__LINE_USCOREINFO_USCOREType::line_USCOREstatus);
	soap_default_string(soap, &this->ns1__LINE_USCOREINFO_USCOREType::line_USCOREnote);
	soap_default_int(soap, &this->ns1__LINE_USCOREINFO_USCOREType::line_USCOREmode);
	soap_default_int(soap, &this->ns1__LINE_USCOREINFO_USCOREType::line_USCOREison);
	soap_default_int(soap, &this->ns1__LINE_USCOREINFO_USCOREType::line_USCOREcurrent);
	/* transient soap skipped */
}

void ns1__LINE_USCOREINFO_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__LINE_USCOREINFO_USCOREType::line_USCOREdcuid);
	soap_serialize_string(soap, &this->ns1__LINE_USCOREINFO_USCOREType::line_USCOREnote);
	/* transient soap skipped */
}

int ns1__LINE_USCOREINFO_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__LINE_USCOREINFO_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__LINE_USCOREINFO_USCOREType(struct soap *soap, const char *tag, int id, const ns1__LINE_USCOREINFO_USCOREType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__LINE_USCOREINFO_USCOREType), type))
		return soap->error;
	if (soap_out_int(soap, "line_id", -1, &(a->ns1__LINE_USCOREINFO_USCOREType::line_USCOREid), ""))
		return soap->error;
	if (a->ns1__LINE_USCOREINFO_USCOREType::line_USCOREdcuid)
	{	if (soap_out_string(soap, "line_dcuid", -1, &a->ns1__LINE_USCOREINFO_USCOREType::line_USCOREdcuid, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "line_dcuid"))
		return soap->error;
	if (soap_out_int(soap, "line_status", -1, &(a->ns1__LINE_USCOREINFO_USCOREType::line_USCOREstatus), ""))
		return soap->error;
	if (a->ns1__LINE_USCOREINFO_USCOREType::line_USCOREnote)
	{	if (soap_out_string(soap, "line_note", -1, &a->ns1__LINE_USCOREINFO_USCOREType::line_USCOREnote, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "line_note"))
		return soap->error;
	if (soap_out_int(soap, "line_mode", -1, &(a->ns1__LINE_USCOREINFO_USCOREType::line_USCOREmode), ""))
		return soap->error;
	if (soap_out_int(soap, "line_ison", -1, &(a->ns1__LINE_USCOREINFO_USCOREType::line_USCOREison), ""))
		return soap->error;
	if (soap_out_int(soap, "line_current", -1, &(a->ns1__LINE_USCOREINFO_USCOREType::line_USCOREcurrent), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__LINE_USCOREINFO_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__LINE_USCOREINFO_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__LINE_USCOREINFO_USCOREType * SOAP_FMAC4 soap_in_ns1__LINE_USCOREINFO_USCOREType(struct soap *soap, const char *tag, ns1__LINE_USCOREINFO_USCOREType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__LINE_USCOREINFO_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__LINE_USCOREINFO_USCOREType, sizeof(ns1__LINE_USCOREINFO_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__LINE_USCOREINFO_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__LINE_USCOREINFO_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_line_USCOREid1 = 1;
	size_t soap_flag_line_USCOREdcuid1 = 1;
	size_t soap_flag_line_USCOREstatus1 = 1;
	size_t soap_flag_line_USCOREnote1 = 1;
	size_t soap_flag_line_USCOREmode1 = 1;
	size_t soap_flag_line_USCOREison1 = 1;
	size_t soap_flag_line_USCOREcurrent1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_line_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "line_id", &(a->ns1__LINE_USCOREINFO_USCOREType::line_USCOREid), "xsd:int"))
				{	soap_flag_line_USCOREid1--;
					continue;
				}
			if (soap_flag_line_USCOREdcuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "line_dcuid", &(a->ns1__LINE_USCOREINFO_USCOREType::line_USCOREdcuid), "xsd:string"))
				{	soap_flag_line_USCOREdcuid1--;
					continue;
				}
			if (soap_flag_line_USCOREstatus1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "line_status", &(a->ns1__LINE_USCOREINFO_USCOREType::line_USCOREstatus), "xsd:int"))
				{	soap_flag_line_USCOREstatus1--;
					continue;
				}
			if (soap_flag_line_USCOREnote1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "line_note", &(a->ns1__LINE_USCOREINFO_USCOREType::line_USCOREnote), "xsd:string"))
				{	soap_flag_line_USCOREnote1--;
					continue;
				}
			if (soap_flag_line_USCOREmode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "line_mode", &(a->ns1__LINE_USCOREINFO_USCOREType::line_USCOREmode), "xsd:int"))
				{	soap_flag_line_USCOREmode1--;
					continue;
				}
			if (soap_flag_line_USCOREison1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "line_ison", &(a->ns1__LINE_USCOREINFO_USCOREType::line_USCOREison), "xsd:int"))
				{	soap_flag_line_USCOREison1--;
					continue;
				}
			if (soap_flag_line_USCOREcurrent1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "line_current", &(a->ns1__LINE_USCOREINFO_USCOREType::line_USCOREcurrent), "xsd:int"))
				{	soap_flag_line_USCOREcurrent1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__LINE_USCOREINFO_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__LINE_USCOREINFO_USCOREType, 0, sizeof(ns1__LINE_USCOREINFO_USCOREType), 0, soap_copy_ns1__LINE_USCOREINFO_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_line_USCOREid1 > 0 || soap_flag_line_USCOREdcuid1 > 0 || soap_flag_line_USCOREstatus1 > 0 || soap_flag_line_USCOREnote1 > 0 || soap_flag_line_USCOREmode1 > 0 || soap_flag_line_USCOREison1 > 0 || soap_flag_line_USCOREcurrent1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__LINE_USCOREINFO_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__LINE_USCOREINFO_USCOREType);
	if (this->soap_out(soap, tag?tag:"ns1:LINE_INFO_Type", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__LINE_USCOREINFO_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__LINE_USCOREINFO_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__LINE_USCOREINFO_USCOREType * SOAP_FMAC4 soap_get_ns1__LINE_USCOREINFO_USCOREType(struct soap *soap, ns1__LINE_USCOREINFO_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__LINE_USCOREINFO_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__LINE_USCOREINFO_USCOREType * SOAP_FMAC2 soap_instantiate_ns1__LINE_USCOREINFO_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__LINE_USCOREINFO_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__LINE_USCOREINFO_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__LINE_USCOREINFO_USCOREType);
		if (size)
			*size = sizeof(ns1__LINE_USCOREINFO_USCOREType);
		((ns1__LINE_USCOREINFO_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__LINE_USCOREINFO_USCOREType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__LINE_USCOREINFO_USCOREType);
		for (int i = 0; i < n; i++)
			((ns1__LINE_USCOREINFO_USCOREType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__LINE_USCOREINFO_USCOREType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__LINE_USCOREINFO_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__LINE_USCOREINFO_USCOREType %p -> %p\n", q, p));
	*(ns1__LINE_USCOREINFO_USCOREType*)p = *(ns1__LINE_USCOREINFO_USCOREType*)q;
}

void ns1__LCULOGINFOType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__LCULOGINFOType::lcuLogId);
	soap_default_string(soap, &this->ns1__LCULOGINFOType::lcuLogLcuId);
	soap_default_int(soap, &this->ns1__LCULOGINFOType::lcuLogPowerConsum);
	soap_default_int(soap, &this->ns1__LCULOGINFOType::lcuLogPowerCtrl);
	soap_default_int(soap, &this->ns1__LCULOGINFOType::lcuLogPower);
	soap_default_int(soap, &this->ns1__LCULOGINFOType::lcuLogTolerance);
	soap_default_string(soap, &this->ns1__LCULOGINFOType::lcuLogDate);
	soap_default_string(soap, &this->ns1__LCULOGINFOType::lcuLogLightName);
	soap_default_int(soap, &this->ns1__LCULOGINFOType::lcuLogStatus);
	soap_default_int(soap, &this->ns1__LCULOGINFOType::lcuLogMode);
	/* transient soap skipped */
}

void ns1__LCULOGINFOType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__LCULOGINFOType::lcuLogLcuId);
	soap_serialize_string(soap, &this->ns1__LCULOGINFOType::lcuLogDate);
	soap_serialize_string(soap, &this->ns1__LCULOGINFOType::lcuLogLightName);
	/* transient soap skipped */
}

int ns1__LCULOGINFOType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__LCULOGINFOType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__LCULOGINFOType(struct soap *soap, const char *tag, int id, const ns1__LCULOGINFOType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__LCULOGINFOType), type))
		return soap->error;
	if (soap_out_int(soap, "lcuLogId", -1, &(a->ns1__LCULOGINFOType::lcuLogId), ""))
		return soap->error;
	if (a->ns1__LCULOGINFOType::lcuLogLcuId)
	{	if (soap_out_string(soap, "lcuLogLcuId", -1, &a->ns1__LCULOGINFOType::lcuLogLcuId, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "lcuLogLcuId"))
		return soap->error;
	if (soap_out_int(soap, "lcuLogPowerConsum", -1, &(a->ns1__LCULOGINFOType::lcuLogPowerConsum), ""))
		return soap->error;
	if (soap_out_int(soap, "lcuLogPowerCtrl", -1, &(a->ns1__LCULOGINFOType::lcuLogPowerCtrl), ""))
		return soap->error;
	if (soap_out_int(soap, "lcuLogPower", -1, &(a->ns1__LCULOGINFOType::lcuLogPower), ""))
		return soap->error;
	if (soap_out_int(soap, "lcuLogTolerance", -1, &(a->ns1__LCULOGINFOType::lcuLogTolerance), ""))
		return soap->error;
	if (a->ns1__LCULOGINFOType::lcuLogDate)
	{	if (soap_out_string(soap, "lcuLogDate", -1, &a->ns1__LCULOGINFOType::lcuLogDate, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "lcuLogDate"))
		return soap->error;
	if (a->ns1__LCULOGINFOType::lcuLogLightName)
	{	if (soap_out_string(soap, "lcuLogLightName", -1, &a->ns1__LCULOGINFOType::lcuLogLightName, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "lcuLogLightName"))
		return soap->error;
	if (soap_out_int(soap, "lcuLogStatus", -1, &(a->ns1__LCULOGINFOType::lcuLogStatus), ""))
		return soap->error;
	if (soap_out_int(soap, "lcuLogMode", -1, &(a->ns1__LCULOGINFOType::lcuLogMode), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__LCULOGINFOType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__LCULOGINFOType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__LCULOGINFOType * SOAP_FMAC4 soap_in_ns1__LCULOGINFOType(struct soap *soap, const char *tag, ns1__LCULOGINFOType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__LCULOGINFOType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__LCULOGINFOType, sizeof(ns1__LCULOGINFOType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__LCULOGINFOType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__LCULOGINFOType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_lcuLogId1 = 1;
	size_t soap_flag_lcuLogLcuId1 = 1;
	size_t soap_flag_lcuLogPowerConsum1 = 1;
	size_t soap_flag_lcuLogPowerCtrl1 = 1;
	size_t soap_flag_lcuLogPower1 = 1;
	size_t soap_flag_lcuLogTolerance1 = 1;
	size_t soap_flag_lcuLogDate1 = 1;
	size_t soap_flag_lcuLogLightName1 = 1;
	size_t soap_flag_lcuLogStatus1 = 1;
	size_t soap_flag_lcuLogMode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lcuLogId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "lcuLogId", &(a->ns1__LCULOGINFOType::lcuLogId), "xsd:int"))
				{	soap_flag_lcuLogId1--;
					continue;
				}
			if (soap_flag_lcuLogLcuId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "lcuLogLcuId", &(a->ns1__LCULOGINFOType::lcuLogLcuId), "xsd:string"))
				{	soap_flag_lcuLogLcuId1--;
					continue;
				}
			if (soap_flag_lcuLogPowerConsum1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "lcuLogPowerConsum", &(a->ns1__LCULOGINFOType::lcuLogPowerConsum), "xsd:int"))
				{	soap_flag_lcuLogPowerConsum1--;
					continue;
				}
			if (soap_flag_lcuLogPowerCtrl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "lcuLogPowerCtrl", &(a->ns1__LCULOGINFOType::lcuLogPowerCtrl), "xsd:int"))
				{	soap_flag_lcuLogPowerCtrl1--;
					continue;
				}
			if (soap_flag_lcuLogPower1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "lcuLogPower", &(a->ns1__LCULOGINFOType::lcuLogPower), "xsd:int"))
				{	soap_flag_lcuLogPower1--;
					continue;
				}
			if (soap_flag_lcuLogTolerance1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "lcuLogTolerance", &(a->ns1__LCULOGINFOType::lcuLogTolerance), "xsd:int"))
				{	soap_flag_lcuLogTolerance1--;
					continue;
				}
			if (soap_flag_lcuLogDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "lcuLogDate", &(a->ns1__LCULOGINFOType::lcuLogDate), "xsd:string"))
				{	soap_flag_lcuLogDate1--;
					continue;
				}
			if (soap_flag_lcuLogLightName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "lcuLogLightName", &(a->ns1__LCULOGINFOType::lcuLogLightName), "xsd:string"))
				{	soap_flag_lcuLogLightName1--;
					continue;
				}
			if (soap_flag_lcuLogStatus1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "lcuLogStatus", &(a->ns1__LCULOGINFOType::lcuLogStatus), "xsd:int"))
				{	soap_flag_lcuLogStatus1--;
					continue;
				}
			if (soap_flag_lcuLogMode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "lcuLogMode", &(a->ns1__LCULOGINFOType::lcuLogMode), "xsd:int"))
				{	soap_flag_lcuLogMode1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__LCULOGINFOType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__LCULOGINFOType, 0, sizeof(ns1__LCULOGINFOType), 0, soap_copy_ns1__LCULOGINFOType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_lcuLogId1 > 0 || soap_flag_lcuLogLcuId1 > 0 || soap_flag_lcuLogPowerConsum1 > 0 || soap_flag_lcuLogPowerCtrl1 > 0 || soap_flag_lcuLogPower1 > 0 || soap_flag_lcuLogTolerance1 > 0 || soap_flag_lcuLogDate1 > 0 || soap_flag_lcuLogLightName1 > 0 || soap_flag_lcuLogStatus1 > 0 || soap_flag_lcuLogMode1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__LCULOGINFOType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__LCULOGINFOType);
	if (this->soap_out(soap, tag?tag:"ns1:LCULOGINFOType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__LCULOGINFOType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__LCULOGINFOType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__LCULOGINFOType * SOAP_FMAC4 soap_get_ns1__LCULOGINFOType(struct soap *soap, ns1__LCULOGINFOType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__LCULOGINFOType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__LCULOGINFOType * SOAP_FMAC2 soap_instantiate_ns1__LCULOGINFOType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__LCULOGINFOType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__LCULOGINFOType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__LCULOGINFOType);
		if (size)
			*size = sizeof(ns1__LCULOGINFOType);
		((ns1__LCULOGINFOType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__LCULOGINFOType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__LCULOGINFOType);
		for (int i = 0; i < n; i++)
			((ns1__LCULOGINFOType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__LCULOGINFOType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__LCULOGINFOType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__LCULOGINFOType %p -> %p\n", q, p));
	*(ns1__LCULOGINFOType*)p = *(ns1__LCULOGINFOType*)q;
}

void ns1__LCU_USCOREINFO_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__LCU_USCOREINFO_USCOREType::lcu_USCOREid);
	soap_default_string(soap, &this->ns1__LCU_USCOREINFO_USCOREType::lcu_USCOREgps);
	soap_default_string(soap, &this->ns1__LCU_USCOREINFO_USCOREType::lcu_USCOREnote);
	soap_default_int(soap, &this->ns1__LCU_USCOREINFO_USCOREType::lcu_USCOREmode);
	soap_default_int(soap, &this->ns1__LCU_USCOREINFO_USCOREType::lcu_USCOREison);
	soap_default_int(soap, &this->ns1__LCU_USCOREINFO_USCOREType::lcu_USCOREstatus);
	soap_default_int(soap, &this->ns1__LCU_USCOREINFO_USCOREType::lcu_USCOREcurrent);
	soap_default_int(soap, &this->ns1__LCU_USCOREINFO_USCOREType::lcu_USCORElevel);
	soap_default_int(soap, &this->ns1__LCU_USCOREINFO_USCOREType::lcu_USCOREistemp);
	soap_default_string(soap, &this->ns1__LCU_USCOREINFO_USCOREType::lcu_USCOREdcuid);
	soap_default_int(soap, &this->ns1__LCU_USCOREINFO_USCOREType::lcu_USCOREpower);
	soap_default_string(soap, &this->ns1__LCU_USCOREINFO_USCOREType::lcu_USCORElightname);
	soap_default_int(soap, &this->ns1__LCU_USCOREINFO_USCOREType::lcu_USCOREtolerance);
	/* transient soap skipped */
}

void ns1__LCU_USCOREINFO_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__LCU_USCOREINFO_USCOREType::lcu_USCOREid);
	soap_serialize_string(soap, &this->ns1__LCU_USCOREINFO_USCOREType::lcu_USCOREgps);
	soap_serialize_string(soap, &this->ns1__LCU_USCOREINFO_USCOREType::lcu_USCOREnote);
	soap_serialize_string(soap, &this->ns1__LCU_USCOREINFO_USCOREType::lcu_USCOREdcuid);
	soap_serialize_string(soap, &this->ns1__LCU_USCOREINFO_USCOREType::lcu_USCORElightname);
	/* transient soap skipped */
}

int ns1__LCU_USCOREINFO_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__LCU_USCOREINFO_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__LCU_USCOREINFO_USCOREType(struct soap *soap, const char *tag, int id, const ns1__LCU_USCOREINFO_USCOREType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__LCU_USCOREINFO_USCOREType), type))
		return soap->error;
	if (a->ns1__LCU_USCOREINFO_USCOREType::lcu_USCOREid)
	{	if (soap_out_string(soap, "lcu_id", -1, &a->ns1__LCU_USCOREINFO_USCOREType::lcu_USCOREid, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "lcu_id"))
		return soap->error;
	if (a->ns1__LCU_USCOREINFO_USCOREType::lcu_USCOREgps)
	{	if (soap_out_string(soap, "lcu_gps", -1, &a->ns1__LCU_USCOREINFO_USCOREType::lcu_USCOREgps, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "lcu_gps"))
		return soap->error;
	if (a->ns1__LCU_USCOREINFO_USCOREType::lcu_USCOREnote)
	{	if (soap_out_string(soap, "lcu_note", -1, &a->ns1__LCU_USCOREINFO_USCOREType::lcu_USCOREnote, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "lcu_note"))
		return soap->error;
	if (soap_out_int(soap, "lcu_mode", -1, &(a->ns1__LCU_USCOREINFO_USCOREType::lcu_USCOREmode), ""))
		return soap->error;
	if (soap_out_int(soap, "lcu_ison", -1, &(a->ns1__LCU_USCOREINFO_USCOREType::lcu_USCOREison), ""))
		return soap->error;
	if (soap_out_int(soap, "lcu_status", -1, &(a->ns1__LCU_USCOREINFO_USCOREType::lcu_USCOREstatus), ""))
		return soap->error;
	if (soap_out_int(soap, "lcu_current", -1, &(a->ns1__LCU_USCOREINFO_USCOREType::lcu_USCOREcurrent), ""))
		return soap->error;
	if (soap_out_int(soap, "lcu_level", -1, &(a->ns1__LCU_USCOREINFO_USCOREType::lcu_USCORElevel), ""))
		return soap->error;
	if (soap_out_int(soap, "lcu_istemp", -1, &(a->ns1__LCU_USCOREINFO_USCOREType::lcu_USCOREistemp), ""))
		return soap->error;
	if (a->ns1__LCU_USCOREINFO_USCOREType::lcu_USCOREdcuid)
	{	if (soap_out_string(soap, "lcu_dcuid", -1, &a->ns1__LCU_USCOREINFO_USCOREType::lcu_USCOREdcuid, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "lcu_dcuid"))
		return soap->error;
	if (soap_out_int(soap, "lcu_power", -1, &(a->ns1__LCU_USCOREINFO_USCOREType::lcu_USCOREpower), ""))
		return soap->error;
	if (a->ns1__LCU_USCOREINFO_USCOREType::lcu_USCORElightname)
	{	if (soap_out_string(soap, "lcu_lightname", -1, &a->ns1__LCU_USCOREINFO_USCOREType::lcu_USCORElightname, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "lcu_lightname"))
		return soap->error;
	if (soap_out_int(soap, "lcu_tolerance", -1, &(a->ns1__LCU_USCOREINFO_USCOREType::lcu_USCOREtolerance), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__LCU_USCOREINFO_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__LCU_USCOREINFO_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__LCU_USCOREINFO_USCOREType * SOAP_FMAC4 soap_in_ns1__LCU_USCOREINFO_USCOREType(struct soap *soap, const char *tag, ns1__LCU_USCOREINFO_USCOREType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__LCU_USCOREINFO_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__LCU_USCOREINFO_USCOREType, sizeof(ns1__LCU_USCOREINFO_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__LCU_USCOREINFO_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__LCU_USCOREINFO_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_lcu_USCOREid1 = 1;
	size_t soap_flag_lcu_USCOREgps1 = 1;
	size_t soap_flag_lcu_USCOREnote1 = 1;
	size_t soap_flag_lcu_USCOREmode1 = 1;
	size_t soap_flag_lcu_USCOREison1 = 1;
	size_t soap_flag_lcu_USCOREstatus1 = 1;
	size_t soap_flag_lcu_USCOREcurrent1 = 1;
	size_t soap_flag_lcu_USCORElevel1 = 1;
	size_t soap_flag_lcu_USCOREistemp1 = 1;
	size_t soap_flag_lcu_USCOREdcuid1 = 1;
	size_t soap_flag_lcu_USCOREpower1 = 1;
	size_t soap_flag_lcu_USCORElightname1 = 1;
	size_t soap_flag_lcu_USCOREtolerance1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lcu_USCOREid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "lcu_id", &(a->ns1__LCU_USCOREINFO_USCOREType::lcu_USCOREid), "xsd:string"))
				{	soap_flag_lcu_USCOREid1--;
					continue;
				}
			if (soap_flag_lcu_USCOREgps1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "lcu_gps", &(a->ns1__LCU_USCOREINFO_USCOREType::lcu_USCOREgps), "xsd:string"))
				{	soap_flag_lcu_USCOREgps1--;
					continue;
				}
			if (soap_flag_lcu_USCOREnote1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "lcu_note", &(a->ns1__LCU_USCOREINFO_USCOREType::lcu_USCOREnote), "xsd:string"))
				{	soap_flag_lcu_USCOREnote1--;
					continue;
				}
			if (soap_flag_lcu_USCOREmode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "lcu_mode", &(a->ns1__LCU_USCOREINFO_USCOREType::lcu_USCOREmode), "xsd:int"))
				{	soap_flag_lcu_USCOREmode1--;
					continue;
				}
			if (soap_flag_lcu_USCOREison1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "lcu_ison", &(a->ns1__LCU_USCOREINFO_USCOREType::lcu_USCOREison), "xsd:int"))
				{	soap_flag_lcu_USCOREison1--;
					continue;
				}
			if (soap_flag_lcu_USCOREstatus1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "lcu_status", &(a->ns1__LCU_USCOREINFO_USCOREType::lcu_USCOREstatus), "xsd:int"))
				{	soap_flag_lcu_USCOREstatus1--;
					continue;
				}
			if (soap_flag_lcu_USCOREcurrent1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "lcu_current", &(a->ns1__LCU_USCOREINFO_USCOREType::lcu_USCOREcurrent), "xsd:int"))
				{	soap_flag_lcu_USCOREcurrent1--;
					continue;
				}
			if (soap_flag_lcu_USCORElevel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "lcu_level", &(a->ns1__LCU_USCOREINFO_USCOREType::lcu_USCORElevel), "xsd:int"))
				{	soap_flag_lcu_USCORElevel1--;
					continue;
				}
			if (soap_flag_lcu_USCOREistemp1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "lcu_istemp", &(a->ns1__LCU_USCOREINFO_USCOREType::lcu_USCOREistemp), "xsd:int"))
				{	soap_flag_lcu_USCOREistemp1--;
					continue;
				}
			if (soap_flag_lcu_USCOREdcuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "lcu_dcuid", &(a->ns1__LCU_USCOREINFO_USCOREType::lcu_USCOREdcuid), "xsd:string"))
				{	soap_flag_lcu_USCOREdcuid1--;
					continue;
				}
			if (soap_flag_lcu_USCOREpower1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "lcu_power", &(a->ns1__LCU_USCOREINFO_USCOREType::lcu_USCOREpower), "xsd:int"))
				{	soap_flag_lcu_USCOREpower1--;
					continue;
				}
			if (soap_flag_lcu_USCORElightname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "lcu_lightname", &(a->ns1__LCU_USCOREINFO_USCOREType::lcu_USCORElightname), "xsd:string"))
				{	soap_flag_lcu_USCORElightname1--;
					continue;
				}
			if (soap_flag_lcu_USCOREtolerance1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "lcu_tolerance", &(a->ns1__LCU_USCOREINFO_USCOREType::lcu_USCOREtolerance), "xsd:int"))
				{	soap_flag_lcu_USCOREtolerance1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__LCU_USCOREINFO_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__LCU_USCOREINFO_USCOREType, 0, sizeof(ns1__LCU_USCOREINFO_USCOREType), 0, soap_copy_ns1__LCU_USCOREINFO_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_lcu_USCOREid1 > 0 || soap_flag_lcu_USCOREgps1 > 0 || soap_flag_lcu_USCOREnote1 > 0 || soap_flag_lcu_USCOREmode1 > 0 || soap_flag_lcu_USCOREison1 > 0 || soap_flag_lcu_USCOREstatus1 > 0 || soap_flag_lcu_USCOREcurrent1 > 0 || soap_flag_lcu_USCORElevel1 > 0 || soap_flag_lcu_USCOREistemp1 > 0 || soap_flag_lcu_USCOREdcuid1 > 0 || soap_flag_lcu_USCOREpower1 > 0 || soap_flag_lcu_USCORElightname1 > 0 || soap_flag_lcu_USCOREtolerance1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__LCU_USCOREINFO_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__LCU_USCOREINFO_USCOREType);
	if (this->soap_out(soap, tag?tag:"ns1:LCU_INFO_Type", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__LCU_USCOREINFO_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__LCU_USCOREINFO_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__LCU_USCOREINFO_USCOREType * SOAP_FMAC4 soap_get_ns1__LCU_USCOREINFO_USCOREType(struct soap *soap, ns1__LCU_USCOREINFO_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__LCU_USCOREINFO_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__LCU_USCOREINFO_USCOREType * SOAP_FMAC2 soap_instantiate_ns1__LCU_USCOREINFO_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__LCU_USCOREINFO_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__LCU_USCOREINFO_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__LCU_USCOREINFO_USCOREType);
		if (size)
			*size = sizeof(ns1__LCU_USCOREINFO_USCOREType);
		((ns1__LCU_USCOREINFO_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__LCU_USCOREINFO_USCOREType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__LCU_USCOREINFO_USCOREType);
		for (int i = 0; i < n; i++)
			((ns1__LCU_USCOREINFO_USCOREType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__LCU_USCOREINFO_USCOREType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__LCU_USCOREINFO_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__LCU_USCOREINFO_USCOREType %p -> %p\n", q, p));
	*(ns1__LCU_USCOREINFO_USCOREType*)p = *(ns1__LCU_USCOREINFO_USCOREType*)q;
}

void ns1__DCU_USCOREINFO_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__DCU_USCOREINFO_USCOREType::dcu_USCOREid);
	soap_default_string(soap, &this->ns1__DCU_USCOREINFO_USCOREType::dcu_USCOREphone);
	soap_default_string(soap, &this->ns1__DCU_USCOREINFO_USCOREType::dcu_USCOREgps);
	soap_default_string(soap, &this->ns1__DCU_USCOREINFO_USCOREType::dcu_USCOREaddress);
	soap_default_string(soap, &this->ns1__DCU_USCOREINFO_USCOREType::dcu_USCOREnote);
	soap_default_int(soap, &this->ns1__DCU_USCOREINFO_USCOREType::dcu_USCOREmode);
	soap_default_int(soap, &this->ns1__DCU_USCOREINFO_USCOREType::dcu_USCOREstatus);
	soap_default_int(soap, &this->ns1__DCU_USCOREINFO_USCOREType::dcu_USCOREprogram_USCOREid);
	soap_default_int(soap, &this->ns1__DCU_USCOREINFO_USCOREType::dcu_USCOREzoneid);
	/* transient soap skipped */
}

void ns1__DCU_USCOREINFO_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__DCU_USCOREINFO_USCOREType::dcu_USCOREid);
	soap_serialize_string(soap, &this->ns1__DCU_USCOREINFO_USCOREType::dcu_USCOREphone);
	soap_serialize_string(soap, &this->ns1__DCU_USCOREINFO_USCOREType::dcu_USCOREgps);
	soap_serialize_string(soap, &this->ns1__DCU_USCOREINFO_USCOREType::dcu_USCOREaddress);
	soap_serialize_string(soap, &this->ns1__DCU_USCOREINFO_USCOREType::dcu_USCOREnote);
	/* transient soap skipped */
}

int ns1__DCU_USCOREINFO_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__DCU_USCOREINFO_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DCU_USCOREINFO_USCOREType(struct soap *soap, const char *tag, int id, const ns1__DCU_USCOREINFO_USCOREType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DCU_USCOREINFO_USCOREType), type))
		return soap->error;
	if (a->ns1__DCU_USCOREINFO_USCOREType::dcu_USCOREid)
	{	if (soap_out_string(soap, "dcu_id", -1, &a->ns1__DCU_USCOREINFO_USCOREType::dcu_USCOREid, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "dcu_id"))
		return soap->error;
	if (a->ns1__DCU_USCOREINFO_USCOREType::dcu_USCOREphone)
	{	if (soap_out_string(soap, "dcu_phone", -1, &a->ns1__DCU_USCOREINFO_USCOREType::dcu_USCOREphone, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "dcu_phone"))
		return soap->error;
	if (a->ns1__DCU_USCOREINFO_USCOREType::dcu_USCOREgps)
	{	if (soap_out_string(soap, "dcu_gps", -1, &a->ns1__DCU_USCOREINFO_USCOREType::dcu_USCOREgps, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "dcu_gps"))
		return soap->error;
	if (a->ns1__DCU_USCOREINFO_USCOREType::dcu_USCOREaddress)
	{	if (soap_out_string(soap, "dcu_address", -1, &a->ns1__DCU_USCOREINFO_USCOREType::dcu_USCOREaddress, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "dcu_address"))
		return soap->error;
	if (a->ns1__DCU_USCOREINFO_USCOREType::dcu_USCOREnote)
	{	if (soap_out_string(soap, "dcu_note", -1, &a->ns1__DCU_USCOREINFO_USCOREType::dcu_USCOREnote, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "dcu_note"))
		return soap->error;
	if (soap_out_int(soap, "dcu_mode", -1, &(a->ns1__DCU_USCOREINFO_USCOREType::dcu_USCOREmode), ""))
		return soap->error;
	if (soap_out_int(soap, "dcu_status", -1, &(a->ns1__DCU_USCOREINFO_USCOREType::dcu_USCOREstatus), ""))
		return soap->error;
	if (soap_out_int(soap, "dcu_program_id", -1, &(a->ns1__DCU_USCOREINFO_USCOREType::dcu_USCOREprogram_USCOREid), ""))
		return soap->error;
	if (soap_out_int(soap, "dcu_zoneid", -1, &(a->ns1__DCU_USCOREINFO_USCOREType::dcu_USCOREzoneid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__DCU_USCOREINFO_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__DCU_USCOREINFO_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__DCU_USCOREINFO_USCOREType * SOAP_FMAC4 soap_in_ns1__DCU_USCOREINFO_USCOREType(struct soap *soap, const char *tag, ns1__DCU_USCOREINFO_USCOREType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__DCU_USCOREINFO_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DCU_USCOREINFO_USCOREType, sizeof(ns1__DCU_USCOREINFO_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__DCU_USCOREINFO_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__DCU_USCOREINFO_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_dcu_USCOREid1 = 1;
	size_t soap_flag_dcu_USCOREphone1 = 1;
	size_t soap_flag_dcu_USCOREgps1 = 1;
	size_t soap_flag_dcu_USCOREaddress1 = 1;
	size_t soap_flag_dcu_USCOREnote1 = 1;
	size_t soap_flag_dcu_USCOREmode1 = 1;
	size_t soap_flag_dcu_USCOREstatus1 = 1;
	size_t soap_flag_dcu_USCOREprogram_USCOREid1 = 1;
	size_t soap_flag_dcu_USCOREzoneid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dcu_USCOREid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "dcu_id", &(a->ns1__DCU_USCOREINFO_USCOREType::dcu_USCOREid), "xsd:string"))
				{	soap_flag_dcu_USCOREid1--;
					continue;
				}
			if (soap_flag_dcu_USCOREphone1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "dcu_phone", &(a->ns1__DCU_USCOREINFO_USCOREType::dcu_USCOREphone), "xsd:string"))
				{	soap_flag_dcu_USCOREphone1--;
					continue;
				}
			if (soap_flag_dcu_USCOREgps1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "dcu_gps", &(a->ns1__DCU_USCOREINFO_USCOREType::dcu_USCOREgps), "xsd:string"))
				{	soap_flag_dcu_USCOREgps1--;
					continue;
				}
			if (soap_flag_dcu_USCOREaddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "dcu_address", &(a->ns1__DCU_USCOREINFO_USCOREType::dcu_USCOREaddress), "xsd:string"))
				{	soap_flag_dcu_USCOREaddress1--;
					continue;
				}
			if (soap_flag_dcu_USCOREnote1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "dcu_note", &(a->ns1__DCU_USCOREINFO_USCOREType::dcu_USCOREnote), "xsd:string"))
				{	soap_flag_dcu_USCOREnote1--;
					continue;
				}
			if (soap_flag_dcu_USCOREmode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "dcu_mode", &(a->ns1__DCU_USCOREINFO_USCOREType::dcu_USCOREmode), "xsd:int"))
				{	soap_flag_dcu_USCOREmode1--;
					continue;
				}
			if (soap_flag_dcu_USCOREstatus1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "dcu_status", &(a->ns1__DCU_USCOREINFO_USCOREType::dcu_USCOREstatus), "xsd:int"))
				{	soap_flag_dcu_USCOREstatus1--;
					continue;
				}
			if (soap_flag_dcu_USCOREprogram_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "dcu_program_id", &(a->ns1__DCU_USCOREINFO_USCOREType::dcu_USCOREprogram_USCOREid), "xsd:int"))
				{	soap_flag_dcu_USCOREprogram_USCOREid1--;
					continue;
				}
			if (soap_flag_dcu_USCOREzoneid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "dcu_zoneid", &(a->ns1__DCU_USCOREINFO_USCOREType::dcu_USCOREzoneid), "xsd:int"))
				{	soap_flag_dcu_USCOREzoneid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__DCU_USCOREINFO_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DCU_USCOREINFO_USCOREType, 0, sizeof(ns1__DCU_USCOREINFO_USCOREType), 0, soap_copy_ns1__DCU_USCOREINFO_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_dcu_USCOREid1 > 0 || soap_flag_dcu_USCOREphone1 > 0 || soap_flag_dcu_USCOREgps1 > 0 || soap_flag_dcu_USCOREaddress1 > 0 || soap_flag_dcu_USCOREnote1 > 0 || soap_flag_dcu_USCOREmode1 > 0 || soap_flag_dcu_USCOREstatus1 > 0 || soap_flag_dcu_USCOREprogram_USCOREid1 > 0 || soap_flag_dcu_USCOREzoneid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__DCU_USCOREINFO_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__DCU_USCOREINFO_USCOREType);
	if (this->soap_out(soap, tag?tag:"ns1:DCU_INFO_Type", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__DCU_USCOREINFO_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__DCU_USCOREINFO_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__DCU_USCOREINFO_USCOREType * SOAP_FMAC4 soap_get_ns1__DCU_USCOREINFO_USCOREType(struct soap *soap, ns1__DCU_USCOREINFO_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DCU_USCOREINFO_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__DCU_USCOREINFO_USCOREType * SOAP_FMAC2 soap_instantiate_ns1__DCU_USCOREINFO_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DCU_USCOREINFO_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__DCU_USCOREINFO_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__DCU_USCOREINFO_USCOREType);
		if (size)
			*size = sizeof(ns1__DCU_USCOREINFO_USCOREType);
		((ns1__DCU_USCOREINFO_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__DCU_USCOREINFO_USCOREType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__DCU_USCOREINFO_USCOREType);
		for (int i = 0; i < n; i++)
			((ns1__DCU_USCOREINFO_USCOREType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__DCU_USCOREINFO_USCOREType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__DCU_USCOREINFO_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__DCU_USCOREINFO_USCOREType %p -> %p\n", q, p));
	*(ns1__DCU_USCOREINFO_USCOREType*)p = *(ns1__DCU_USCOREINFO_USCOREType*)q;
}

void ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType::curr_USCOREusername);
	soap_default_int(soap, &this->ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType::curr_USCOREsession_USCOREid);
	/* transient soap skipped */
}

void ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType::curr_USCOREusername);
	/* transient soap skipped */
}

int ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType(struct soap *soap, const char *tag, int id, const ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType), type))
		return soap->error;
	if (a->ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType::curr_USCOREusername)
	{	if (soap_out_string(soap, "curr_username", -1, &a->ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType::curr_USCOREusername, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "curr_username"))
		return soap->error;
	if (soap_out_int(soap, "curr_session_id", -1, &(a->ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType::curr_USCOREsession_USCOREid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType * SOAP_FMAC4 soap_in_ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType(struct soap *soap, const char *tag, ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType, sizeof(ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_curr_USCOREusername1 = 1;
	size_t soap_flag_curr_USCOREsession_USCOREid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_curr_USCOREusername1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "curr_username", &(a->ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType::curr_USCOREusername), "xsd:string"))
				{	soap_flag_curr_USCOREusername1--;
					continue;
				}
			if (soap_flag_curr_USCOREsession_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "curr_session_id", &(a->ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType::curr_USCOREsession_USCOREid), "xsd:int"))
				{	soap_flag_curr_USCOREsession_USCOREid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType, 0, sizeof(ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType), 0, soap_copy_ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_curr_USCOREusername1 > 0 || soap_flag_curr_USCOREsession_USCOREid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType);
	if (this->soap_out(soap, tag?tag:"ns1:CURR_LOGIN_INFO_Type", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType * SOAP_FMAC4 soap_get_ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType(struct soap *soap, ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType * SOAP_FMAC2 soap_instantiate_ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType);
		if (size)
			*size = sizeof(ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType);
		((ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType);
		for (int i = 0; i < n; i++)
			((ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType %p -> %p\n", q, p));
	*(ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType*)p = *(ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getLcuLogOperation(struct soap *soap, struct __ns1__getLcuLogOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getLcuLogOperation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getLcuLogOperation(struct soap *soap, const struct __ns1__getLcuLogOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getLcuLogOperation(soap, &a->ns1__getLcuLogOperation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getLcuLogOperation(struct soap *soap, const char *tag, int id, const struct __ns1__getLcuLogOperation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getLcuLogOperation(soap, "ns1:getLcuLogOperation", -1, &a->ns1__getLcuLogOperation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getLcuLogOperation * SOAP_FMAC4 soap_in___ns1__getLcuLogOperation(struct soap *soap, const char *tag, struct __ns1__getLcuLogOperation *a, const char *type)
{
	size_t soap_flag_ns1__getLcuLogOperation = 1;
	short soap_flag;
	a = (struct __ns1__getLcuLogOperation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getLcuLogOperation, sizeof(struct __ns1__getLcuLogOperation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getLcuLogOperation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getLcuLogOperation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getLcuLogOperation(soap, "ns1:getLcuLogOperation", &a->ns1__getLcuLogOperation, ""))
				{	soap_flag_ns1__getLcuLogOperation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getLcuLogOperation(struct soap *soap, const struct __ns1__getLcuLogOperation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getLcuLogOperation(soap, tag?tag:"-ns1:getLcuLogOperation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getLcuLogOperation * SOAP_FMAC4 soap_get___ns1__getLcuLogOperation(struct soap *soap, struct __ns1__getLcuLogOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getLcuLogOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getLcuLogOperation * SOAP_FMAC2 soap_instantiate___ns1__getLcuLogOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getLcuLogOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getLcuLogOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getLcuLogOperation);
		if (size)
			*size = sizeof(struct __ns1__getLcuLogOperation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getLcuLogOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getLcuLogOperation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getLcuLogOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getLcuLogOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getLcuLogOperation %p -> %p\n", q, p));
	*(struct __ns1__getLcuLogOperation*)p = *(struct __ns1__getLcuLogOperation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__removeScheduleOperation(struct soap *soap, struct __ns1__removeScheduleOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__removeScheduleOperation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__removeScheduleOperation(struct soap *soap, const struct __ns1__removeScheduleOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__removeScheduleOperation(soap, &a->ns1__removeScheduleOperation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__removeScheduleOperation(struct soap *soap, const char *tag, int id, const struct __ns1__removeScheduleOperation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__removeScheduleOperation(soap, "ns1:removeScheduleOperation", -1, &a->ns1__removeScheduleOperation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeScheduleOperation * SOAP_FMAC4 soap_in___ns1__removeScheduleOperation(struct soap *soap, const char *tag, struct __ns1__removeScheduleOperation *a, const char *type)
{
	size_t soap_flag_ns1__removeScheduleOperation = 1;
	short soap_flag;
	a = (struct __ns1__removeScheduleOperation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__removeScheduleOperation, sizeof(struct __ns1__removeScheduleOperation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__removeScheduleOperation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__removeScheduleOperation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__removeScheduleOperation(soap, "ns1:removeScheduleOperation", &a->ns1__removeScheduleOperation, ""))
				{	soap_flag_ns1__removeScheduleOperation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__removeScheduleOperation(struct soap *soap, const struct __ns1__removeScheduleOperation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__removeScheduleOperation(soap, tag?tag:"-ns1:removeScheduleOperation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeScheduleOperation * SOAP_FMAC4 soap_get___ns1__removeScheduleOperation(struct soap *soap, struct __ns1__removeScheduleOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__removeScheduleOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__removeScheduleOperation * SOAP_FMAC2 soap_instantiate___ns1__removeScheduleOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__removeScheduleOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__removeScheduleOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeScheduleOperation);
		if (size)
			*size = sizeof(struct __ns1__removeScheduleOperation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeScheduleOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__removeScheduleOperation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__removeScheduleOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__removeScheduleOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__removeScheduleOperation %p -> %p\n", q, p));
	*(struct __ns1__removeScheduleOperation*)p = *(struct __ns1__removeScheduleOperation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__editScheduleOperation(struct soap *soap, struct __ns1__editScheduleOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__editScheduleOperation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__editScheduleOperation(struct soap *soap, const struct __ns1__editScheduleOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__editScheduleOperation(soap, &a->ns1__editScheduleOperation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__editScheduleOperation(struct soap *soap, const char *tag, int id, const struct __ns1__editScheduleOperation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__editScheduleOperation(soap, "ns1:editScheduleOperation", -1, &a->ns1__editScheduleOperation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__editScheduleOperation * SOAP_FMAC4 soap_in___ns1__editScheduleOperation(struct soap *soap, const char *tag, struct __ns1__editScheduleOperation *a, const char *type)
{
	size_t soap_flag_ns1__editScheduleOperation = 1;
	short soap_flag;
	a = (struct __ns1__editScheduleOperation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__editScheduleOperation, sizeof(struct __ns1__editScheduleOperation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__editScheduleOperation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__editScheduleOperation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__editScheduleOperation(soap, "ns1:editScheduleOperation", &a->ns1__editScheduleOperation, ""))
				{	soap_flag_ns1__editScheduleOperation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__editScheduleOperation(struct soap *soap, const struct __ns1__editScheduleOperation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__editScheduleOperation(soap, tag?tag:"-ns1:editScheduleOperation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__editScheduleOperation * SOAP_FMAC4 soap_get___ns1__editScheduleOperation(struct soap *soap, struct __ns1__editScheduleOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__editScheduleOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__editScheduleOperation * SOAP_FMAC2 soap_instantiate___ns1__editScheduleOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__editScheduleOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__editScheduleOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__editScheduleOperation);
		if (size)
			*size = sizeof(struct __ns1__editScheduleOperation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__editScheduleOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__editScheduleOperation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__editScheduleOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__editScheduleOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__editScheduleOperation %p -> %p\n", q, p));
	*(struct __ns1__editScheduleOperation*)p = *(struct __ns1__editScheduleOperation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__addScheduleOperation(struct soap *soap, struct __ns1__addScheduleOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__addScheduleOperation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__addScheduleOperation(struct soap *soap, const struct __ns1__addScheduleOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__addScheduleOperation(soap, &a->ns1__addScheduleOperation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__addScheduleOperation(struct soap *soap, const char *tag, int id, const struct __ns1__addScheduleOperation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__addScheduleOperation(soap, "ns1:addScheduleOperation", -1, &a->ns1__addScheduleOperation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addScheduleOperation * SOAP_FMAC4 soap_in___ns1__addScheduleOperation(struct soap *soap, const char *tag, struct __ns1__addScheduleOperation *a, const char *type)
{
	size_t soap_flag_ns1__addScheduleOperation = 1;
	short soap_flag;
	a = (struct __ns1__addScheduleOperation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__addScheduleOperation, sizeof(struct __ns1__addScheduleOperation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__addScheduleOperation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__addScheduleOperation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__addScheduleOperation(soap, "ns1:addScheduleOperation", &a->ns1__addScheduleOperation, ""))
				{	soap_flag_ns1__addScheduleOperation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__addScheduleOperation(struct soap *soap, const struct __ns1__addScheduleOperation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__addScheduleOperation(soap, tag?tag:"-ns1:addScheduleOperation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addScheduleOperation * SOAP_FMAC4 soap_get___ns1__addScheduleOperation(struct soap *soap, struct __ns1__addScheduleOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__addScheduleOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__addScheduleOperation * SOAP_FMAC2 soap_instantiate___ns1__addScheduleOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__addScheduleOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__addScheduleOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__addScheduleOperation);
		if (size)
			*size = sizeof(struct __ns1__addScheduleOperation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__addScheduleOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__addScheduleOperation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__addScheduleOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__addScheduleOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__addScheduleOperation %p -> %p\n", q, p));
	*(struct __ns1__addScheduleOperation*)p = *(struct __ns1__addScheduleOperation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getScheduleOperation(struct soap *soap, struct __ns1__getScheduleOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getScheduleOperation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getScheduleOperation(struct soap *soap, const struct __ns1__getScheduleOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getScheduleOperation(soap, &a->ns1__getScheduleOperation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getScheduleOperation(struct soap *soap, const char *tag, int id, const struct __ns1__getScheduleOperation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getScheduleOperation(soap, "ns1:getScheduleOperation", -1, &a->ns1__getScheduleOperation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getScheduleOperation * SOAP_FMAC4 soap_in___ns1__getScheduleOperation(struct soap *soap, const char *tag, struct __ns1__getScheduleOperation *a, const char *type)
{
	size_t soap_flag_ns1__getScheduleOperation = 1;
	short soap_flag;
	a = (struct __ns1__getScheduleOperation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getScheduleOperation, sizeof(struct __ns1__getScheduleOperation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getScheduleOperation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getScheduleOperation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getScheduleOperation(soap, "ns1:getScheduleOperation", &a->ns1__getScheduleOperation, ""))
				{	soap_flag_ns1__getScheduleOperation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getScheduleOperation(struct soap *soap, const struct __ns1__getScheduleOperation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getScheduleOperation(soap, tag?tag:"-ns1:getScheduleOperation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getScheduleOperation * SOAP_FMAC4 soap_get___ns1__getScheduleOperation(struct soap *soap, struct __ns1__getScheduleOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getScheduleOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getScheduleOperation * SOAP_FMAC2 soap_instantiate___ns1__getScheduleOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getScheduleOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getScheduleOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getScheduleOperation);
		if (size)
			*size = sizeof(struct __ns1__getScheduleOperation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getScheduleOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getScheduleOperation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getScheduleOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getScheduleOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getScheduleOperation %p -> %p\n", q, p));
	*(struct __ns1__getScheduleOperation*)p = *(struct __ns1__getScheduleOperation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__removeListScheduleOperation(struct soap *soap, struct __ns1__removeListScheduleOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__removeListScheduleOperation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__removeListScheduleOperation(struct soap *soap, const struct __ns1__removeListScheduleOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__removeListScheduleOperation(soap, &a->ns1__removeListScheduleOperation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__removeListScheduleOperation(struct soap *soap, const char *tag, int id, const struct __ns1__removeListScheduleOperation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__removeListScheduleOperation(soap, "ns1:removeListScheduleOperation", -1, &a->ns1__removeListScheduleOperation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeListScheduleOperation * SOAP_FMAC4 soap_in___ns1__removeListScheduleOperation(struct soap *soap, const char *tag, struct __ns1__removeListScheduleOperation *a, const char *type)
{
	size_t soap_flag_ns1__removeListScheduleOperation = 1;
	short soap_flag;
	a = (struct __ns1__removeListScheduleOperation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__removeListScheduleOperation, sizeof(struct __ns1__removeListScheduleOperation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__removeListScheduleOperation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__removeListScheduleOperation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__removeListScheduleOperation(soap, "ns1:removeListScheduleOperation", &a->ns1__removeListScheduleOperation, ""))
				{	soap_flag_ns1__removeListScheduleOperation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__removeListScheduleOperation(struct soap *soap, const struct __ns1__removeListScheduleOperation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__removeListScheduleOperation(soap, tag?tag:"-ns1:removeListScheduleOperation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeListScheduleOperation * SOAP_FMAC4 soap_get___ns1__removeListScheduleOperation(struct soap *soap, struct __ns1__removeListScheduleOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__removeListScheduleOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__removeListScheduleOperation * SOAP_FMAC2 soap_instantiate___ns1__removeListScheduleOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__removeListScheduleOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__removeListScheduleOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeListScheduleOperation);
		if (size)
			*size = sizeof(struct __ns1__removeListScheduleOperation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeListScheduleOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__removeListScheduleOperation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__removeListScheduleOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__removeListScheduleOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__removeListScheduleOperation %p -> %p\n", q, p));
	*(struct __ns1__removeListScheduleOperation*)p = *(struct __ns1__removeListScheduleOperation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__editListScheduleOperation(struct soap *soap, struct __ns1__editListScheduleOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__editListScheduleOperation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__editListScheduleOperation(struct soap *soap, const struct __ns1__editListScheduleOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__editListScheduleOperation(soap, &a->ns1__editListScheduleOperation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__editListScheduleOperation(struct soap *soap, const char *tag, int id, const struct __ns1__editListScheduleOperation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__editListScheduleOperation(soap, "ns1:editListScheduleOperation", -1, &a->ns1__editListScheduleOperation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__editListScheduleOperation * SOAP_FMAC4 soap_in___ns1__editListScheduleOperation(struct soap *soap, const char *tag, struct __ns1__editListScheduleOperation *a, const char *type)
{
	size_t soap_flag_ns1__editListScheduleOperation = 1;
	short soap_flag;
	a = (struct __ns1__editListScheduleOperation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__editListScheduleOperation, sizeof(struct __ns1__editListScheduleOperation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__editListScheduleOperation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__editListScheduleOperation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__editListScheduleOperation(soap, "ns1:editListScheduleOperation", &a->ns1__editListScheduleOperation, ""))
				{	soap_flag_ns1__editListScheduleOperation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__editListScheduleOperation(struct soap *soap, const struct __ns1__editListScheduleOperation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__editListScheduleOperation(soap, tag?tag:"-ns1:editListScheduleOperation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__editListScheduleOperation * SOAP_FMAC4 soap_get___ns1__editListScheduleOperation(struct soap *soap, struct __ns1__editListScheduleOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__editListScheduleOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__editListScheduleOperation * SOAP_FMAC2 soap_instantiate___ns1__editListScheduleOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__editListScheduleOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__editListScheduleOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__editListScheduleOperation);
		if (size)
			*size = sizeof(struct __ns1__editListScheduleOperation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__editListScheduleOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__editListScheduleOperation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__editListScheduleOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__editListScheduleOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__editListScheduleOperation %p -> %p\n", q, p));
	*(struct __ns1__editListScheduleOperation*)p = *(struct __ns1__editListScheduleOperation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__addListScheduleOperation(struct soap *soap, struct __ns1__addListScheduleOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__addListScheduleOperation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__addListScheduleOperation(struct soap *soap, const struct __ns1__addListScheduleOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__addListScheduleOperation(soap, &a->ns1__addListScheduleOperation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__addListScheduleOperation(struct soap *soap, const char *tag, int id, const struct __ns1__addListScheduleOperation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__addListScheduleOperation(soap, "ns1:addListScheduleOperation", -1, &a->ns1__addListScheduleOperation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addListScheduleOperation * SOAP_FMAC4 soap_in___ns1__addListScheduleOperation(struct soap *soap, const char *tag, struct __ns1__addListScheduleOperation *a, const char *type)
{
	size_t soap_flag_ns1__addListScheduleOperation = 1;
	short soap_flag;
	a = (struct __ns1__addListScheduleOperation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__addListScheduleOperation, sizeof(struct __ns1__addListScheduleOperation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__addListScheduleOperation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__addListScheduleOperation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__addListScheduleOperation(soap, "ns1:addListScheduleOperation", &a->ns1__addListScheduleOperation, ""))
				{	soap_flag_ns1__addListScheduleOperation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__addListScheduleOperation(struct soap *soap, const struct __ns1__addListScheduleOperation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__addListScheduleOperation(soap, tag?tag:"-ns1:addListScheduleOperation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addListScheduleOperation * SOAP_FMAC4 soap_get___ns1__addListScheduleOperation(struct soap *soap, struct __ns1__addListScheduleOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__addListScheduleOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__addListScheduleOperation * SOAP_FMAC2 soap_instantiate___ns1__addListScheduleOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__addListScheduleOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__addListScheduleOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__addListScheduleOperation);
		if (size)
			*size = sizeof(struct __ns1__addListScheduleOperation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__addListScheduleOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__addListScheduleOperation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__addListScheduleOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__addListScheduleOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__addListScheduleOperation %p -> %p\n", q, p));
	*(struct __ns1__addListScheduleOperation*)p = *(struct __ns1__addListScheduleOperation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getListScheduleOperation(struct soap *soap, struct __ns1__getListScheduleOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getListScheduleOperation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getListScheduleOperation(struct soap *soap, const struct __ns1__getListScheduleOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getListScheduleOperation(soap, &a->ns1__getListScheduleOperation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getListScheduleOperation(struct soap *soap, const char *tag, int id, const struct __ns1__getListScheduleOperation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getListScheduleOperation(soap, "ns1:getListScheduleOperation", -1, &a->ns1__getListScheduleOperation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getListScheduleOperation * SOAP_FMAC4 soap_in___ns1__getListScheduleOperation(struct soap *soap, const char *tag, struct __ns1__getListScheduleOperation *a, const char *type)
{
	size_t soap_flag_ns1__getListScheduleOperation = 1;
	short soap_flag;
	a = (struct __ns1__getListScheduleOperation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getListScheduleOperation, sizeof(struct __ns1__getListScheduleOperation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getListScheduleOperation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getListScheduleOperation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getListScheduleOperation(soap, "ns1:getListScheduleOperation", &a->ns1__getListScheduleOperation, ""))
				{	soap_flag_ns1__getListScheduleOperation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getListScheduleOperation(struct soap *soap, const struct __ns1__getListScheduleOperation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getListScheduleOperation(soap, tag?tag:"-ns1:getListScheduleOperation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getListScheduleOperation * SOAP_FMAC4 soap_get___ns1__getListScheduleOperation(struct soap *soap, struct __ns1__getListScheduleOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getListScheduleOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getListScheduleOperation * SOAP_FMAC2 soap_instantiate___ns1__getListScheduleOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getListScheduleOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getListScheduleOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getListScheduleOperation);
		if (size)
			*size = sizeof(struct __ns1__getListScheduleOperation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getListScheduleOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getListScheduleOperation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getListScheduleOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getListScheduleOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getListScheduleOperation %p -> %p\n", q, p));
	*(struct __ns1__getListScheduleOperation*)p = *(struct __ns1__getListScheduleOperation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__addDayScheduleOperation(struct soap *soap, struct __ns1__addDayScheduleOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__addDayScheduleOperation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__addDayScheduleOperation(struct soap *soap, const struct __ns1__addDayScheduleOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__addDayScheduleOperation(soap, &a->ns1__addDayScheduleOperation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__addDayScheduleOperation(struct soap *soap, const char *tag, int id, const struct __ns1__addDayScheduleOperation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__addDayScheduleOperation(soap, "ns1:addDayScheduleOperation", -1, &a->ns1__addDayScheduleOperation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addDayScheduleOperation * SOAP_FMAC4 soap_in___ns1__addDayScheduleOperation(struct soap *soap, const char *tag, struct __ns1__addDayScheduleOperation *a, const char *type)
{
	size_t soap_flag_ns1__addDayScheduleOperation = 1;
	short soap_flag;
	a = (struct __ns1__addDayScheduleOperation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__addDayScheduleOperation, sizeof(struct __ns1__addDayScheduleOperation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__addDayScheduleOperation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__addDayScheduleOperation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__addDayScheduleOperation(soap, "ns1:addDayScheduleOperation", &a->ns1__addDayScheduleOperation, ""))
				{	soap_flag_ns1__addDayScheduleOperation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__addDayScheduleOperation(struct soap *soap, const struct __ns1__addDayScheduleOperation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__addDayScheduleOperation(soap, tag?tag:"-ns1:addDayScheduleOperation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addDayScheduleOperation * SOAP_FMAC4 soap_get___ns1__addDayScheduleOperation(struct soap *soap, struct __ns1__addDayScheduleOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__addDayScheduleOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__addDayScheduleOperation * SOAP_FMAC2 soap_instantiate___ns1__addDayScheduleOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__addDayScheduleOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__addDayScheduleOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__addDayScheduleOperation);
		if (size)
			*size = sizeof(struct __ns1__addDayScheduleOperation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__addDayScheduleOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__addDayScheduleOperation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__addDayScheduleOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__addDayScheduleOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__addDayScheduleOperation %p -> %p\n", q, p));
	*(struct __ns1__addDayScheduleOperation*)p = *(struct __ns1__addDayScheduleOperation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__removeDayScheduleOperation(struct soap *soap, struct __ns1__removeDayScheduleOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__removeDayScheduleOperation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__removeDayScheduleOperation(struct soap *soap, const struct __ns1__removeDayScheduleOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__removeDayScheduleOperation(soap, &a->ns1__removeDayScheduleOperation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__removeDayScheduleOperation(struct soap *soap, const char *tag, int id, const struct __ns1__removeDayScheduleOperation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__removeDayScheduleOperation(soap, "ns1:removeDayScheduleOperation", -1, &a->ns1__removeDayScheduleOperation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeDayScheduleOperation * SOAP_FMAC4 soap_in___ns1__removeDayScheduleOperation(struct soap *soap, const char *tag, struct __ns1__removeDayScheduleOperation *a, const char *type)
{
	size_t soap_flag_ns1__removeDayScheduleOperation = 1;
	short soap_flag;
	a = (struct __ns1__removeDayScheduleOperation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__removeDayScheduleOperation, sizeof(struct __ns1__removeDayScheduleOperation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__removeDayScheduleOperation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__removeDayScheduleOperation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__removeDayScheduleOperation(soap, "ns1:removeDayScheduleOperation", &a->ns1__removeDayScheduleOperation, ""))
				{	soap_flag_ns1__removeDayScheduleOperation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__removeDayScheduleOperation(struct soap *soap, const struct __ns1__removeDayScheduleOperation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__removeDayScheduleOperation(soap, tag?tag:"-ns1:removeDayScheduleOperation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeDayScheduleOperation * SOAP_FMAC4 soap_get___ns1__removeDayScheduleOperation(struct soap *soap, struct __ns1__removeDayScheduleOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__removeDayScheduleOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__removeDayScheduleOperation * SOAP_FMAC2 soap_instantiate___ns1__removeDayScheduleOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__removeDayScheduleOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__removeDayScheduleOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeDayScheduleOperation);
		if (size)
			*size = sizeof(struct __ns1__removeDayScheduleOperation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeDayScheduleOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__removeDayScheduleOperation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__removeDayScheduleOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__removeDayScheduleOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__removeDayScheduleOperation %p -> %p\n", q, p));
	*(struct __ns1__removeDayScheduleOperation*)p = *(struct __ns1__removeDayScheduleOperation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__editDayScheduleOperation(struct soap *soap, struct __ns1__editDayScheduleOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__editDayScheduleOperation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__editDayScheduleOperation(struct soap *soap, const struct __ns1__editDayScheduleOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__editDayScheduleOperation(soap, &a->ns1__editDayScheduleOperation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__editDayScheduleOperation(struct soap *soap, const char *tag, int id, const struct __ns1__editDayScheduleOperation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__editDayScheduleOperation(soap, "ns1:editDayScheduleOperation", -1, &a->ns1__editDayScheduleOperation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__editDayScheduleOperation * SOAP_FMAC4 soap_in___ns1__editDayScheduleOperation(struct soap *soap, const char *tag, struct __ns1__editDayScheduleOperation *a, const char *type)
{
	size_t soap_flag_ns1__editDayScheduleOperation = 1;
	short soap_flag;
	a = (struct __ns1__editDayScheduleOperation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__editDayScheduleOperation, sizeof(struct __ns1__editDayScheduleOperation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__editDayScheduleOperation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__editDayScheduleOperation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__editDayScheduleOperation(soap, "ns1:editDayScheduleOperation", &a->ns1__editDayScheduleOperation, ""))
				{	soap_flag_ns1__editDayScheduleOperation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__editDayScheduleOperation(struct soap *soap, const struct __ns1__editDayScheduleOperation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__editDayScheduleOperation(soap, tag?tag:"-ns1:editDayScheduleOperation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__editDayScheduleOperation * SOAP_FMAC4 soap_get___ns1__editDayScheduleOperation(struct soap *soap, struct __ns1__editDayScheduleOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__editDayScheduleOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__editDayScheduleOperation * SOAP_FMAC2 soap_instantiate___ns1__editDayScheduleOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__editDayScheduleOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__editDayScheduleOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__editDayScheduleOperation);
		if (size)
			*size = sizeof(struct __ns1__editDayScheduleOperation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__editDayScheduleOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__editDayScheduleOperation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__editDayScheduleOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__editDayScheduleOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__editDayScheduleOperation %p -> %p\n", q, p));
	*(struct __ns1__editDayScheduleOperation*)p = *(struct __ns1__editDayScheduleOperation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getDayScheduleOperation(struct soap *soap, struct __ns1__getDayScheduleOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getDayScheduleOperation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getDayScheduleOperation(struct soap *soap, const struct __ns1__getDayScheduleOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getDayScheduleOperation(soap, &a->ns1__getDayScheduleOperation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getDayScheduleOperation(struct soap *soap, const char *tag, int id, const struct __ns1__getDayScheduleOperation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getDayScheduleOperation(soap, "ns1:getDayScheduleOperation", -1, &a->ns1__getDayScheduleOperation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getDayScheduleOperation * SOAP_FMAC4 soap_in___ns1__getDayScheduleOperation(struct soap *soap, const char *tag, struct __ns1__getDayScheduleOperation *a, const char *type)
{
	size_t soap_flag_ns1__getDayScheduleOperation = 1;
	short soap_flag;
	a = (struct __ns1__getDayScheduleOperation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getDayScheduleOperation, sizeof(struct __ns1__getDayScheduleOperation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getDayScheduleOperation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getDayScheduleOperation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getDayScheduleOperation(soap, "ns1:getDayScheduleOperation", &a->ns1__getDayScheduleOperation, ""))
				{	soap_flag_ns1__getDayScheduleOperation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getDayScheduleOperation(struct soap *soap, const struct __ns1__getDayScheduleOperation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getDayScheduleOperation(soap, tag?tag:"-ns1:getDayScheduleOperation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getDayScheduleOperation * SOAP_FMAC4 soap_get___ns1__getDayScheduleOperation(struct soap *soap, struct __ns1__getDayScheduleOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getDayScheduleOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getDayScheduleOperation * SOAP_FMAC2 soap_instantiate___ns1__getDayScheduleOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getDayScheduleOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getDayScheduleOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getDayScheduleOperation);
		if (size)
			*size = sizeof(struct __ns1__getDayScheduleOperation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getDayScheduleOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getDayScheduleOperation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getDayScheduleOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getDayScheduleOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getDayScheduleOperation %p -> %p\n", q, p));
	*(struct __ns1__getDayScheduleOperation*)p = *(struct __ns1__getDayScheduleOperation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__editProgramOperation(struct soap *soap, struct __ns1__editProgramOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__editProgramOperation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__editProgramOperation(struct soap *soap, const struct __ns1__editProgramOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__editProgramOperation(soap, &a->ns1__editProgramOperation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__editProgramOperation(struct soap *soap, const char *tag, int id, const struct __ns1__editProgramOperation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__editProgramOperation(soap, "ns1:editProgramOperation", -1, &a->ns1__editProgramOperation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__editProgramOperation * SOAP_FMAC4 soap_in___ns1__editProgramOperation(struct soap *soap, const char *tag, struct __ns1__editProgramOperation *a, const char *type)
{
	size_t soap_flag_ns1__editProgramOperation = 1;
	short soap_flag;
	a = (struct __ns1__editProgramOperation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__editProgramOperation, sizeof(struct __ns1__editProgramOperation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__editProgramOperation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__editProgramOperation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__editProgramOperation(soap, "ns1:editProgramOperation", &a->ns1__editProgramOperation, ""))
				{	soap_flag_ns1__editProgramOperation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__editProgramOperation(struct soap *soap, const struct __ns1__editProgramOperation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__editProgramOperation(soap, tag?tag:"-ns1:editProgramOperation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__editProgramOperation * SOAP_FMAC4 soap_get___ns1__editProgramOperation(struct soap *soap, struct __ns1__editProgramOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__editProgramOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__editProgramOperation * SOAP_FMAC2 soap_instantiate___ns1__editProgramOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__editProgramOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__editProgramOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__editProgramOperation);
		if (size)
			*size = sizeof(struct __ns1__editProgramOperation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__editProgramOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__editProgramOperation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__editProgramOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__editProgramOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__editProgramOperation %p -> %p\n", q, p));
	*(struct __ns1__editProgramOperation*)p = *(struct __ns1__editProgramOperation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getProgramOperation(struct soap *soap, struct __ns1__getProgramOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getProgramOperation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getProgramOperation(struct soap *soap, const struct __ns1__getProgramOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getProgramOperation(soap, &a->ns1__getProgramOperation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getProgramOperation(struct soap *soap, const char *tag, int id, const struct __ns1__getProgramOperation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getProgramOperation(soap, "ns1:getProgramOperation", -1, &a->ns1__getProgramOperation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getProgramOperation * SOAP_FMAC4 soap_in___ns1__getProgramOperation(struct soap *soap, const char *tag, struct __ns1__getProgramOperation *a, const char *type)
{
	size_t soap_flag_ns1__getProgramOperation = 1;
	short soap_flag;
	a = (struct __ns1__getProgramOperation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getProgramOperation, sizeof(struct __ns1__getProgramOperation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getProgramOperation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getProgramOperation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getProgramOperation(soap, "ns1:getProgramOperation", &a->ns1__getProgramOperation, ""))
				{	soap_flag_ns1__getProgramOperation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getProgramOperation(struct soap *soap, const struct __ns1__getProgramOperation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getProgramOperation(soap, tag?tag:"-ns1:getProgramOperation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getProgramOperation * SOAP_FMAC4 soap_get___ns1__getProgramOperation(struct soap *soap, struct __ns1__getProgramOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getProgramOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getProgramOperation * SOAP_FMAC2 soap_instantiate___ns1__getProgramOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getProgramOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getProgramOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getProgramOperation);
		if (size)
			*size = sizeof(struct __ns1__getProgramOperation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getProgramOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getProgramOperation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getProgramOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getProgramOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getProgramOperation %p -> %p\n", q, p));
	*(struct __ns1__getProgramOperation*)p = *(struct __ns1__getProgramOperation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__editUserByUserOperation(struct soap *soap, struct __ns1__editUserByUserOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__editUserByUserOperation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__editUserByUserOperation(struct soap *soap, const struct __ns1__editUserByUserOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__editUserByUserOperation(soap, &a->ns1__editUserByUserOperation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__editUserByUserOperation(struct soap *soap, const char *tag, int id, const struct __ns1__editUserByUserOperation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__editUserByUserOperation(soap, "ns1:editUserByUserOperation", -1, &a->ns1__editUserByUserOperation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__editUserByUserOperation * SOAP_FMAC4 soap_in___ns1__editUserByUserOperation(struct soap *soap, const char *tag, struct __ns1__editUserByUserOperation *a, const char *type)
{
	size_t soap_flag_ns1__editUserByUserOperation = 1;
	short soap_flag;
	a = (struct __ns1__editUserByUserOperation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__editUserByUserOperation, sizeof(struct __ns1__editUserByUserOperation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__editUserByUserOperation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__editUserByUserOperation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__editUserByUserOperation(soap, "ns1:editUserByUserOperation", &a->ns1__editUserByUserOperation, ""))
				{	soap_flag_ns1__editUserByUserOperation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__editUserByUserOperation(struct soap *soap, const struct __ns1__editUserByUserOperation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__editUserByUserOperation(soap, tag?tag:"-ns1:editUserByUserOperation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__editUserByUserOperation * SOAP_FMAC4 soap_get___ns1__editUserByUserOperation(struct soap *soap, struct __ns1__editUserByUserOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__editUserByUserOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__editUserByUserOperation * SOAP_FMAC2 soap_instantiate___ns1__editUserByUserOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__editUserByUserOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__editUserByUserOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__editUserByUserOperation);
		if (size)
			*size = sizeof(struct __ns1__editUserByUserOperation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__editUserByUserOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__editUserByUserOperation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__editUserByUserOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__editUserByUserOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__editUserByUserOperation %p -> %p\n", q, p));
	*(struct __ns1__editUserByUserOperation*)p = *(struct __ns1__editUserByUserOperation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__removeUserOperation(struct soap *soap, struct __ns1__removeUserOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__removeUserOperation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__removeUserOperation(struct soap *soap, const struct __ns1__removeUserOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__removeUserOperation(soap, &a->ns1__removeUserOperation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__removeUserOperation(struct soap *soap, const char *tag, int id, const struct __ns1__removeUserOperation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__removeUserOperation(soap, "ns1:removeUserOperation", -1, &a->ns1__removeUserOperation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeUserOperation * SOAP_FMAC4 soap_in___ns1__removeUserOperation(struct soap *soap, const char *tag, struct __ns1__removeUserOperation *a, const char *type)
{
	size_t soap_flag_ns1__removeUserOperation = 1;
	short soap_flag;
	a = (struct __ns1__removeUserOperation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__removeUserOperation, sizeof(struct __ns1__removeUserOperation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__removeUserOperation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__removeUserOperation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__removeUserOperation(soap, "ns1:removeUserOperation", &a->ns1__removeUserOperation, ""))
				{	soap_flag_ns1__removeUserOperation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__removeUserOperation(struct soap *soap, const struct __ns1__removeUserOperation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__removeUserOperation(soap, tag?tag:"-ns1:removeUserOperation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeUserOperation * SOAP_FMAC4 soap_get___ns1__removeUserOperation(struct soap *soap, struct __ns1__removeUserOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__removeUserOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__removeUserOperation * SOAP_FMAC2 soap_instantiate___ns1__removeUserOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__removeUserOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__removeUserOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeUserOperation);
		if (size)
			*size = sizeof(struct __ns1__removeUserOperation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeUserOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__removeUserOperation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__removeUserOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__removeUserOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__removeUserOperation %p -> %p\n", q, p));
	*(struct __ns1__removeUserOperation*)p = *(struct __ns1__removeUserOperation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__editUserOperation(struct soap *soap, struct __ns1__editUserOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__editUserOperation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__editUserOperation(struct soap *soap, const struct __ns1__editUserOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__editUserOperation(soap, &a->ns1__editUserOperation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__editUserOperation(struct soap *soap, const char *tag, int id, const struct __ns1__editUserOperation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__editUserOperation(soap, "ns1:editUserOperation", -1, &a->ns1__editUserOperation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__editUserOperation * SOAP_FMAC4 soap_in___ns1__editUserOperation(struct soap *soap, const char *tag, struct __ns1__editUserOperation *a, const char *type)
{
	size_t soap_flag_ns1__editUserOperation = 1;
	short soap_flag;
	a = (struct __ns1__editUserOperation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__editUserOperation, sizeof(struct __ns1__editUserOperation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__editUserOperation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__editUserOperation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__editUserOperation(soap, "ns1:editUserOperation", &a->ns1__editUserOperation, ""))
				{	soap_flag_ns1__editUserOperation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__editUserOperation(struct soap *soap, const struct __ns1__editUserOperation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__editUserOperation(soap, tag?tag:"-ns1:editUserOperation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__editUserOperation * SOAP_FMAC4 soap_get___ns1__editUserOperation(struct soap *soap, struct __ns1__editUserOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__editUserOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__editUserOperation * SOAP_FMAC2 soap_instantiate___ns1__editUserOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__editUserOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__editUserOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__editUserOperation);
		if (size)
			*size = sizeof(struct __ns1__editUserOperation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__editUserOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__editUserOperation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__editUserOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__editUserOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__editUserOperation %p -> %p\n", q, p));
	*(struct __ns1__editUserOperation*)p = *(struct __ns1__editUserOperation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__addUserOperation(struct soap *soap, struct __ns1__addUserOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__addUserOperation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__addUserOperation(struct soap *soap, const struct __ns1__addUserOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__addUserOperation(soap, &a->ns1__addUserOperation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__addUserOperation(struct soap *soap, const char *tag, int id, const struct __ns1__addUserOperation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__addUserOperation(soap, "ns1:addUserOperation", -1, &a->ns1__addUserOperation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addUserOperation * SOAP_FMAC4 soap_in___ns1__addUserOperation(struct soap *soap, const char *tag, struct __ns1__addUserOperation *a, const char *type)
{
	size_t soap_flag_ns1__addUserOperation = 1;
	short soap_flag;
	a = (struct __ns1__addUserOperation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__addUserOperation, sizeof(struct __ns1__addUserOperation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__addUserOperation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__addUserOperation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__addUserOperation(soap, "ns1:addUserOperation", &a->ns1__addUserOperation, ""))
				{	soap_flag_ns1__addUserOperation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__addUserOperation(struct soap *soap, const struct __ns1__addUserOperation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__addUserOperation(soap, tag?tag:"-ns1:addUserOperation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addUserOperation * SOAP_FMAC4 soap_get___ns1__addUserOperation(struct soap *soap, struct __ns1__addUserOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__addUserOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__addUserOperation * SOAP_FMAC2 soap_instantiate___ns1__addUserOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__addUserOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__addUserOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__addUserOperation);
		if (size)
			*size = sizeof(struct __ns1__addUserOperation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__addUserOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__addUserOperation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__addUserOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__addUserOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__addUserOperation %p -> %p\n", q, p));
	*(struct __ns1__addUserOperation*)p = *(struct __ns1__addUserOperation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getAllUserOperation(struct soap *soap, struct __ns1__getAllUserOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getAllUserOperation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getAllUserOperation(struct soap *soap, const struct __ns1__getAllUserOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getAllUserOperation(soap, &a->ns1__getAllUserOperation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getAllUserOperation(struct soap *soap, const char *tag, int id, const struct __ns1__getAllUserOperation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getAllUserOperation(soap, "ns1:getAllUserOperation", -1, &a->ns1__getAllUserOperation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAllUserOperation * SOAP_FMAC4 soap_in___ns1__getAllUserOperation(struct soap *soap, const char *tag, struct __ns1__getAllUserOperation *a, const char *type)
{
	size_t soap_flag_ns1__getAllUserOperation = 1;
	short soap_flag;
	a = (struct __ns1__getAllUserOperation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getAllUserOperation, sizeof(struct __ns1__getAllUserOperation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getAllUserOperation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getAllUserOperation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getAllUserOperation(soap, "ns1:getAllUserOperation", &a->ns1__getAllUserOperation, ""))
				{	soap_flag_ns1__getAllUserOperation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getAllUserOperation(struct soap *soap, const struct __ns1__getAllUserOperation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getAllUserOperation(soap, tag?tag:"-ns1:getAllUserOperation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAllUserOperation * SOAP_FMAC4 soap_get___ns1__getAllUserOperation(struct soap *soap, struct __ns1__getAllUserOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getAllUserOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getAllUserOperation * SOAP_FMAC2 soap_instantiate___ns1__getAllUserOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getAllUserOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getAllUserOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getAllUserOperation);
		if (size)
			*size = sizeof(struct __ns1__getAllUserOperation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getAllUserOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getAllUserOperation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getAllUserOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getAllUserOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getAllUserOperation %p -> %p\n", q, p));
	*(struct __ns1__getAllUserOperation*)p = *(struct __ns1__getAllUserOperation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__removeZoneOperation(struct soap *soap, struct __ns1__removeZoneOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__removeZoneOperation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__removeZoneOperation(struct soap *soap, const struct __ns1__removeZoneOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__removeZoneOperation(soap, &a->ns1__removeZoneOperation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__removeZoneOperation(struct soap *soap, const char *tag, int id, const struct __ns1__removeZoneOperation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__removeZoneOperation(soap, "ns1:removeZoneOperation", -1, &a->ns1__removeZoneOperation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeZoneOperation * SOAP_FMAC4 soap_in___ns1__removeZoneOperation(struct soap *soap, const char *tag, struct __ns1__removeZoneOperation *a, const char *type)
{
	size_t soap_flag_ns1__removeZoneOperation = 1;
	short soap_flag;
	a = (struct __ns1__removeZoneOperation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__removeZoneOperation, sizeof(struct __ns1__removeZoneOperation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__removeZoneOperation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__removeZoneOperation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__removeZoneOperation(soap, "ns1:removeZoneOperation", &a->ns1__removeZoneOperation, ""))
				{	soap_flag_ns1__removeZoneOperation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__removeZoneOperation(struct soap *soap, const struct __ns1__removeZoneOperation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__removeZoneOperation(soap, tag?tag:"-ns1:removeZoneOperation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeZoneOperation * SOAP_FMAC4 soap_get___ns1__removeZoneOperation(struct soap *soap, struct __ns1__removeZoneOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__removeZoneOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__removeZoneOperation * SOAP_FMAC2 soap_instantiate___ns1__removeZoneOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__removeZoneOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__removeZoneOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeZoneOperation);
		if (size)
			*size = sizeof(struct __ns1__removeZoneOperation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeZoneOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__removeZoneOperation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__removeZoneOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__removeZoneOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__removeZoneOperation %p -> %p\n", q, p));
	*(struct __ns1__removeZoneOperation*)p = *(struct __ns1__removeZoneOperation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__editZoneOperation(struct soap *soap, struct __ns1__editZoneOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__editZoneOperation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__editZoneOperation(struct soap *soap, const struct __ns1__editZoneOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__editZoneOperation(soap, &a->ns1__editZoneOperation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__editZoneOperation(struct soap *soap, const char *tag, int id, const struct __ns1__editZoneOperation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__editZoneOperation(soap, "ns1:editZoneOperation", -1, &a->ns1__editZoneOperation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__editZoneOperation * SOAP_FMAC4 soap_in___ns1__editZoneOperation(struct soap *soap, const char *tag, struct __ns1__editZoneOperation *a, const char *type)
{
	size_t soap_flag_ns1__editZoneOperation = 1;
	short soap_flag;
	a = (struct __ns1__editZoneOperation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__editZoneOperation, sizeof(struct __ns1__editZoneOperation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__editZoneOperation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__editZoneOperation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__editZoneOperation(soap, "ns1:editZoneOperation", &a->ns1__editZoneOperation, ""))
				{	soap_flag_ns1__editZoneOperation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__editZoneOperation(struct soap *soap, const struct __ns1__editZoneOperation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__editZoneOperation(soap, tag?tag:"-ns1:editZoneOperation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__editZoneOperation * SOAP_FMAC4 soap_get___ns1__editZoneOperation(struct soap *soap, struct __ns1__editZoneOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__editZoneOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__editZoneOperation * SOAP_FMAC2 soap_instantiate___ns1__editZoneOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__editZoneOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__editZoneOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__editZoneOperation);
		if (size)
			*size = sizeof(struct __ns1__editZoneOperation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__editZoneOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__editZoneOperation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__editZoneOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__editZoneOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__editZoneOperation %p -> %p\n", q, p));
	*(struct __ns1__editZoneOperation*)p = *(struct __ns1__editZoneOperation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__addZoneOperation(struct soap *soap, struct __ns1__addZoneOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__addZoneOperation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__addZoneOperation(struct soap *soap, const struct __ns1__addZoneOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__addZoneOperation(soap, &a->ns1__addZoneOperation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__addZoneOperation(struct soap *soap, const char *tag, int id, const struct __ns1__addZoneOperation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__addZoneOperation(soap, "ns1:addZoneOperation", -1, &a->ns1__addZoneOperation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addZoneOperation * SOAP_FMAC4 soap_in___ns1__addZoneOperation(struct soap *soap, const char *tag, struct __ns1__addZoneOperation *a, const char *type)
{
	size_t soap_flag_ns1__addZoneOperation = 1;
	short soap_flag;
	a = (struct __ns1__addZoneOperation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__addZoneOperation, sizeof(struct __ns1__addZoneOperation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__addZoneOperation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__addZoneOperation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__addZoneOperation(soap, "ns1:addZoneOperation", &a->ns1__addZoneOperation, ""))
				{	soap_flag_ns1__addZoneOperation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__addZoneOperation(struct soap *soap, const struct __ns1__addZoneOperation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__addZoneOperation(soap, tag?tag:"-ns1:addZoneOperation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addZoneOperation * SOAP_FMAC4 soap_get___ns1__addZoneOperation(struct soap *soap, struct __ns1__addZoneOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__addZoneOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__addZoneOperation * SOAP_FMAC2 soap_instantiate___ns1__addZoneOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__addZoneOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__addZoneOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__addZoneOperation);
		if (size)
			*size = sizeof(struct __ns1__addZoneOperation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__addZoneOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__addZoneOperation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__addZoneOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__addZoneOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__addZoneOperation %p -> %p\n", q, p));
	*(struct __ns1__addZoneOperation*)p = *(struct __ns1__addZoneOperation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SetDcuToZoneOperation(struct soap *soap, struct __ns1__SetDcuToZoneOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SetDcuToZoneOperation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SetDcuToZoneOperation(struct soap *soap, const struct __ns1__SetDcuToZoneOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__SetDcuToZoneOperation(soap, &a->ns1__SetDcuToZoneOperation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SetDcuToZoneOperation(struct soap *soap, const char *tag, int id, const struct __ns1__SetDcuToZoneOperation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__SetDcuToZoneOperation(soap, "ns1:SetDcuToZoneOperation", -1, &a->ns1__SetDcuToZoneOperation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SetDcuToZoneOperation * SOAP_FMAC4 soap_in___ns1__SetDcuToZoneOperation(struct soap *soap, const char *tag, struct __ns1__SetDcuToZoneOperation *a, const char *type)
{
	size_t soap_flag_ns1__SetDcuToZoneOperation = 1;
	short soap_flag;
	a = (struct __ns1__SetDcuToZoneOperation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SetDcuToZoneOperation, sizeof(struct __ns1__SetDcuToZoneOperation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SetDcuToZoneOperation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SetDcuToZoneOperation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SetDcuToZoneOperation(soap, "ns1:SetDcuToZoneOperation", &a->ns1__SetDcuToZoneOperation, ""))
				{	soap_flag_ns1__SetDcuToZoneOperation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SetDcuToZoneOperation(struct soap *soap, const struct __ns1__SetDcuToZoneOperation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__SetDcuToZoneOperation(soap, tag?tag:"-ns1:SetDcuToZoneOperation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SetDcuToZoneOperation * SOAP_FMAC4 soap_get___ns1__SetDcuToZoneOperation(struct soap *soap, struct __ns1__SetDcuToZoneOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SetDcuToZoneOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__SetDcuToZoneOperation * SOAP_FMAC2 soap_instantiate___ns1__SetDcuToZoneOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SetDcuToZoneOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__SetDcuToZoneOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__SetDcuToZoneOperation);
		if (size)
			*size = sizeof(struct __ns1__SetDcuToZoneOperation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__SetDcuToZoneOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__SetDcuToZoneOperation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__SetDcuToZoneOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__SetDcuToZoneOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__SetDcuToZoneOperation %p -> %p\n", q, p));
	*(struct __ns1__SetDcuToZoneOperation*)p = *(struct __ns1__SetDcuToZoneOperation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getAllZoneForUserOperation(struct soap *soap, struct __ns1__getAllZoneForUserOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getAllZoneForUserOperation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getAllZoneForUserOperation(struct soap *soap, const struct __ns1__getAllZoneForUserOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getAllZoneForUserOperation(soap, &a->ns1__getAllZoneForUserOperation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getAllZoneForUserOperation(struct soap *soap, const char *tag, int id, const struct __ns1__getAllZoneForUserOperation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getAllZoneForUserOperation(soap, "ns1:getAllZoneForUserOperation", -1, &a->ns1__getAllZoneForUserOperation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAllZoneForUserOperation * SOAP_FMAC4 soap_in___ns1__getAllZoneForUserOperation(struct soap *soap, const char *tag, struct __ns1__getAllZoneForUserOperation *a, const char *type)
{
	size_t soap_flag_ns1__getAllZoneForUserOperation = 1;
	short soap_flag;
	a = (struct __ns1__getAllZoneForUserOperation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getAllZoneForUserOperation, sizeof(struct __ns1__getAllZoneForUserOperation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getAllZoneForUserOperation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getAllZoneForUserOperation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getAllZoneForUserOperation(soap, "ns1:getAllZoneForUserOperation", &a->ns1__getAllZoneForUserOperation, ""))
				{	soap_flag_ns1__getAllZoneForUserOperation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getAllZoneForUserOperation(struct soap *soap, const struct __ns1__getAllZoneForUserOperation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getAllZoneForUserOperation(soap, tag?tag:"-ns1:getAllZoneForUserOperation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAllZoneForUserOperation * SOAP_FMAC4 soap_get___ns1__getAllZoneForUserOperation(struct soap *soap, struct __ns1__getAllZoneForUserOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getAllZoneForUserOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getAllZoneForUserOperation * SOAP_FMAC2 soap_instantiate___ns1__getAllZoneForUserOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getAllZoneForUserOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getAllZoneForUserOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getAllZoneForUserOperation);
		if (size)
			*size = sizeof(struct __ns1__getAllZoneForUserOperation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getAllZoneForUserOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getAllZoneForUserOperation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getAllZoneForUserOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getAllZoneForUserOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getAllZoneForUserOperation %p -> %p\n", q, p));
	*(struct __ns1__getAllZoneForUserOperation*)p = *(struct __ns1__getAllZoneForUserOperation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getAllZoneOperation(struct soap *soap, struct __ns1__getAllZoneOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getAllZoneOperation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getAllZoneOperation(struct soap *soap, const struct __ns1__getAllZoneOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getAllZoneOperation(soap, &a->ns1__getAllZoneOperation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getAllZoneOperation(struct soap *soap, const char *tag, int id, const struct __ns1__getAllZoneOperation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getAllZoneOperation(soap, "ns1:getAllZoneOperation", -1, &a->ns1__getAllZoneOperation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAllZoneOperation * SOAP_FMAC4 soap_in___ns1__getAllZoneOperation(struct soap *soap, const char *tag, struct __ns1__getAllZoneOperation *a, const char *type)
{
	size_t soap_flag_ns1__getAllZoneOperation = 1;
	short soap_flag;
	a = (struct __ns1__getAllZoneOperation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getAllZoneOperation, sizeof(struct __ns1__getAllZoneOperation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getAllZoneOperation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getAllZoneOperation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getAllZoneOperation(soap, "ns1:getAllZoneOperation", &a->ns1__getAllZoneOperation, ""))
				{	soap_flag_ns1__getAllZoneOperation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getAllZoneOperation(struct soap *soap, const struct __ns1__getAllZoneOperation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getAllZoneOperation(soap, tag?tag:"-ns1:getAllZoneOperation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAllZoneOperation * SOAP_FMAC4 soap_get___ns1__getAllZoneOperation(struct soap *soap, struct __ns1__getAllZoneOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getAllZoneOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getAllZoneOperation * SOAP_FMAC2 soap_instantiate___ns1__getAllZoneOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getAllZoneOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getAllZoneOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getAllZoneOperation);
		if (size)
			*size = sizeof(struct __ns1__getAllZoneOperation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getAllZoneOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getAllZoneOperation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getAllZoneOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getAllZoneOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getAllZoneOperation %p -> %p\n", q, p));
	*(struct __ns1__getAllZoneOperation*)p = *(struct __ns1__getAllZoneOperation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__deleteUserLogOperation(struct soap *soap, struct __ns1__deleteUserLogOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__deleteUserLogOperation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__deleteUserLogOperation(struct soap *soap, const struct __ns1__deleteUserLogOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__deleteUserLogOperation(soap, &a->ns1__deleteUserLogOperation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__deleteUserLogOperation(struct soap *soap, const char *tag, int id, const struct __ns1__deleteUserLogOperation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__deleteUserLogOperation(soap, "ns1:deleteUserLogOperation", -1, &a->ns1__deleteUserLogOperation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteUserLogOperation * SOAP_FMAC4 soap_in___ns1__deleteUserLogOperation(struct soap *soap, const char *tag, struct __ns1__deleteUserLogOperation *a, const char *type)
{
	size_t soap_flag_ns1__deleteUserLogOperation = 1;
	short soap_flag;
	a = (struct __ns1__deleteUserLogOperation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__deleteUserLogOperation, sizeof(struct __ns1__deleteUserLogOperation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__deleteUserLogOperation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__deleteUserLogOperation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__deleteUserLogOperation(soap, "ns1:deleteUserLogOperation", &a->ns1__deleteUserLogOperation, ""))
				{	soap_flag_ns1__deleteUserLogOperation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__deleteUserLogOperation(struct soap *soap, const struct __ns1__deleteUserLogOperation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__deleteUserLogOperation(soap, tag?tag:"-ns1:deleteUserLogOperation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteUserLogOperation * SOAP_FMAC4 soap_get___ns1__deleteUserLogOperation(struct soap *soap, struct __ns1__deleteUserLogOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__deleteUserLogOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__deleteUserLogOperation * SOAP_FMAC2 soap_instantiate___ns1__deleteUserLogOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__deleteUserLogOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__deleteUserLogOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__deleteUserLogOperation);
		if (size)
			*size = sizeof(struct __ns1__deleteUserLogOperation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__deleteUserLogOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__deleteUserLogOperation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__deleteUserLogOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__deleteUserLogOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__deleteUserLogOperation %p -> %p\n", q, p));
	*(struct __ns1__deleteUserLogOperation*)p = *(struct __ns1__deleteUserLogOperation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getUserLogOperation(struct soap *soap, struct __ns1__getUserLogOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getUserLogOperation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getUserLogOperation(struct soap *soap, const struct __ns1__getUserLogOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getUserLogOperation(soap, &a->ns1__getUserLogOperation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getUserLogOperation(struct soap *soap, const char *tag, int id, const struct __ns1__getUserLogOperation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getUserLogOperation(soap, "ns1:getUserLogOperation", -1, &a->ns1__getUserLogOperation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getUserLogOperation * SOAP_FMAC4 soap_in___ns1__getUserLogOperation(struct soap *soap, const char *tag, struct __ns1__getUserLogOperation *a, const char *type)
{
	size_t soap_flag_ns1__getUserLogOperation = 1;
	short soap_flag;
	a = (struct __ns1__getUserLogOperation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getUserLogOperation, sizeof(struct __ns1__getUserLogOperation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getUserLogOperation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getUserLogOperation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getUserLogOperation(soap, "ns1:getUserLogOperation", &a->ns1__getUserLogOperation, ""))
				{	soap_flag_ns1__getUserLogOperation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getUserLogOperation(struct soap *soap, const struct __ns1__getUserLogOperation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getUserLogOperation(soap, tag?tag:"-ns1:getUserLogOperation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getUserLogOperation * SOAP_FMAC4 soap_get___ns1__getUserLogOperation(struct soap *soap, struct __ns1__getUserLogOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getUserLogOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getUserLogOperation * SOAP_FMAC2 soap_instantiate___ns1__getUserLogOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getUserLogOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getUserLogOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getUserLogOperation);
		if (size)
			*size = sizeof(struct __ns1__getUserLogOperation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getUserLogOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getUserLogOperation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getUserLogOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getUserLogOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getUserLogOperation %p -> %p\n", q, p));
	*(struct __ns1__getUserLogOperation*)p = *(struct __ns1__getUserLogOperation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__deleteEventLogOperation(struct soap *soap, struct __ns1__deleteEventLogOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__deleteEventLogOperation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__deleteEventLogOperation(struct soap *soap, const struct __ns1__deleteEventLogOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__deleteEventLogOperation(soap, &a->ns1__deleteEventLogOperation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__deleteEventLogOperation(struct soap *soap, const char *tag, int id, const struct __ns1__deleteEventLogOperation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__deleteEventLogOperation(soap, "ns1:deleteEventLogOperation", -1, &a->ns1__deleteEventLogOperation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteEventLogOperation * SOAP_FMAC4 soap_in___ns1__deleteEventLogOperation(struct soap *soap, const char *tag, struct __ns1__deleteEventLogOperation *a, const char *type)
{
	size_t soap_flag_ns1__deleteEventLogOperation = 1;
	short soap_flag;
	a = (struct __ns1__deleteEventLogOperation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__deleteEventLogOperation, sizeof(struct __ns1__deleteEventLogOperation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__deleteEventLogOperation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__deleteEventLogOperation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__deleteEventLogOperation(soap, "ns1:deleteEventLogOperation", &a->ns1__deleteEventLogOperation, ""))
				{	soap_flag_ns1__deleteEventLogOperation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__deleteEventLogOperation(struct soap *soap, const struct __ns1__deleteEventLogOperation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__deleteEventLogOperation(soap, tag?tag:"-ns1:deleteEventLogOperation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteEventLogOperation * SOAP_FMAC4 soap_get___ns1__deleteEventLogOperation(struct soap *soap, struct __ns1__deleteEventLogOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__deleteEventLogOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__deleteEventLogOperation * SOAP_FMAC2 soap_instantiate___ns1__deleteEventLogOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__deleteEventLogOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__deleteEventLogOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__deleteEventLogOperation);
		if (size)
			*size = sizeof(struct __ns1__deleteEventLogOperation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__deleteEventLogOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__deleteEventLogOperation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__deleteEventLogOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__deleteEventLogOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__deleteEventLogOperation %p -> %p\n", q, p));
	*(struct __ns1__deleteEventLogOperation*)p = *(struct __ns1__deleteEventLogOperation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__updateReadEventLogOperation(struct soap *soap, struct __ns1__updateReadEventLogOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__updateReadEventLogOperation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__updateReadEventLogOperation(struct soap *soap, const struct __ns1__updateReadEventLogOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__updateReadEventLogOperation(soap, &a->ns1__updateReadEventLogOperation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__updateReadEventLogOperation(struct soap *soap, const char *tag, int id, const struct __ns1__updateReadEventLogOperation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__updateReadEventLogOperation(soap, "ns1:updateReadEventLogOperation", -1, &a->ns1__updateReadEventLogOperation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updateReadEventLogOperation * SOAP_FMAC4 soap_in___ns1__updateReadEventLogOperation(struct soap *soap, const char *tag, struct __ns1__updateReadEventLogOperation *a, const char *type)
{
	size_t soap_flag_ns1__updateReadEventLogOperation = 1;
	short soap_flag;
	a = (struct __ns1__updateReadEventLogOperation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__updateReadEventLogOperation, sizeof(struct __ns1__updateReadEventLogOperation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__updateReadEventLogOperation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__updateReadEventLogOperation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__updateReadEventLogOperation(soap, "ns1:updateReadEventLogOperation", &a->ns1__updateReadEventLogOperation, ""))
				{	soap_flag_ns1__updateReadEventLogOperation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__updateReadEventLogOperation(struct soap *soap, const struct __ns1__updateReadEventLogOperation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__updateReadEventLogOperation(soap, tag?tag:"-ns1:updateReadEventLogOperation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updateReadEventLogOperation * SOAP_FMAC4 soap_get___ns1__updateReadEventLogOperation(struct soap *soap, struct __ns1__updateReadEventLogOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__updateReadEventLogOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__updateReadEventLogOperation * SOAP_FMAC2 soap_instantiate___ns1__updateReadEventLogOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__updateReadEventLogOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__updateReadEventLogOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__updateReadEventLogOperation);
		if (size)
			*size = sizeof(struct __ns1__updateReadEventLogOperation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__updateReadEventLogOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__updateReadEventLogOperation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__updateReadEventLogOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__updateReadEventLogOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__updateReadEventLogOperation %p -> %p\n", q, p));
	*(struct __ns1__updateReadEventLogOperation*)p = *(struct __ns1__updateReadEventLogOperation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getEventLogOperation(struct soap *soap, struct __ns1__getEventLogOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getEventLogOperation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getEventLogOperation(struct soap *soap, const struct __ns1__getEventLogOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getEventLogOperation(soap, &a->ns1__getEventLogOperation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getEventLogOperation(struct soap *soap, const char *tag, int id, const struct __ns1__getEventLogOperation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getEventLogOperation(soap, "ns1:getEventLogOperation", -1, &a->ns1__getEventLogOperation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getEventLogOperation * SOAP_FMAC4 soap_in___ns1__getEventLogOperation(struct soap *soap, const char *tag, struct __ns1__getEventLogOperation *a, const char *type)
{
	size_t soap_flag_ns1__getEventLogOperation = 1;
	short soap_flag;
	a = (struct __ns1__getEventLogOperation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getEventLogOperation, sizeof(struct __ns1__getEventLogOperation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getEventLogOperation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getEventLogOperation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getEventLogOperation(soap, "ns1:getEventLogOperation", &a->ns1__getEventLogOperation, ""))
				{	soap_flag_ns1__getEventLogOperation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getEventLogOperation(struct soap *soap, const struct __ns1__getEventLogOperation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getEventLogOperation(soap, tag?tag:"-ns1:getEventLogOperation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getEventLogOperation * SOAP_FMAC4 soap_get___ns1__getEventLogOperation(struct soap *soap, struct __ns1__getEventLogOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getEventLogOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getEventLogOperation * SOAP_FMAC2 soap_instantiate___ns1__getEventLogOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getEventLogOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getEventLogOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getEventLogOperation);
		if (size)
			*size = sizeof(struct __ns1__getEventLogOperation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getEventLogOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getEventLogOperation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getEventLogOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getEventLogOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getEventLogOperation %p -> %p\n", q, p));
	*(struct __ns1__getEventLogOperation*)p = *(struct __ns1__getEventLogOperation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__setProgramDcuOperation(struct soap *soap, struct __ns1__setProgramDcuOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__setProgramDcuOperation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__setProgramDcuOperation(struct soap *soap, const struct __ns1__setProgramDcuOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__setProgramDcuOperation(soap, &a->ns1__setProgramDcuOperation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__setProgramDcuOperation(struct soap *soap, const char *tag, int id, const struct __ns1__setProgramDcuOperation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__setProgramDcuOperation(soap, "ns1:setProgramDcuOperation", -1, &a->ns1__setProgramDcuOperation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setProgramDcuOperation * SOAP_FMAC4 soap_in___ns1__setProgramDcuOperation(struct soap *soap, const char *tag, struct __ns1__setProgramDcuOperation *a, const char *type)
{
	size_t soap_flag_ns1__setProgramDcuOperation = 1;
	short soap_flag;
	a = (struct __ns1__setProgramDcuOperation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__setProgramDcuOperation, sizeof(struct __ns1__setProgramDcuOperation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__setProgramDcuOperation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__setProgramDcuOperation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__setProgramDcuOperation(soap, "ns1:setProgramDcuOperation", &a->ns1__setProgramDcuOperation, ""))
				{	soap_flag_ns1__setProgramDcuOperation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__setProgramDcuOperation(struct soap *soap, const struct __ns1__setProgramDcuOperation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__setProgramDcuOperation(soap, tag?tag:"-ns1:setProgramDcuOperation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setProgramDcuOperation * SOAP_FMAC4 soap_get___ns1__setProgramDcuOperation(struct soap *soap, struct __ns1__setProgramDcuOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__setProgramDcuOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__setProgramDcuOperation * SOAP_FMAC2 soap_instantiate___ns1__setProgramDcuOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__setProgramDcuOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__setProgramDcuOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__setProgramDcuOperation);
		if (size)
			*size = sizeof(struct __ns1__setProgramDcuOperation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__setProgramDcuOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__setProgramDcuOperation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__setProgramDcuOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__setProgramDcuOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__setProgramDcuOperation %p -> %p\n", q, p));
	*(struct __ns1__setProgramDcuOperation*)p = *(struct __ns1__setProgramDcuOperation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__controlLineOperation(struct soap *soap, struct __ns1__controlLineOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__controlLineOperation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__controlLineOperation(struct soap *soap, const struct __ns1__controlLineOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__controlLineOperation(soap, &a->ns1__controlLineOperation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__controlLineOperation(struct soap *soap, const char *tag, int id, const struct __ns1__controlLineOperation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__controlLineOperation(soap, "ns1:controlLineOperation", -1, &a->ns1__controlLineOperation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__controlLineOperation * SOAP_FMAC4 soap_in___ns1__controlLineOperation(struct soap *soap, const char *tag, struct __ns1__controlLineOperation *a, const char *type)
{
	size_t soap_flag_ns1__controlLineOperation = 1;
	short soap_flag;
	a = (struct __ns1__controlLineOperation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__controlLineOperation, sizeof(struct __ns1__controlLineOperation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__controlLineOperation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__controlLineOperation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__controlLineOperation(soap, "ns1:controlLineOperation", &a->ns1__controlLineOperation, ""))
				{	soap_flag_ns1__controlLineOperation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__controlLineOperation(struct soap *soap, const struct __ns1__controlLineOperation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__controlLineOperation(soap, tag?tag:"-ns1:controlLineOperation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__controlLineOperation * SOAP_FMAC4 soap_get___ns1__controlLineOperation(struct soap *soap, struct __ns1__controlLineOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__controlLineOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__controlLineOperation * SOAP_FMAC2 soap_instantiate___ns1__controlLineOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__controlLineOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__controlLineOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__controlLineOperation);
		if (size)
			*size = sizeof(struct __ns1__controlLineOperation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__controlLineOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__controlLineOperation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__controlLineOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__controlLineOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__controlLineOperation %p -> %p\n", q, p));
	*(struct __ns1__controlLineOperation*)p = *(struct __ns1__controlLineOperation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__controlLcuOperation(struct soap *soap, struct __ns1__controlLcuOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__controlLcuOperation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__controlLcuOperation(struct soap *soap, const struct __ns1__controlLcuOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__controlLcuOperation(soap, &a->ns1__controlLcuOperation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__controlLcuOperation(struct soap *soap, const char *tag, int id, const struct __ns1__controlLcuOperation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__controlLcuOperation(soap, "ns1:controlLcuOperation", -1, &a->ns1__controlLcuOperation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__controlLcuOperation * SOAP_FMAC4 soap_in___ns1__controlLcuOperation(struct soap *soap, const char *tag, struct __ns1__controlLcuOperation *a, const char *type)
{
	size_t soap_flag_ns1__controlLcuOperation = 1;
	short soap_flag;
	a = (struct __ns1__controlLcuOperation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__controlLcuOperation, sizeof(struct __ns1__controlLcuOperation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__controlLcuOperation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__controlLcuOperation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__controlLcuOperation(soap, "ns1:controlLcuOperation", &a->ns1__controlLcuOperation, ""))
				{	soap_flag_ns1__controlLcuOperation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__controlLcuOperation(struct soap *soap, const struct __ns1__controlLcuOperation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__controlLcuOperation(soap, tag?tag:"-ns1:controlLcuOperation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__controlLcuOperation * SOAP_FMAC4 soap_get___ns1__controlLcuOperation(struct soap *soap, struct __ns1__controlLcuOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__controlLcuOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__controlLcuOperation * SOAP_FMAC2 soap_instantiate___ns1__controlLcuOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__controlLcuOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__controlLcuOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__controlLcuOperation);
		if (size)
			*size = sizeof(struct __ns1__controlLcuOperation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__controlLcuOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__controlLcuOperation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__controlLcuOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__controlLcuOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__controlLcuOperation %p -> %p\n", q, p));
	*(struct __ns1__controlLcuOperation*)p = *(struct __ns1__controlLcuOperation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__removeProgramOperation(struct soap *soap, struct __ns1__removeProgramOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__removeProgramOperation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__removeProgramOperation(struct soap *soap, const struct __ns1__removeProgramOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__removeProgramOperation(soap, &a->ns1__removeProgramOperation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__removeProgramOperation(struct soap *soap, const char *tag, int id, const struct __ns1__removeProgramOperation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__removeProgramOperation(soap, "ns1:removeProgramOperation", -1, &a->ns1__removeProgramOperation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeProgramOperation * SOAP_FMAC4 soap_in___ns1__removeProgramOperation(struct soap *soap, const char *tag, struct __ns1__removeProgramOperation *a, const char *type)
{
	size_t soap_flag_ns1__removeProgramOperation = 1;
	short soap_flag;
	a = (struct __ns1__removeProgramOperation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__removeProgramOperation, sizeof(struct __ns1__removeProgramOperation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__removeProgramOperation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__removeProgramOperation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__removeProgramOperation(soap, "ns1:removeProgramOperation", &a->ns1__removeProgramOperation, ""))
				{	soap_flag_ns1__removeProgramOperation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__removeProgramOperation(struct soap *soap, const struct __ns1__removeProgramOperation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__removeProgramOperation(soap, tag?tag:"-ns1:removeProgramOperation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeProgramOperation * SOAP_FMAC4 soap_get___ns1__removeProgramOperation(struct soap *soap, struct __ns1__removeProgramOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__removeProgramOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__removeProgramOperation * SOAP_FMAC2 soap_instantiate___ns1__removeProgramOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__removeProgramOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__removeProgramOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeProgramOperation);
		if (size)
			*size = sizeof(struct __ns1__removeProgramOperation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeProgramOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__removeProgramOperation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__removeProgramOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__removeProgramOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__removeProgramOperation %p -> %p\n", q, p));
	*(struct __ns1__removeProgramOperation*)p = *(struct __ns1__removeProgramOperation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__addProgramOperation(struct soap *soap, struct __ns1__addProgramOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__addProgramOperation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__addProgramOperation(struct soap *soap, const struct __ns1__addProgramOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__addProgramOperation(soap, &a->ns1__addProgramOperation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__addProgramOperation(struct soap *soap, const char *tag, int id, const struct __ns1__addProgramOperation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__addProgramOperation(soap, "ns1:addProgramOperation", -1, &a->ns1__addProgramOperation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addProgramOperation * SOAP_FMAC4 soap_in___ns1__addProgramOperation(struct soap *soap, const char *tag, struct __ns1__addProgramOperation *a, const char *type)
{
	size_t soap_flag_ns1__addProgramOperation = 1;
	short soap_flag;
	a = (struct __ns1__addProgramOperation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__addProgramOperation, sizeof(struct __ns1__addProgramOperation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__addProgramOperation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__addProgramOperation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__addProgramOperation(soap, "ns1:addProgramOperation", &a->ns1__addProgramOperation, ""))
				{	soap_flag_ns1__addProgramOperation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__addProgramOperation(struct soap *soap, const struct __ns1__addProgramOperation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__addProgramOperation(soap, tag?tag:"-ns1:addProgramOperation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addProgramOperation * SOAP_FMAC4 soap_get___ns1__addProgramOperation(struct soap *soap, struct __ns1__addProgramOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__addProgramOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__addProgramOperation * SOAP_FMAC2 soap_instantiate___ns1__addProgramOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__addProgramOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__addProgramOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__addProgramOperation);
		if (size)
			*size = sizeof(struct __ns1__addProgramOperation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__addProgramOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__addProgramOperation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__addProgramOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__addProgramOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__addProgramOperation %p -> %p\n", q, p));
	*(struct __ns1__addProgramOperation*)p = *(struct __ns1__addProgramOperation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__editLineOperation(struct soap *soap, struct __ns1__editLineOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__editLineOperation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__editLineOperation(struct soap *soap, const struct __ns1__editLineOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__editLineOperation(soap, &a->ns1__editLineOperation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__editLineOperation(struct soap *soap, const char *tag, int id, const struct __ns1__editLineOperation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__editLineOperation(soap, "ns1:editLineOperation", -1, &a->ns1__editLineOperation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__editLineOperation * SOAP_FMAC4 soap_in___ns1__editLineOperation(struct soap *soap, const char *tag, struct __ns1__editLineOperation *a, const char *type)
{
	size_t soap_flag_ns1__editLineOperation = 1;
	short soap_flag;
	a = (struct __ns1__editLineOperation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__editLineOperation, sizeof(struct __ns1__editLineOperation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__editLineOperation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__editLineOperation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__editLineOperation(soap, "ns1:editLineOperation", &a->ns1__editLineOperation, ""))
				{	soap_flag_ns1__editLineOperation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__editLineOperation(struct soap *soap, const struct __ns1__editLineOperation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__editLineOperation(soap, tag?tag:"-ns1:editLineOperation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__editLineOperation * SOAP_FMAC4 soap_get___ns1__editLineOperation(struct soap *soap, struct __ns1__editLineOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__editLineOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__editLineOperation * SOAP_FMAC2 soap_instantiate___ns1__editLineOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__editLineOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__editLineOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__editLineOperation);
		if (size)
			*size = sizeof(struct __ns1__editLineOperation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__editLineOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__editLineOperation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__editLineOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__editLineOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__editLineOperation %p -> %p\n", q, p));
	*(struct __ns1__editLineOperation*)p = *(struct __ns1__editLineOperation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__removeLineOperation(struct soap *soap, struct __ns1__removeLineOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__removeLineOperation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__removeLineOperation(struct soap *soap, const struct __ns1__removeLineOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__removeLineOperation(soap, &a->ns1__removeLineOperation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__removeLineOperation(struct soap *soap, const char *tag, int id, const struct __ns1__removeLineOperation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__removeLineOperation(soap, "ns1:removeLineOperation", -1, &a->ns1__removeLineOperation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeLineOperation * SOAP_FMAC4 soap_in___ns1__removeLineOperation(struct soap *soap, const char *tag, struct __ns1__removeLineOperation *a, const char *type)
{
	size_t soap_flag_ns1__removeLineOperation = 1;
	short soap_flag;
	a = (struct __ns1__removeLineOperation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__removeLineOperation, sizeof(struct __ns1__removeLineOperation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__removeLineOperation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__removeLineOperation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__removeLineOperation(soap, "ns1:removeLineOperation", &a->ns1__removeLineOperation, ""))
				{	soap_flag_ns1__removeLineOperation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__removeLineOperation(struct soap *soap, const struct __ns1__removeLineOperation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__removeLineOperation(soap, tag?tag:"-ns1:removeLineOperation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeLineOperation * SOAP_FMAC4 soap_get___ns1__removeLineOperation(struct soap *soap, struct __ns1__removeLineOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__removeLineOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__removeLineOperation * SOAP_FMAC2 soap_instantiate___ns1__removeLineOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__removeLineOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__removeLineOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeLineOperation);
		if (size)
			*size = sizeof(struct __ns1__removeLineOperation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeLineOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__removeLineOperation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__removeLineOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__removeLineOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__removeLineOperation %p -> %p\n", q, p));
	*(struct __ns1__removeLineOperation*)p = *(struct __ns1__removeLineOperation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__addLineOperation(struct soap *soap, struct __ns1__addLineOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__addLineOperation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__addLineOperation(struct soap *soap, const struct __ns1__addLineOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__addLineOperation(soap, &a->ns1__addLineOperation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__addLineOperation(struct soap *soap, const char *tag, int id, const struct __ns1__addLineOperation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__addLineOperation(soap, "ns1:addLineOperation", -1, &a->ns1__addLineOperation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addLineOperation * SOAP_FMAC4 soap_in___ns1__addLineOperation(struct soap *soap, const char *tag, struct __ns1__addLineOperation *a, const char *type)
{
	size_t soap_flag_ns1__addLineOperation = 1;
	short soap_flag;
	a = (struct __ns1__addLineOperation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__addLineOperation, sizeof(struct __ns1__addLineOperation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__addLineOperation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__addLineOperation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__addLineOperation(soap, "ns1:addLineOperation", &a->ns1__addLineOperation, ""))
				{	soap_flag_ns1__addLineOperation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__addLineOperation(struct soap *soap, const struct __ns1__addLineOperation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__addLineOperation(soap, tag?tag:"-ns1:addLineOperation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addLineOperation * SOAP_FMAC4 soap_get___ns1__addLineOperation(struct soap *soap, struct __ns1__addLineOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__addLineOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__addLineOperation * SOAP_FMAC2 soap_instantiate___ns1__addLineOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__addLineOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__addLineOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__addLineOperation);
		if (size)
			*size = sizeof(struct __ns1__addLineOperation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__addLineOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__addLineOperation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__addLineOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__addLineOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__addLineOperation %p -> %p\n", q, p));
	*(struct __ns1__addLineOperation*)p = *(struct __ns1__addLineOperation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__editLcuOperation(struct soap *soap, struct __ns1__editLcuOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__editLcuOperation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__editLcuOperation(struct soap *soap, const struct __ns1__editLcuOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__editLcuOperation(soap, &a->ns1__editLcuOperation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__editLcuOperation(struct soap *soap, const char *tag, int id, const struct __ns1__editLcuOperation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__editLcuOperation(soap, "ns1:editLcuOperation", -1, &a->ns1__editLcuOperation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__editLcuOperation * SOAP_FMAC4 soap_in___ns1__editLcuOperation(struct soap *soap, const char *tag, struct __ns1__editLcuOperation *a, const char *type)
{
	size_t soap_flag_ns1__editLcuOperation = 1;
	short soap_flag;
	a = (struct __ns1__editLcuOperation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__editLcuOperation, sizeof(struct __ns1__editLcuOperation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__editLcuOperation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__editLcuOperation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__editLcuOperation(soap, "ns1:editLcuOperation", &a->ns1__editLcuOperation, ""))
				{	soap_flag_ns1__editLcuOperation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__editLcuOperation(struct soap *soap, const struct __ns1__editLcuOperation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__editLcuOperation(soap, tag?tag:"-ns1:editLcuOperation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__editLcuOperation * SOAP_FMAC4 soap_get___ns1__editLcuOperation(struct soap *soap, struct __ns1__editLcuOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__editLcuOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__editLcuOperation * SOAP_FMAC2 soap_instantiate___ns1__editLcuOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__editLcuOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__editLcuOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__editLcuOperation);
		if (size)
			*size = sizeof(struct __ns1__editLcuOperation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__editLcuOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__editLcuOperation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__editLcuOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__editLcuOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__editLcuOperation %p -> %p\n", q, p));
	*(struct __ns1__editLcuOperation*)p = *(struct __ns1__editLcuOperation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__removeLcuOperation(struct soap *soap, struct __ns1__removeLcuOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__removeLcuOperation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__removeLcuOperation(struct soap *soap, const struct __ns1__removeLcuOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__removeLcuOperation(soap, &a->ns1__removeLcuOperation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__removeLcuOperation(struct soap *soap, const char *tag, int id, const struct __ns1__removeLcuOperation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__removeLcuOperation(soap, "ns1:removeLcuOperation", -1, &a->ns1__removeLcuOperation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeLcuOperation * SOAP_FMAC4 soap_in___ns1__removeLcuOperation(struct soap *soap, const char *tag, struct __ns1__removeLcuOperation *a, const char *type)
{
	size_t soap_flag_ns1__removeLcuOperation = 1;
	short soap_flag;
	a = (struct __ns1__removeLcuOperation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__removeLcuOperation, sizeof(struct __ns1__removeLcuOperation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__removeLcuOperation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__removeLcuOperation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__removeLcuOperation(soap, "ns1:removeLcuOperation", &a->ns1__removeLcuOperation, ""))
				{	soap_flag_ns1__removeLcuOperation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__removeLcuOperation(struct soap *soap, const struct __ns1__removeLcuOperation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__removeLcuOperation(soap, tag?tag:"-ns1:removeLcuOperation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeLcuOperation * SOAP_FMAC4 soap_get___ns1__removeLcuOperation(struct soap *soap, struct __ns1__removeLcuOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__removeLcuOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__removeLcuOperation * SOAP_FMAC2 soap_instantiate___ns1__removeLcuOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__removeLcuOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__removeLcuOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeLcuOperation);
		if (size)
			*size = sizeof(struct __ns1__removeLcuOperation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeLcuOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__removeLcuOperation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__removeLcuOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__removeLcuOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__removeLcuOperation %p -> %p\n", q, p));
	*(struct __ns1__removeLcuOperation*)p = *(struct __ns1__removeLcuOperation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__addLcuOperation(struct soap *soap, struct __ns1__addLcuOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__addLcuOperation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__addLcuOperation(struct soap *soap, const struct __ns1__addLcuOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__addLcuOperation(soap, &a->ns1__addLcuOperation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__addLcuOperation(struct soap *soap, const char *tag, int id, const struct __ns1__addLcuOperation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__addLcuOperation(soap, "ns1:addLcuOperation", -1, &a->ns1__addLcuOperation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addLcuOperation * SOAP_FMAC4 soap_in___ns1__addLcuOperation(struct soap *soap, const char *tag, struct __ns1__addLcuOperation *a, const char *type)
{
	size_t soap_flag_ns1__addLcuOperation = 1;
	short soap_flag;
	a = (struct __ns1__addLcuOperation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__addLcuOperation, sizeof(struct __ns1__addLcuOperation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__addLcuOperation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__addLcuOperation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__addLcuOperation(soap, "ns1:addLcuOperation", &a->ns1__addLcuOperation, ""))
				{	soap_flag_ns1__addLcuOperation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__addLcuOperation(struct soap *soap, const struct __ns1__addLcuOperation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__addLcuOperation(soap, tag?tag:"-ns1:addLcuOperation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addLcuOperation * SOAP_FMAC4 soap_get___ns1__addLcuOperation(struct soap *soap, struct __ns1__addLcuOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__addLcuOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__addLcuOperation * SOAP_FMAC2 soap_instantiate___ns1__addLcuOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__addLcuOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__addLcuOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__addLcuOperation);
		if (size)
			*size = sizeof(struct __ns1__addLcuOperation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__addLcuOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__addLcuOperation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__addLcuOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__addLcuOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__addLcuOperation %p -> %p\n", q, p));
	*(struct __ns1__addLcuOperation*)p = *(struct __ns1__addLcuOperation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__editDcuOperation(struct soap *soap, struct __ns1__editDcuOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__editDcuOperation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__editDcuOperation(struct soap *soap, const struct __ns1__editDcuOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__editDcuOperation(soap, &a->ns1__editDcuOperation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__editDcuOperation(struct soap *soap, const char *tag, int id, const struct __ns1__editDcuOperation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__editDcuOperation(soap, "ns1:editDcuOperation", -1, &a->ns1__editDcuOperation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__editDcuOperation * SOAP_FMAC4 soap_in___ns1__editDcuOperation(struct soap *soap, const char *tag, struct __ns1__editDcuOperation *a, const char *type)
{
	size_t soap_flag_ns1__editDcuOperation = 1;
	short soap_flag;
	a = (struct __ns1__editDcuOperation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__editDcuOperation, sizeof(struct __ns1__editDcuOperation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__editDcuOperation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__editDcuOperation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__editDcuOperation(soap, "ns1:editDcuOperation", &a->ns1__editDcuOperation, ""))
				{	soap_flag_ns1__editDcuOperation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__editDcuOperation(struct soap *soap, const struct __ns1__editDcuOperation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__editDcuOperation(soap, tag?tag:"-ns1:editDcuOperation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__editDcuOperation * SOAP_FMAC4 soap_get___ns1__editDcuOperation(struct soap *soap, struct __ns1__editDcuOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__editDcuOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__editDcuOperation * SOAP_FMAC2 soap_instantiate___ns1__editDcuOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__editDcuOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__editDcuOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__editDcuOperation);
		if (size)
			*size = sizeof(struct __ns1__editDcuOperation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__editDcuOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__editDcuOperation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__editDcuOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__editDcuOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__editDcuOperation %p -> %p\n", q, p));
	*(struct __ns1__editDcuOperation*)p = *(struct __ns1__editDcuOperation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__removeDcuOperation(struct soap *soap, struct __ns1__removeDcuOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__removeDcuOperation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__removeDcuOperation(struct soap *soap, const struct __ns1__removeDcuOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__removeDcuOperation(soap, &a->ns1__removeDcuOperation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__removeDcuOperation(struct soap *soap, const char *tag, int id, const struct __ns1__removeDcuOperation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__removeDcuOperation(soap, "ns1:removeDcuOperation", -1, &a->ns1__removeDcuOperation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeDcuOperation * SOAP_FMAC4 soap_in___ns1__removeDcuOperation(struct soap *soap, const char *tag, struct __ns1__removeDcuOperation *a, const char *type)
{
	size_t soap_flag_ns1__removeDcuOperation = 1;
	short soap_flag;
	a = (struct __ns1__removeDcuOperation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__removeDcuOperation, sizeof(struct __ns1__removeDcuOperation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__removeDcuOperation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__removeDcuOperation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__removeDcuOperation(soap, "ns1:removeDcuOperation", &a->ns1__removeDcuOperation, ""))
				{	soap_flag_ns1__removeDcuOperation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__removeDcuOperation(struct soap *soap, const struct __ns1__removeDcuOperation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__removeDcuOperation(soap, tag?tag:"-ns1:removeDcuOperation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeDcuOperation * SOAP_FMAC4 soap_get___ns1__removeDcuOperation(struct soap *soap, struct __ns1__removeDcuOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__removeDcuOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__removeDcuOperation * SOAP_FMAC2 soap_instantiate___ns1__removeDcuOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__removeDcuOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__removeDcuOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeDcuOperation);
		if (size)
			*size = sizeof(struct __ns1__removeDcuOperation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeDcuOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__removeDcuOperation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__removeDcuOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__removeDcuOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__removeDcuOperation %p -> %p\n", q, p));
	*(struct __ns1__removeDcuOperation*)p = *(struct __ns1__removeDcuOperation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__addDcuOperation(struct soap *soap, struct __ns1__addDcuOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__addDcuOperation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__addDcuOperation(struct soap *soap, const struct __ns1__addDcuOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__addDcuOperation(soap, &a->ns1__addDcuOperation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__addDcuOperation(struct soap *soap, const char *tag, int id, const struct __ns1__addDcuOperation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__addDcuOperation(soap, "ns1:addDcuOperation", -1, &a->ns1__addDcuOperation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addDcuOperation * SOAP_FMAC4 soap_in___ns1__addDcuOperation(struct soap *soap, const char *tag, struct __ns1__addDcuOperation *a, const char *type)
{
	size_t soap_flag_ns1__addDcuOperation = 1;
	short soap_flag;
	a = (struct __ns1__addDcuOperation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__addDcuOperation, sizeof(struct __ns1__addDcuOperation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__addDcuOperation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__addDcuOperation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__addDcuOperation(soap, "ns1:addDcuOperation", &a->ns1__addDcuOperation, ""))
				{	soap_flag_ns1__addDcuOperation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__addDcuOperation(struct soap *soap, const struct __ns1__addDcuOperation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__addDcuOperation(soap, tag?tag:"-ns1:addDcuOperation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addDcuOperation * SOAP_FMAC4 soap_get___ns1__addDcuOperation(struct soap *soap, struct __ns1__addDcuOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__addDcuOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__addDcuOperation * SOAP_FMAC2 soap_instantiate___ns1__addDcuOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__addDcuOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__addDcuOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__addDcuOperation);
		if (size)
			*size = sizeof(struct __ns1__addDcuOperation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__addDcuOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__addDcuOperation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__addDcuOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__addDcuOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__addDcuOperation %p -> %p\n", q, p));
	*(struct __ns1__addDcuOperation*)p = *(struct __ns1__addDcuOperation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getLineListOperation(struct soap *soap, struct __ns1__getLineListOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getLineListOperation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getLineListOperation(struct soap *soap, const struct __ns1__getLineListOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getLineListOperation(soap, &a->ns1__getLineListOperation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getLineListOperation(struct soap *soap, const char *tag, int id, const struct __ns1__getLineListOperation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getLineListOperation(soap, "ns1:getLineListOperation", -1, &a->ns1__getLineListOperation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getLineListOperation * SOAP_FMAC4 soap_in___ns1__getLineListOperation(struct soap *soap, const char *tag, struct __ns1__getLineListOperation *a, const char *type)
{
	size_t soap_flag_ns1__getLineListOperation = 1;
	short soap_flag;
	a = (struct __ns1__getLineListOperation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getLineListOperation, sizeof(struct __ns1__getLineListOperation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getLineListOperation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getLineListOperation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getLineListOperation(soap, "ns1:getLineListOperation", &a->ns1__getLineListOperation, ""))
				{	soap_flag_ns1__getLineListOperation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getLineListOperation(struct soap *soap, const struct __ns1__getLineListOperation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getLineListOperation(soap, tag?tag:"-ns1:getLineListOperation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getLineListOperation * SOAP_FMAC4 soap_get___ns1__getLineListOperation(struct soap *soap, struct __ns1__getLineListOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getLineListOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getLineListOperation * SOAP_FMAC2 soap_instantiate___ns1__getLineListOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getLineListOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getLineListOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getLineListOperation);
		if (size)
			*size = sizeof(struct __ns1__getLineListOperation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getLineListOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getLineListOperation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getLineListOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getLineListOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getLineListOperation %p -> %p\n", q, p));
	*(struct __ns1__getLineListOperation*)p = *(struct __ns1__getLineListOperation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__updateRuntimeForUserOperation(struct soap *soap, struct __ns1__updateRuntimeForUserOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__updateRuntimeForUserOperation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__updateRuntimeForUserOperation(struct soap *soap, const struct __ns1__updateRuntimeForUserOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__updateRuntimeForUserOperation(soap, &a->ns1__updateRuntimeForUserOperation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__updateRuntimeForUserOperation(struct soap *soap, const char *tag, int id, const struct __ns1__updateRuntimeForUserOperation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__updateRuntimeForUserOperation(soap, "ns1:updateRuntimeForUserOperation", -1, &a->ns1__updateRuntimeForUserOperation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updateRuntimeForUserOperation * SOAP_FMAC4 soap_in___ns1__updateRuntimeForUserOperation(struct soap *soap, const char *tag, struct __ns1__updateRuntimeForUserOperation *a, const char *type)
{
	size_t soap_flag_ns1__updateRuntimeForUserOperation = 1;
	short soap_flag;
	a = (struct __ns1__updateRuntimeForUserOperation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__updateRuntimeForUserOperation, sizeof(struct __ns1__updateRuntimeForUserOperation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__updateRuntimeForUserOperation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__updateRuntimeForUserOperation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__updateRuntimeForUserOperation(soap, "ns1:updateRuntimeForUserOperation", &a->ns1__updateRuntimeForUserOperation, ""))
				{	soap_flag_ns1__updateRuntimeForUserOperation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__updateRuntimeForUserOperation(struct soap *soap, const struct __ns1__updateRuntimeForUserOperation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__updateRuntimeForUserOperation(soap, tag?tag:"-ns1:updateRuntimeForUserOperation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updateRuntimeForUserOperation * SOAP_FMAC4 soap_get___ns1__updateRuntimeForUserOperation(struct soap *soap, struct __ns1__updateRuntimeForUserOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__updateRuntimeForUserOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__updateRuntimeForUserOperation * SOAP_FMAC2 soap_instantiate___ns1__updateRuntimeForUserOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__updateRuntimeForUserOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__updateRuntimeForUserOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__updateRuntimeForUserOperation);
		if (size)
			*size = sizeof(struct __ns1__updateRuntimeForUserOperation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__updateRuntimeForUserOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__updateRuntimeForUserOperation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__updateRuntimeForUserOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__updateRuntimeForUserOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__updateRuntimeForUserOperation %p -> %p\n", q, p));
	*(struct __ns1__updateRuntimeForUserOperation*)p = *(struct __ns1__updateRuntimeForUserOperation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getLcuListOperation(struct soap *soap, struct __ns1__getLcuListOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getLcuListOperation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getLcuListOperation(struct soap *soap, const struct __ns1__getLcuListOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getLcuListOperation(soap, &a->ns1__getLcuListOperation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getLcuListOperation(struct soap *soap, const char *tag, int id, const struct __ns1__getLcuListOperation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getLcuListOperation(soap, "ns1:getLcuListOperation", -1, &a->ns1__getLcuListOperation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getLcuListOperation * SOAP_FMAC4 soap_in___ns1__getLcuListOperation(struct soap *soap, const char *tag, struct __ns1__getLcuListOperation *a, const char *type)
{
	size_t soap_flag_ns1__getLcuListOperation = 1;
	short soap_flag;
	a = (struct __ns1__getLcuListOperation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getLcuListOperation, sizeof(struct __ns1__getLcuListOperation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getLcuListOperation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getLcuListOperation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getLcuListOperation(soap, "ns1:getLcuListOperation", &a->ns1__getLcuListOperation, ""))
				{	soap_flag_ns1__getLcuListOperation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getLcuListOperation(struct soap *soap, const struct __ns1__getLcuListOperation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getLcuListOperation(soap, tag?tag:"-ns1:getLcuListOperation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getLcuListOperation * SOAP_FMAC4 soap_get___ns1__getLcuListOperation(struct soap *soap, struct __ns1__getLcuListOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getLcuListOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getLcuListOperation * SOAP_FMAC2 soap_instantiate___ns1__getLcuListOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getLcuListOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getLcuListOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getLcuListOperation);
		if (size)
			*size = sizeof(struct __ns1__getLcuListOperation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getLcuListOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getLcuListOperation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getLcuListOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getLcuListOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getLcuListOperation %p -> %p\n", q, p));
	*(struct __ns1__getLcuListOperation*)p = *(struct __ns1__getLcuListOperation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getDcuListOperation(struct soap *soap, struct __ns1__getDcuListOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getDcuListOperation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getDcuListOperation(struct soap *soap, const struct __ns1__getDcuListOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getDcuListOperation(soap, &a->ns1__getDcuListOperation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getDcuListOperation(struct soap *soap, const char *tag, int id, const struct __ns1__getDcuListOperation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getDcuListOperation(soap, "ns1:getDcuListOperation", -1, &a->ns1__getDcuListOperation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getDcuListOperation * SOAP_FMAC4 soap_in___ns1__getDcuListOperation(struct soap *soap, const char *tag, struct __ns1__getDcuListOperation *a, const char *type)
{
	size_t soap_flag_ns1__getDcuListOperation = 1;
	short soap_flag;
	a = (struct __ns1__getDcuListOperation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getDcuListOperation, sizeof(struct __ns1__getDcuListOperation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getDcuListOperation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getDcuListOperation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getDcuListOperation(soap, "ns1:getDcuListOperation", &a->ns1__getDcuListOperation, ""))
				{	soap_flag_ns1__getDcuListOperation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getDcuListOperation(struct soap *soap, const struct __ns1__getDcuListOperation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getDcuListOperation(soap, tag?tag:"-ns1:getDcuListOperation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getDcuListOperation * SOAP_FMAC4 soap_get___ns1__getDcuListOperation(struct soap *soap, struct __ns1__getDcuListOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getDcuListOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getDcuListOperation * SOAP_FMAC2 soap_instantiate___ns1__getDcuListOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getDcuListOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getDcuListOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getDcuListOperation);
		if (size)
			*size = sizeof(struct __ns1__getDcuListOperation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getDcuListOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getDcuListOperation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getDcuListOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getDcuListOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getDcuListOperation %p -> %p\n", q, p));
	*(struct __ns1__getDcuListOperation*)p = *(struct __ns1__getDcuListOperation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__LogoutOperation(struct soap *soap, struct __ns1__LogoutOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__LogoutOperation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__LogoutOperation(struct soap *soap, const struct __ns1__LogoutOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__LogoutOperation(soap, &a->ns1__LogoutOperation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__LogoutOperation(struct soap *soap, const char *tag, int id, const struct __ns1__LogoutOperation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__LogoutOperation(soap, "ns1:LogoutOperation", -1, &a->ns1__LogoutOperation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__LogoutOperation * SOAP_FMAC4 soap_in___ns1__LogoutOperation(struct soap *soap, const char *tag, struct __ns1__LogoutOperation *a, const char *type)
{
	size_t soap_flag_ns1__LogoutOperation = 1;
	short soap_flag;
	a = (struct __ns1__LogoutOperation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__LogoutOperation, sizeof(struct __ns1__LogoutOperation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__LogoutOperation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__LogoutOperation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__LogoutOperation(soap, "ns1:LogoutOperation", &a->ns1__LogoutOperation, ""))
				{	soap_flag_ns1__LogoutOperation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__LogoutOperation(struct soap *soap, const struct __ns1__LogoutOperation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__LogoutOperation(soap, tag?tag:"-ns1:LogoutOperation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__LogoutOperation * SOAP_FMAC4 soap_get___ns1__LogoutOperation(struct soap *soap, struct __ns1__LogoutOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__LogoutOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__LogoutOperation * SOAP_FMAC2 soap_instantiate___ns1__LogoutOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__LogoutOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__LogoutOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__LogoutOperation);
		if (size)
			*size = sizeof(struct __ns1__LogoutOperation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__LogoutOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__LogoutOperation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__LogoutOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__LogoutOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__LogoutOperation %p -> %p\n", q, p));
	*(struct __ns1__LogoutOperation*)p = *(struct __ns1__LogoutOperation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__LoginPcOperation(struct soap *soap, struct __ns1__LoginPcOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__LoginPcOperation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__LoginPcOperation(struct soap *soap, const struct __ns1__LoginPcOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__LoginPcOperation(soap, &a->ns1__LoginPcOperation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__LoginPcOperation(struct soap *soap, const char *tag, int id, const struct __ns1__LoginPcOperation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__LoginPcOperation(soap, "ns1:LoginPcOperation", -1, &a->ns1__LoginPcOperation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__LoginPcOperation * SOAP_FMAC4 soap_in___ns1__LoginPcOperation(struct soap *soap, const char *tag, struct __ns1__LoginPcOperation *a, const char *type)
{
	size_t soap_flag_ns1__LoginPcOperation = 1;
	short soap_flag;
	a = (struct __ns1__LoginPcOperation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__LoginPcOperation, sizeof(struct __ns1__LoginPcOperation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__LoginPcOperation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__LoginPcOperation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__LoginPcOperation(soap, "ns1:LoginPcOperation", &a->ns1__LoginPcOperation, ""))
				{	soap_flag_ns1__LoginPcOperation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__LoginPcOperation(struct soap *soap, const struct __ns1__LoginPcOperation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__LoginPcOperation(soap, tag?tag:"-ns1:LoginPcOperation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__LoginPcOperation * SOAP_FMAC4 soap_get___ns1__LoginPcOperation(struct soap *soap, struct __ns1__LoginPcOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__LoginPcOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__LoginPcOperation * SOAP_FMAC2 soap_instantiate___ns1__LoginPcOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__LoginPcOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__LoginPcOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__LoginPcOperation);
		if (size)
			*size = sizeof(struct __ns1__LoginPcOperation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__LoginPcOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__LoginPcOperation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__LoginPcOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__LoginPcOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__LoginPcOperation %p -> %p\n", q, p));
	*(struct __ns1__LoginPcOperation*)p = *(struct __ns1__LoginPcOperation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__LoginOperation(struct soap *soap, struct __ns1__LoginOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__LoginOperation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__LoginOperation(struct soap *soap, const struct __ns1__LoginOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__LoginOperation(soap, &a->ns1__LoginOperation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__LoginOperation(struct soap *soap, const char *tag, int id, const struct __ns1__LoginOperation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__LoginOperation(soap, "ns1:LoginOperation", -1, &a->ns1__LoginOperation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__LoginOperation * SOAP_FMAC4 soap_in___ns1__LoginOperation(struct soap *soap, const char *tag, struct __ns1__LoginOperation *a, const char *type)
{
	size_t soap_flag_ns1__LoginOperation = 1;
	short soap_flag;
	a = (struct __ns1__LoginOperation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__LoginOperation, sizeof(struct __ns1__LoginOperation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__LoginOperation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__LoginOperation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__LoginOperation(soap, "ns1:LoginOperation", &a->ns1__LoginOperation, ""))
				{	soap_flag_ns1__LoginOperation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__LoginOperation(struct soap *soap, const struct __ns1__LoginOperation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__LoginOperation(soap, tag?tag:"-ns1:LoginOperation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__LoginOperation * SOAP_FMAC4 soap_get___ns1__LoginOperation(struct soap *soap, struct __ns1__LoginOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__LoginOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__LoginOperation * SOAP_FMAC2 soap_instantiate___ns1__LoginOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__LoginOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__LoginOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__LoginOperation);
		if (size)
			*size = sizeof(struct __ns1__LoginOperation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__LoginOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__LoginOperation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__LoginOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__LoginOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__LoginOperation %p -> %p\n", q, p));
	*(struct __ns1__LoginOperation*)p = *(struct __ns1__LoginOperation*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getLcuLogOperationResponse(struct soap *soap, _ns1__getLcuLogOperationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getLcuLogOperationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getLcuLogOperationResponse(struct soap *soap, const char *tag, int id, _ns1__getLcuLogOperationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getLcuLogOperationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getLcuLogOperationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getLcuLogOperationResponse(struct soap *soap, const char *tag, _ns1__getLcuLogOperationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getLcuLogOperationResponse **)soap_malloc(soap, sizeof(_ns1__getLcuLogOperationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getLcuLogOperationResponse *)soap_instantiate__ns1__getLcuLogOperationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getLcuLogOperationResponse ** p = (_ns1__getLcuLogOperationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getLcuLogOperationResponse, sizeof(_ns1__getLcuLogOperationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getLcuLogOperationResponse(struct soap *soap, _ns1__getLcuLogOperationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getLcuLogOperationResponse);
	if (soap_out_PointerTo_ns1__getLcuLogOperationResponse(soap, tag?tag:"ns1:getLcuLogOperationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getLcuLogOperationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getLcuLogOperationResponse(struct soap *soap, _ns1__getLcuLogOperationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getLcuLogOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getLcuLogOperation(struct soap *soap, _ns1__getLcuLogOperation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getLcuLogOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getLcuLogOperation(struct soap *soap, const char *tag, int id, _ns1__getLcuLogOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getLcuLogOperation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getLcuLogOperation ** SOAP_FMAC4 soap_in_PointerTo_ns1__getLcuLogOperation(struct soap *soap, const char *tag, _ns1__getLcuLogOperation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getLcuLogOperation **)soap_malloc(soap, sizeof(_ns1__getLcuLogOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getLcuLogOperation *)soap_instantiate__ns1__getLcuLogOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getLcuLogOperation ** p = (_ns1__getLcuLogOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getLcuLogOperation, sizeof(_ns1__getLcuLogOperation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getLcuLogOperation(struct soap *soap, _ns1__getLcuLogOperation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getLcuLogOperation);
	if (soap_out_PointerTo_ns1__getLcuLogOperation(soap, tag?tag:"ns1:getLcuLogOperation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getLcuLogOperation ** SOAP_FMAC4 soap_get_PointerTo_ns1__getLcuLogOperation(struct soap *soap, _ns1__getLcuLogOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getLcuLogOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__removeScheduleOperationResponse(struct soap *soap, _ns1__removeScheduleOperationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__removeScheduleOperationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__removeScheduleOperationResponse(struct soap *soap, const char *tag, int id, _ns1__removeScheduleOperationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__removeScheduleOperationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__removeScheduleOperationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__removeScheduleOperationResponse(struct soap *soap, const char *tag, _ns1__removeScheduleOperationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__removeScheduleOperationResponse **)soap_malloc(soap, sizeof(_ns1__removeScheduleOperationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__removeScheduleOperationResponse *)soap_instantiate__ns1__removeScheduleOperationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__removeScheduleOperationResponse ** p = (_ns1__removeScheduleOperationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__removeScheduleOperationResponse, sizeof(_ns1__removeScheduleOperationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__removeScheduleOperationResponse(struct soap *soap, _ns1__removeScheduleOperationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__removeScheduleOperationResponse);
	if (soap_out_PointerTo_ns1__removeScheduleOperationResponse(soap, tag?tag:"ns1:removeScheduleOperationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__removeScheduleOperationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__removeScheduleOperationResponse(struct soap *soap, _ns1__removeScheduleOperationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__removeScheduleOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__removeScheduleOperation(struct soap *soap, _ns1__removeScheduleOperation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__removeScheduleOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__removeScheduleOperation(struct soap *soap, const char *tag, int id, _ns1__removeScheduleOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__removeScheduleOperation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__removeScheduleOperation ** SOAP_FMAC4 soap_in_PointerTo_ns1__removeScheduleOperation(struct soap *soap, const char *tag, _ns1__removeScheduleOperation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__removeScheduleOperation **)soap_malloc(soap, sizeof(_ns1__removeScheduleOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__removeScheduleOperation *)soap_instantiate__ns1__removeScheduleOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__removeScheduleOperation ** p = (_ns1__removeScheduleOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__removeScheduleOperation, sizeof(_ns1__removeScheduleOperation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__removeScheduleOperation(struct soap *soap, _ns1__removeScheduleOperation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__removeScheduleOperation);
	if (soap_out_PointerTo_ns1__removeScheduleOperation(soap, tag?tag:"ns1:removeScheduleOperation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__removeScheduleOperation ** SOAP_FMAC4 soap_get_PointerTo_ns1__removeScheduleOperation(struct soap *soap, _ns1__removeScheduleOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__removeScheduleOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__editScheduleOperationResponse(struct soap *soap, _ns1__editScheduleOperationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__editScheduleOperationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__editScheduleOperationResponse(struct soap *soap, const char *tag, int id, _ns1__editScheduleOperationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__editScheduleOperationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__editScheduleOperationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__editScheduleOperationResponse(struct soap *soap, const char *tag, _ns1__editScheduleOperationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__editScheduleOperationResponse **)soap_malloc(soap, sizeof(_ns1__editScheduleOperationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__editScheduleOperationResponse *)soap_instantiate__ns1__editScheduleOperationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__editScheduleOperationResponse ** p = (_ns1__editScheduleOperationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__editScheduleOperationResponse, sizeof(_ns1__editScheduleOperationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__editScheduleOperationResponse(struct soap *soap, _ns1__editScheduleOperationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__editScheduleOperationResponse);
	if (soap_out_PointerTo_ns1__editScheduleOperationResponse(soap, tag?tag:"ns1:editScheduleOperationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__editScheduleOperationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__editScheduleOperationResponse(struct soap *soap, _ns1__editScheduleOperationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__editScheduleOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__editScheduleOperation(struct soap *soap, _ns1__editScheduleOperation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__editScheduleOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__editScheduleOperation(struct soap *soap, const char *tag, int id, _ns1__editScheduleOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__editScheduleOperation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__editScheduleOperation ** SOAP_FMAC4 soap_in_PointerTo_ns1__editScheduleOperation(struct soap *soap, const char *tag, _ns1__editScheduleOperation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__editScheduleOperation **)soap_malloc(soap, sizeof(_ns1__editScheduleOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__editScheduleOperation *)soap_instantiate__ns1__editScheduleOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__editScheduleOperation ** p = (_ns1__editScheduleOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__editScheduleOperation, sizeof(_ns1__editScheduleOperation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__editScheduleOperation(struct soap *soap, _ns1__editScheduleOperation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__editScheduleOperation);
	if (soap_out_PointerTo_ns1__editScheduleOperation(soap, tag?tag:"ns1:editScheduleOperation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__editScheduleOperation ** SOAP_FMAC4 soap_get_PointerTo_ns1__editScheduleOperation(struct soap *soap, _ns1__editScheduleOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__editScheduleOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__addScheduleOperationResponse(struct soap *soap, _ns1__addScheduleOperationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__addScheduleOperationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__addScheduleOperationResponse(struct soap *soap, const char *tag, int id, _ns1__addScheduleOperationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__addScheduleOperationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__addScheduleOperationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__addScheduleOperationResponse(struct soap *soap, const char *tag, _ns1__addScheduleOperationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__addScheduleOperationResponse **)soap_malloc(soap, sizeof(_ns1__addScheduleOperationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__addScheduleOperationResponse *)soap_instantiate__ns1__addScheduleOperationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__addScheduleOperationResponse ** p = (_ns1__addScheduleOperationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__addScheduleOperationResponse, sizeof(_ns1__addScheduleOperationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__addScheduleOperationResponse(struct soap *soap, _ns1__addScheduleOperationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__addScheduleOperationResponse);
	if (soap_out_PointerTo_ns1__addScheduleOperationResponse(soap, tag?tag:"ns1:addScheduleOperationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__addScheduleOperationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__addScheduleOperationResponse(struct soap *soap, _ns1__addScheduleOperationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__addScheduleOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__addScheduleOperation(struct soap *soap, _ns1__addScheduleOperation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__addScheduleOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__addScheduleOperation(struct soap *soap, const char *tag, int id, _ns1__addScheduleOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__addScheduleOperation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__addScheduleOperation ** SOAP_FMAC4 soap_in_PointerTo_ns1__addScheduleOperation(struct soap *soap, const char *tag, _ns1__addScheduleOperation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__addScheduleOperation **)soap_malloc(soap, sizeof(_ns1__addScheduleOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__addScheduleOperation *)soap_instantiate__ns1__addScheduleOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__addScheduleOperation ** p = (_ns1__addScheduleOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__addScheduleOperation, sizeof(_ns1__addScheduleOperation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__addScheduleOperation(struct soap *soap, _ns1__addScheduleOperation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__addScheduleOperation);
	if (soap_out_PointerTo_ns1__addScheduleOperation(soap, tag?tag:"ns1:addScheduleOperation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__addScheduleOperation ** SOAP_FMAC4 soap_get_PointerTo_ns1__addScheduleOperation(struct soap *soap, _ns1__addScheduleOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__addScheduleOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getScheduleOperationResponse(struct soap *soap, _ns1__getScheduleOperationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getScheduleOperationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getScheduleOperationResponse(struct soap *soap, const char *tag, int id, _ns1__getScheduleOperationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getScheduleOperationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getScheduleOperationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getScheduleOperationResponse(struct soap *soap, const char *tag, _ns1__getScheduleOperationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getScheduleOperationResponse **)soap_malloc(soap, sizeof(_ns1__getScheduleOperationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getScheduleOperationResponse *)soap_instantiate__ns1__getScheduleOperationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getScheduleOperationResponse ** p = (_ns1__getScheduleOperationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getScheduleOperationResponse, sizeof(_ns1__getScheduleOperationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getScheduleOperationResponse(struct soap *soap, _ns1__getScheduleOperationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getScheduleOperationResponse);
	if (soap_out_PointerTo_ns1__getScheduleOperationResponse(soap, tag?tag:"ns1:getScheduleOperationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getScheduleOperationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getScheduleOperationResponse(struct soap *soap, _ns1__getScheduleOperationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getScheduleOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getScheduleOperation(struct soap *soap, _ns1__getScheduleOperation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getScheduleOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getScheduleOperation(struct soap *soap, const char *tag, int id, _ns1__getScheduleOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getScheduleOperation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getScheduleOperation ** SOAP_FMAC4 soap_in_PointerTo_ns1__getScheduleOperation(struct soap *soap, const char *tag, _ns1__getScheduleOperation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getScheduleOperation **)soap_malloc(soap, sizeof(_ns1__getScheduleOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getScheduleOperation *)soap_instantiate__ns1__getScheduleOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getScheduleOperation ** p = (_ns1__getScheduleOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getScheduleOperation, sizeof(_ns1__getScheduleOperation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getScheduleOperation(struct soap *soap, _ns1__getScheduleOperation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getScheduleOperation);
	if (soap_out_PointerTo_ns1__getScheduleOperation(soap, tag?tag:"ns1:getScheduleOperation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getScheduleOperation ** SOAP_FMAC4 soap_get_PointerTo_ns1__getScheduleOperation(struct soap *soap, _ns1__getScheduleOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getScheduleOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__removeListScheduleOperationResponse(struct soap *soap, _ns1__removeListScheduleOperationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__removeListScheduleOperationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__removeListScheduleOperationResponse(struct soap *soap, const char *tag, int id, _ns1__removeListScheduleOperationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__removeListScheduleOperationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__removeListScheduleOperationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__removeListScheduleOperationResponse(struct soap *soap, const char *tag, _ns1__removeListScheduleOperationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__removeListScheduleOperationResponse **)soap_malloc(soap, sizeof(_ns1__removeListScheduleOperationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__removeListScheduleOperationResponse *)soap_instantiate__ns1__removeListScheduleOperationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__removeListScheduleOperationResponse ** p = (_ns1__removeListScheduleOperationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__removeListScheduleOperationResponse, sizeof(_ns1__removeListScheduleOperationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__removeListScheduleOperationResponse(struct soap *soap, _ns1__removeListScheduleOperationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__removeListScheduleOperationResponse);
	if (soap_out_PointerTo_ns1__removeListScheduleOperationResponse(soap, tag?tag:"ns1:removeListScheduleOperationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__removeListScheduleOperationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__removeListScheduleOperationResponse(struct soap *soap, _ns1__removeListScheduleOperationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__removeListScheduleOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__removeListScheduleOperation(struct soap *soap, _ns1__removeListScheduleOperation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__removeListScheduleOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__removeListScheduleOperation(struct soap *soap, const char *tag, int id, _ns1__removeListScheduleOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__removeListScheduleOperation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__removeListScheduleOperation ** SOAP_FMAC4 soap_in_PointerTo_ns1__removeListScheduleOperation(struct soap *soap, const char *tag, _ns1__removeListScheduleOperation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__removeListScheduleOperation **)soap_malloc(soap, sizeof(_ns1__removeListScheduleOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__removeListScheduleOperation *)soap_instantiate__ns1__removeListScheduleOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__removeListScheduleOperation ** p = (_ns1__removeListScheduleOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__removeListScheduleOperation, sizeof(_ns1__removeListScheduleOperation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__removeListScheduleOperation(struct soap *soap, _ns1__removeListScheduleOperation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__removeListScheduleOperation);
	if (soap_out_PointerTo_ns1__removeListScheduleOperation(soap, tag?tag:"ns1:removeListScheduleOperation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__removeListScheduleOperation ** SOAP_FMAC4 soap_get_PointerTo_ns1__removeListScheduleOperation(struct soap *soap, _ns1__removeListScheduleOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__removeListScheduleOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__editListScheduleOperationResponse(struct soap *soap, _ns1__editListScheduleOperationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__editListScheduleOperationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__editListScheduleOperationResponse(struct soap *soap, const char *tag, int id, _ns1__editListScheduleOperationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__editListScheduleOperationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__editListScheduleOperationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__editListScheduleOperationResponse(struct soap *soap, const char *tag, _ns1__editListScheduleOperationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__editListScheduleOperationResponse **)soap_malloc(soap, sizeof(_ns1__editListScheduleOperationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__editListScheduleOperationResponse *)soap_instantiate__ns1__editListScheduleOperationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__editListScheduleOperationResponse ** p = (_ns1__editListScheduleOperationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__editListScheduleOperationResponse, sizeof(_ns1__editListScheduleOperationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__editListScheduleOperationResponse(struct soap *soap, _ns1__editListScheduleOperationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__editListScheduleOperationResponse);
	if (soap_out_PointerTo_ns1__editListScheduleOperationResponse(soap, tag?tag:"ns1:editListScheduleOperationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__editListScheduleOperationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__editListScheduleOperationResponse(struct soap *soap, _ns1__editListScheduleOperationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__editListScheduleOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__editListScheduleOperation(struct soap *soap, _ns1__editListScheduleOperation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__editListScheduleOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__editListScheduleOperation(struct soap *soap, const char *tag, int id, _ns1__editListScheduleOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__editListScheduleOperation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__editListScheduleOperation ** SOAP_FMAC4 soap_in_PointerTo_ns1__editListScheduleOperation(struct soap *soap, const char *tag, _ns1__editListScheduleOperation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__editListScheduleOperation **)soap_malloc(soap, sizeof(_ns1__editListScheduleOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__editListScheduleOperation *)soap_instantiate__ns1__editListScheduleOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__editListScheduleOperation ** p = (_ns1__editListScheduleOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__editListScheduleOperation, sizeof(_ns1__editListScheduleOperation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__editListScheduleOperation(struct soap *soap, _ns1__editListScheduleOperation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__editListScheduleOperation);
	if (soap_out_PointerTo_ns1__editListScheduleOperation(soap, tag?tag:"ns1:editListScheduleOperation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__editListScheduleOperation ** SOAP_FMAC4 soap_get_PointerTo_ns1__editListScheduleOperation(struct soap *soap, _ns1__editListScheduleOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__editListScheduleOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__addListScheduleOperationResponse(struct soap *soap, _ns1__addListScheduleOperationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__addListScheduleOperationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__addListScheduleOperationResponse(struct soap *soap, const char *tag, int id, _ns1__addListScheduleOperationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__addListScheduleOperationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__addListScheduleOperationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__addListScheduleOperationResponse(struct soap *soap, const char *tag, _ns1__addListScheduleOperationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__addListScheduleOperationResponse **)soap_malloc(soap, sizeof(_ns1__addListScheduleOperationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__addListScheduleOperationResponse *)soap_instantiate__ns1__addListScheduleOperationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__addListScheduleOperationResponse ** p = (_ns1__addListScheduleOperationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__addListScheduleOperationResponse, sizeof(_ns1__addListScheduleOperationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__addListScheduleOperationResponse(struct soap *soap, _ns1__addListScheduleOperationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__addListScheduleOperationResponse);
	if (soap_out_PointerTo_ns1__addListScheduleOperationResponse(soap, tag?tag:"ns1:addListScheduleOperationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__addListScheduleOperationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__addListScheduleOperationResponse(struct soap *soap, _ns1__addListScheduleOperationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__addListScheduleOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__addListScheduleOperation(struct soap *soap, _ns1__addListScheduleOperation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__addListScheduleOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__addListScheduleOperation(struct soap *soap, const char *tag, int id, _ns1__addListScheduleOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__addListScheduleOperation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__addListScheduleOperation ** SOAP_FMAC4 soap_in_PointerTo_ns1__addListScheduleOperation(struct soap *soap, const char *tag, _ns1__addListScheduleOperation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__addListScheduleOperation **)soap_malloc(soap, sizeof(_ns1__addListScheduleOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__addListScheduleOperation *)soap_instantiate__ns1__addListScheduleOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__addListScheduleOperation ** p = (_ns1__addListScheduleOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__addListScheduleOperation, sizeof(_ns1__addListScheduleOperation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__addListScheduleOperation(struct soap *soap, _ns1__addListScheduleOperation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__addListScheduleOperation);
	if (soap_out_PointerTo_ns1__addListScheduleOperation(soap, tag?tag:"ns1:addListScheduleOperation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__addListScheduleOperation ** SOAP_FMAC4 soap_get_PointerTo_ns1__addListScheduleOperation(struct soap *soap, _ns1__addListScheduleOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__addListScheduleOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getListScheduleOperationResponse(struct soap *soap, _ns1__getListScheduleOperationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getListScheduleOperationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getListScheduleOperationResponse(struct soap *soap, const char *tag, int id, _ns1__getListScheduleOperationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getListScheduleOperationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getListScheduleOperationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getListScheduleOperationResponse(struct soap *soap, const char *tag, _ns1__getListScheduleOperationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getListScheduleOperationResponse **)soap_malloc(soap, sizeof(_ns1__getListScheduleOperationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getListScheduleOperationResponse *)soap_instantiate__ns1__getListScheduleOperationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getListScheduleOperationResponse ** p = (_ns1__getListScheduleOperationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getListScheduleOperationResponse, sizeof(_ns1__getListScheduleOperationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getListScheduleOperationResponse(struct soap *soap, _ns1__getListScheduleOperationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getListScheduleOperationResponse);
	if (soap_out_PointerTo_ns1__getListScheduleOperationResponse(soap, tag?tag:"ns1:getListScheduleOperationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getListScheduleOperationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getListScheduleOperationResponse(struct soap *soap, _ns1__getListScheduleOperationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getListScheduleOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getListScheduleOperation(struct soap *soap, _ns1__getListScheduleOperation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getListScheduleOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getListScheduleOperation(struct soap *soap, const char *tag, int id, _ns1__getListScheduleOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getListScheduleOperation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getListScheduleOperation ** SOAP_FMAC4 soap_in_PointerTo_ns1__getListScheduleOperation(struct soap *soap, const char *tag, _ns1__getListScheduleOperation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getListScheduleOperation **)soap_malloc(soap, sizeof(_ns1__getListScheduleOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getListScheduleOperation *)soap_instantiate__ns1__getListScheduleOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getListScheduleOperation ** p = (_ns1__getListScheduleOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getListScheduleOperation, sizeof(_ns1__getListScheduleOperation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getListScheduleOperation(struct soap *soap, _ns1__getListScheduleOperation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getListScheduleOperation);
	if (soap_out_PointerTo_ns1__getListScheduleOperation(soap, tag?tag:"ns1:getListScheduleOperation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getListScheduleOperation ** SOAP_FMAC4 soap_get_PointerTo_ns1__getListScheduleOperation(struct soap *soap, _ns1__getListScheduleOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getListScheduleOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__addDayScheduleOperationResponse(struct soap *soap, _ns1__addDayScheduleOperationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__addDayScheduleOperationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__addDayScheduleOperationResponse(struct soap *soap, const char *tag, int id, _ns1__addDayScheduleOperationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__addDayScheduleOperationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__addDayScheduleOperationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__addDayScheduleOperationResponse(struct soap *soap, const char *tag, _ns1__addDayScheduleOperationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__addDayScheduleOperationResponse **)soap_malloc(soap, sizeof(_ns1__addDayScheduleOperationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__addDayScheduleOperationResponse *)soap_instantiate__ns1__addDayScheduleOperationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__addDayScheduleOperationResponse ** p = (_ns1__addDayScheduleOperationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__addDayScheduleOperationResponse, sizeof(_ns1__addDayScheduleOperationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__addDayScheduleOperationResponse(struct soap *soap, _ns1__addDayScheduleOperationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__addDayScheduleOperationResponse);
	if (soap_out_PointerTo_ns1__addDayScheduleOperationResponse(soap, tag?tag:"ns1:addDayScheduleOperationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__addDayScheduleOperationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__addDayScheduleOperationResponse(struct soap *soap, _ns1__addDayScheduleOperationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__addDayScheduleOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__addDayScheduleOperation(struct soap *soap, _ns1__addDayScheduleOperation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__addDayScheduleOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__addDayScheduleOperation(struct soap *soap, const char *tag, int id, _ns1__addDayScheduleOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__addDayScheduleOperation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__addDayScheduleOperation ** SOAP_FMAC4 soap_in_PointerTo_ns1__addDayScheduleOperation(struct soap *soap, const char *tag, _ns1__addDayScheduleOperation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__addDayScheduleOperation **)soap_malloc(soap, sizeof(_ns1__addDayScheduleOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__addDayScheduleOperation *)soap_instantiate__ns1__addDayScheduleOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__addDayScheduleOperation ** p = (_ns1__addDayScheduleOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__addDayScheduleOperation, sizeof(_ns1__addDayScheduleOperation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__addDayScheduleOperation(struct soap *soap, _ns1__addDayScheduleOperation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__addDayScheduleOperation);
	if (soap_out_PointerTo_ns1__addDayScheduleOperation(soap, tag?tag:"ns1:addDayScheduleOperation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__addDayScheduleOperation ** SOAP_FMAC4 soap_get_PointerTo_ns1__addDayScheduleOperation(struct soap *soap, _ns1__addDayScheduleOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__addDayScheduleOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__removeDayScheduleOperationResponse(struct soap *soap, _ns1__removeDayScheduleOperationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__removeDayScheduleOperationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__removeDayScheduleOperationResponse(struct soap *soap, const char *tag, int id, _ns1__removeDayScheduleOperationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__removeDayScheduleOperationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__removeDayScheduleOperationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__removeDayScheduleOperationResponse(struct soap *soap, const char *tag, _ns1__removeDayScheduleOperationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__removeDayScheduleOperationResponse **)soap_malloc(soap, sizeof(_ns1__removeDayScheduleOperationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__removeDayScheduleOperationResponse *)soap_instantiate__ns1__removeDayScheduleOperationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__removeDayScheduleOperationResponse ** p = (_ns1__removeDayScheduleOperationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__removeDayScheduleOperationResponse, sizeof(_ns1__removeDayScheduleOperationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__removeDayScheduleOperationResponse(struct soap *soap, _ns1__removeDayScheduleOperationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__removeDayScheduleOperationResponse);
	if (soap_out_PointerTo_ns1__removeDayScheduleOperationResponse(soap, tag?tag:"ns1:removeDayScheduleOperationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__removeDayScheduleOperationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__removeDayScheduleOperationResponse(struct soap *soap, _ns1__removeDayScheduleOperationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__removeDayScheduleOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__removeDayScheduleOperation(struct soap *soap, _ns1__removeDayScheduleOperation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__removeDayScheduleOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__removeDayScheduleOperation(struct soap *soap, const char *tag, int id, _ns1__removeDayScheduleOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__removeDayScheduleOperation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__removeDayScheduleOperation ** SOAP_FMAC4 soap_in_PointerTo_ns1__removeDayScheduleOperation(struct soap *soap, const char *tag, _ns1__removeDayScheduleOperation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__removeDayScheduleOperation **)soap_malloc(soap, sizeof(_ns1__removeDayScheduleOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__removeDayScheduleOperation *)soap_instantiate__ns1__removeDayScheduleOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__removeDayScheduleOperation ** p = (_ns1__removeDayScheduleOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__removeDayScheduleOperation, sizeof(_ns1__removeDayScheduleOperation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__removeDayScheduleOperation(struct soap *soap, _ns1__removeDayScheduleOperation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__removeDayScheduleOperation);
	if (soap_out_PointerTo_ns1__removeDayScheduleOperation(soap, tag?tag:"ns1:removeDayScheduleOperation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__removeDayScheduleOperation ** SOAP_FMAC4 soap_get_PointerTo_ns1__removeDayScheduleOperation(struct soap *soap, _ns1__removeDayScheduleOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__removeDayScheduleOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__editDayScheduleOperationResponse(struct soap *soap, _ns1__editDayScheduleOperationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__editDayScheduleOperationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__editDayScheduleOperationResponse(struct soap *soap, const char *tag, int id, _ns1__editDayScheduleOperationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__editDayScheduleOperationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__editDayScheduleOperationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__editDayScheduleOperationResponse(struct soap *soap, const char *tag, _ns1__editDayScheduleOperationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__editDayScheduleOperationResponse **)soap_malloc(soap, sizeof(_ns1__editDayScheduleOperationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__editDayScheduleOperationResponse *)soap_instantiate__ns1__editDayScheduleOperationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__editDayScheduleOperationResponse ** p = (_ns1__editDayScheduleOperationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__editDayScheduleOperationResponse, sizeof(_ns1__editDayScheduleOperationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__editDayScheduleOperationResponse(struct soap *soap, _ns1__editDayScheduleOperationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__editDayScheduleOperationResponse);
	if (soap_out_PointerTo_ns1__editDayScheduleOperationResponse(soap, tag?tag:"ns1:editDayScheduleOperationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__editDayScheduleOperationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__editDayScheduleOperationResponse(struct soap *soap, _ns1__editDayScheduleOperationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__editDayScheduleOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__editDayScheduleOperation(struct soap *soap, _ns1__editDayScheduleOperation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__editDayScheduleOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__editDayScheduleOperation(struct soap *soap, const char *tag, int id, _ns1__editDayScheduleOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__editDayScheduleOperation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__editDayScheduleOperation ** SOAP_FMAC4 soap_in_PointerTo_ns1__editDayScheduleOperation(struct soap *soap, const char *tag, _ns1__editDayScheduleOperation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__editDayScheduleOperation **)soap_malloc(soap, sizeof(_ns1__editDayScheduleOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__editDayScheduleOperation *)soap_instantiate__ns1__editDayScheduleOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__editDayScheduleOperation ** p = (_ns1__editDayScheduleOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__editDayScheduleOperation, sizeof(_ns1__editDayScheduleOperation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__editDayScheduleOperation(struct soap *soap, _ns1__editDayScheduleOperation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__editDayScheduleOperation);
	if (soap_out_PointerTo_ns1__editDayScheduleOperation(soap, tag?tag:"ns1:editDayScheduleOperation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__editDayScheduleOperation ** SOAP_FMAC4 soap_get_PointerTo_ns1__editDayScheduleOperation(struct soap *soap, _ns1__editDayScheduleOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__editDayScheduleOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getDayScheduleOperationResponse(struct soap *soap, _ns1__getDayScheduleOperationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getDayScheduleOperationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getDayScheduleOperationResponse(struct soap *soap, const char *tag, int id, _ns1__getDayScheduleOperationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getDayScheduleOperationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getDayScheduleOperationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getDayScheduleOperationResponse(struct soap *soap, const char *tag, _ns1__getDayScheduleOperationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getDayScheduleOperationResponse **)soap_malloc(soap, sizeof(_ns1__getDayScheduleOperationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getDayScheduleOperationResponse *)soap_instantiate__ns1__getDayScheduleOperationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getDayScheduleOperationResponse ** p = (_ns1__getDayScheduleOperationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getDayScheduleOperationResponse, sizeof(_ns1__getDayScheduleOperationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getDayScheduleOperationResponse(struct soap *soap, _ns1__getDayScheduleOperationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getDayScheduleOperationResponse);
	if (soap_out_PointerTo_ns1__getDayScheduleOperationResponse(soap, tag?tag:"ns1:getDayScheduleOperationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getDayScheduleOperationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getDayScheduleOperationResponse(struct soap *soap, _ns1__getDayScheduleOperationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getDayScheduleOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getDayScheduleOperation(struct soap *soap, _ns1__getDayScheduleOperation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getDayScheduleOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getDayScheduleOperation(struct soap *soap, const char *tag, int id, _ns1__getDayScheduleOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getDayScheduleOperation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getDayScheduleOperation ** SOAP_FMAC4 soap_in_PointerTo_ns1__getDayScheduleOperation(struct soap *soap, const char *tag, _ns1__getDayScheduleOperation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getDayScheduleOperation **)soap_malloc(soap, sizeof(_ns1__getDayScheduleOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getDayScheduleOperation *)soap_instantiate__ns1__getDayScheduleOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getDayScheduleOperation ** p = (_ns1__getDayScheduleOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getDayScheduleOperation, sizeof(_ns1__getDayScheduleOperation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getDayScheduleOperation(struct soap *soap, _ns1__getDayScheduleOperation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getDayScheduleOperation);
	if (soap_out_PointerTo_ns1__getDayScheduleOperation(soap, tag?tag:"ns1:getDayScheduleOperation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getDayScheduleOperation ** SOAP_FMAC4 soap_get_PointerTo_ns1__getDayScheduleOperation(struct soap *soap, _ns1__getDayScheduleOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getDayScheduleOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__editProgramOperationResponse(struct soap *soap, _ns1__editProgramOperationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__editProgramOperationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__editProgramOperationResponse(struct soap *soap, const char *tag, int id, _ns1__editProgramOperationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__editProgramOperationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__editProgramOperationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__editProgramOperationResponse(struct soap *soap, const char *tag, _ns1__editProgramOperationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__editProgramOperationResponse **)soap_malloc(soap, sizeof(_ns1__editProgramOperationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__editProgramOperationResponse *)soap_instantiate__ns1__editProgramOperationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__editProgramOperationResponse ** p = (_ns1__editProgramOperationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__editProgramOperationResponse, sizeof(_ns1__editProgramOperationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__editProgramOperationResponse(struct soap *soap, _ns1__editProgramOperationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__editProgramOperationResponse);
	if (soap_out_PointerTo_ns1__editProgramOperationResponse(soap, tag?tag:"ns1:editProgramOperationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__editProgramOperationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__editProgramOperationResponse(struct soap *soap, _ns1__editProgramOperationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__editProgramOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__editProgramOperation(struct soap *soap, _ns1__editProgramOperation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__editProgramOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__editProgramOperation(struct soap *soap, const char *tag, int id, _ns1__editProgramOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__editProgramOperation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__editProgramOperation ** SOAP_FMAC4 soap_in_PointerTo_ns1__editProgramOperation(struct soap *soap, const char *tag, _ns1__editProgramOperation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__editProgramOperation **)soap_malloc(soap, sizeof(_ns1__editProgramOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__editProgramOperation *)soap_instantiate__ns1__editProgramOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__editProgramOperation ** p = (_ns1__editProgramOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__editProgramOperation, sizeof(_ns1__editProgramOperation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__editProgramOperation(struct soap *soap, _ns1__editProgramOperation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__editProgramOperation);
	if (soap_out_PointerTo_ns1__editProgramOperation(soap, tag?tag:"ns1:editProgramOperation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__editProgramOperation ** SOAP_FMAC4 soap_get_PointerTo_ns1__editProgramOperation(struct soap *soap, _ns1__editProgramOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__editProgramOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getProgramOperationResponse(struct soap *soap, _ns1__getProgramOperationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getProgramOperationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getProgramOperationResponse(struct soap *soap, const char *tag, int id, _ns1__getProgramOperationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getProgramOperationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getProgramOperationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getProgramOperationResponse(struct soap *soap, const char *tag, _ns1__getProgramOperationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getProgramOperationResponse **)soap_malloc(soap, sizeof(_ns1__getProgramOperationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getProgramOperationResponse *)soap_instantiate__ns1__getProgramOperationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getProgramOperationResponse ** p = (_ns1__getProgramOperationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getProgramOperationResponse, sizeof(_ns1__getProgramOperationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getProgramOperationResponse(struct soap *soap, _ns1__getProgramOperationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getProgramOperationResponse);
	if (soap_out_PointerTo_ns1__getProgramOperationResponse(soap, tag?tag:"ns1:getProgramOperationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getProgramOperationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getProgramOperationResponse(struct soap *soap, _ns1__getProgramOperationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getProgramOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getProgramOperation(struct soap *soap, _ns1__getProgramOperation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getProgramOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getProgramOperation(struct soap *soap, const char *tag, int id, _ns1__getProgramOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getProgramOperation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getProgramOperation ** SOAP_FMAC4 soap_in_PointerTo_ns1__getProgramOperation(struct soap *soap, const char *tag, _ns1__getProgramOperation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getProgramOperation **)soap_malloc(soap, sizeof(_ns1__getProgramOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getProgramOperation *)soap_instantiate__ns1__getProgramOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getProgramOperation ** p = (_ns1__getProgramOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getProgramOperation, sizeof(_ns1__getProgramOperation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getProgramOperation(struct soap *soap, _ns1__getProgramOperation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getProgramOperation);
	if (soap_out_PointerTo_ns1__getProgramOperation(soap, tag?tag:"ns1:getProgramOperation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getProgramOperation ** SOAP_FMAC4 soap_get_PointerTo_ns1__getProgramOperation(struct soap *soap, _ns1__getProgramOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getProgramOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__editUserByUserOperationResponse(struct soap *soap, _ns1__editUserByUserOperationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__editUserByUserOperationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__editUserByUserOperationResponse(struct soap *soap, const char *tag, int id, _ns1__editUserByUserOperationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__editUserByUserOperationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__editUserByUserOperationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__editUserByUserOperationResponse(struct soap *soap, const char *tag, _ns1__editUserByUserOperationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__editUserByUserOperationResponse **)soap_malloc(soap, sizeof(_ns1__editUserByUserOperationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__editUserByUserOperationResponse *)soap_instantiate__ns1__editUserByUserOperationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__editUserByUserOperationResponse ** p = (_ns1__editUserByUserOperationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__editUserByUserOperationResponse, sizeof(_ns1__editUserByUserOperationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__editUserByUserOperationResponse(struct soap *soap, _ns1__editUserByUserOperationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__editUserByUserOperationResponse);
	if (soap_out_PointerTo_ns1__editUserByUserOperationResponse(soap, tag?tag:"ns1:editUserByUserOperationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__editUserByUserOperationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__editUserByUserOperationResponse(struct soap *soap, _ns1__editUserByUserOperationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__editUserByUserOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__editUserByUserOperation(struct soap *soap, _ns1__editUserByUserOperation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__editUserByUserOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__editUserByUserOperation(struct soap *soap, const char *tag, int id, _ns1__editUserByUserOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__editUserByUserOperation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__editUserByUserOperation ** SOAP_FMAC4 soap_in_PointerTo_ns1__editUserByUserOperation(struct soap *soap, const char *tag, _ns1__editUserByUserOperation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__editUserByUserOperation **)soap_malloc(soap, sizeof(_ns1__editUserByUserOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__editUserByUserOperation *)soap_instantiate__ns1__editUserByUserOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__editUserByUserOperation ** p = (_ns1__editUserByUserOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__editUserByUserOperation, sizeof(_ns1__editUserByUserOperation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__editUserByUserOperation(struct soap *soap, _ns1__editUserByUserOperation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__editUserByUserOperation);
	if (soap_out_PointerTo_ns1__editUserByUserOperation(soap, tag?tag:"ns1:editUserByUserOperation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__editUserByUserOperation ** SOAP_FMAC4 soap_get_PointerTo_ns1__editUserByUserOperation(struct soap *soap, _ns1__editUserByUserOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__editUserByUserOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__removeUserOperationResponse(struct soap *soap, _ns1__removeUserOperationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__removeUserOperationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__removeUserOperationResponse(struct soap *soap, const char *tag, int id, _ns1__removeUserOperationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__removeUserOperationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__removeUserOperationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__removeUserOperationResponse(struct soap *soap, const char *tag, _ns1__removeUserOperationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__removeUserOperationResponse **)soap_malloc(soap, sizeof(_ns1__removeUserOperationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__removeUserOperationResponse *)soap_instantiate__ns1__removeUserOperationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__removeUserOperationResponse ** p = (_ns1__removeUserOperationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__removeUserOperationResponse, sizeof(_ns1__removeUserOperationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__removeUserOperationResponse(struct soap *soap, _ns1__removeUserOperationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__removeUserOperationResponse);
	if (soap_out_PointerTo_ns1__removeUserOperationResponse(soap, tag?tag:"ns1:removeUserOperationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__removeUserOperationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__removeUserOperationResponse(struct soap *soap, _ns1__removeUserOperationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__removeUserOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__removeUserOperation(struct soap *soap, _ns1__removeUserOperation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__removeUserOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__removeUserOperation(struct soap *soap, const char *tag, int id, _ns1__removeUserOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__removeUserOperation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__removeUserOperation ** SOAP_FMAC4 soap_in_PointerTo_ns1__removeUserOperation(struct soap *soap, const char *tag, _ns1__removeUserOperation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__removeUserOperation **)soap_malloc(soap, sizeof(_ns1__removeUserOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__removeUserOperation *)soap_instantiate__ns1__removeUserOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__removeUserOperation ** p = (_ns1__removeUserOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__removeUserOperation, sizeof(_ns1__removeUserOperation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__removeUserOperation(struct soap *soap, _ns1__removeUserOperation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__removeUserOperation);
	if (soap_out_PointerTo_ns1__removeUserOperation(soap, tag?tag:"ns1:removeUserOperation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__removeUserOperation ** SOAP_FMAC4 soap_get_PointerTo_ns1__removeUserOperation(struct soap *soap, _ns1__removeUserOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__removeUserOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__editUserOperationResponse(struct soap *soap, _ns1__editUserOperationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__editUserOperationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__editUserOperationResponse(struct soap *soap, const char *tag, int id, _ns1__editUserOperationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__editUserOperationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__editUserOperationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__editUserOperationResponse(struct soap *soap, const char *tag, _ns1__editUserOperationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__editUserOperationResponse **)soap_malloc(soap, sizeof(_ns1__editUserOperationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__editUserOperationResponse *)soap_instantiate__ns1__editUserOperationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__editUserOperationResponse ** p = (_ns1__editUserOperationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__editUserOperationResponse, sizeof(_ns1__editUserOperationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__editUserOperationResponse(struct soap *soap, _ns1__editUserOperationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__editUserOperationResponse);
	if (soap_out_PointerTo_ns1__editUserOperationResponse(soap, tag?tag:"ns1:editUserOperationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__editUserOperationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__editUserOperationResponse(struct soap *soap, _ns1__editUserOperationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__editUserOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__editUserOperation(struct soap *soap, _ns1__editUserOperation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__editUserOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__editUserOperation(struct soap *soap, const char *tag, int id, _ns1__editUserOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__editUserOperation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__editUserOperation ** SOAP_FMAC4 soap_in_PointerTo_ns1__editUserOperation(struct soap *soap, const char *tag, _ns1__editUserOperation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__editUserOperation **)soap_malloc(soap, sizeof(_ns1__editUserOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__editUserOperation *)soap_instantiate__ns1__editUserOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__editUserOperation ** p = (_ns1__editUserOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__editUserOperation, sizeof(_ns1__editUserOperation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__editUserOperation(struct soap *soap, _ns1__editUserOperation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__editUserOperation);
	if (soap_out_PointerTo_ns1__editUserOperation(soap, tag?tag:"ns1:editUserOperation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__editUserOperation ** SOAP_FMAC4 soap_get_PointerTo_ns1__editUserOperation(struct soap *soap, _ns1__editUserOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__editUserOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__addUserOperationResponse(struct soap *soap, _ns1__addUserOperationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__addUserOperationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__addUserOperationResponse(struct soap *soap, const char *tag, int id, _ns1__addUserOperationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__addUserOperationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__addUserOperationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__addUserOperationResponse(struct soap *soap, const char *tag, _ns1__addUserOperationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__addUserOperationResponse **)soap_malloc(soap, sizeof(_ns1__addUserOperationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__addUserOperationResponse *)soap_instantiate__ns1__addUserOperationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__addUserOperationResponse ** p = (_ns1__addUserOperationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__addUserOperationResponse, sizeof(_ns1__addUserOperationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__addUserOperationResponse(struct soap *soap, _ns1__addUserOperationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__addUserOperationResponse);
	if (soap_out_PointerTo_ns1__addUserOperationResponse(soap, tag?tag:"ns1:addUserOperationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__addUserOperationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__addUserOperationResponse(struct soap *soap, _ns1__addUserOperationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__addUserOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__addUserOperation(struct soap *soap, _ns1__addUserOperation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__addUserOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__addUserOperation(struct soap *soap, const char *tag, int id, _ns1__addUserOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__addUserOperation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__addUserOperation ** SOAP_FMAC4 soap_in_PointerTo_ns1__addUserOperation(struct soap *soap, const char *tag, _ns1__addUserOperation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__addUserOperation **)soap_malloc(soap, sizeof(_ns1__addUserOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__addUserOperation *)soap_instantiate__ns1__addUserOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__addUserOperation ** p = (_ns1__addUserOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__addUserOperation, sizeof(_ns1__addUserOperation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__addUserOperation(struct soap *soap, _ns1__addUserOperation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__addUserOperation);
	if (soap_out_PointerTo_ns1__addUserOperation(soap, tag?tag:"ns1:addUserOperation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__addUserOperation ** SOAP_FMAC4 soap_get_PointerTo_ns1__addUserOperation(struct soap *soap, _ns1__addUserOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__addUserOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getAllUserOperationResponse(struct soap *soap, _ns1__getAllUserOperationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getAllUserOperationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getAllUserOperationResponse(struct soap *soap, const char *tag, int id, _ns1__getAllUserOperationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getAllUserOperationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getAllUserOperationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getAllUserOperationResponse(struct soap *soap, const char *tag, _ns1__getAllUserOperationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getAllUserOperationResponse **)soap_malloc(soap, sizeof(_ns1__getAllUserOperationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getAllUserOperationResponse *)soap_instantiate__ns1__getAllUserOperationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getAllUserOperationResponse ** p = (_ns1__getAllUserOperationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getAllUserOperationResponse, sizeof(_ns1__getAllUserOperationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getAllUserOperationResponse(struct soap *soap, _ns1__getAllUserOperationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getAllUserOperationResponse);
	if (soap_out_PointerTo_ns1__getAllUserOperationResponse(soap, tag?tag:"ns1:getAllUserOperationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getAllUserOperationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getAllUserOperationResponse(struct soap *soap, _ns1__getAllUserOperationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getAllUserOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getAllUserOperation(struct soap *soap, _ns1__getAllUserOperation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getAllUserOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getAllUserOperation(struct soap *soap, const char *tag, int id, _ns1__getAllUserOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getAllUserOperation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getAllUserOperation ** SOAP_FMAC4 soap_in_PointerTo_ns1__getAllUserOperation(struct soap *soap, const char *tag, _ns1__getAllUserOperation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getAllUserOperation **)soap_malloc(soap, sizeof(_ns1__getAllUserOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getAllUserOperation *)soap_instantiate__ns1__getAllUserOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getAllUserOperation ** p = (_ns1__getAllUserOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getAllUserOperation, sizeof(_ns1__getAllUserOperation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getAllUserOperation(struct soap *soap, _ns1__getAllUserOperation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getAllUserOperation);
	if (soap_out_PointerTo_ns1__getAllUserOperation(soap, tag?tag:"ns1:getAllUserOperation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getAllUserOperation ** SOAP_FMAC4 soap_get_PointerTo_ns1__getAllUserOperation(struct soap *soap, _ns1__getAllUserOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getAllUserOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__removeZoneOperationResponse(struct soap *soap, _ns1__removeZoneOperationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__removeZoneOperationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__removeZoneOperationResponse(struct soap *soap, const char *tag, int id, _ns1__removeZoneOperationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__removeZoneOperationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__removeZoneOperationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__removeZoneOperationResponse(struct soap *soap, const char *tag, _ns1__removeZoneOperationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__removeZoneOperationResponse **)soap_malloc(soap, sizeof(_ns1__removeZoneOperationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__removeZoneOperationResponse *)soap_instantiate__ns1__removeZoneOperationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__removeZoneOperationResponse ** p = (_ns1__removeZoneOperationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__removeZoneOperationResponse, sizeof(_ns1__removeZoneOperationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__removeZoneOperationResponse(struct soap *soap, _ns1__removeZoneOperationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__removeZoneOperationResponse);
	if (soap_out_PointerTo_ns1__removeZoneOperationResponse(soap, tag?tag:"ns1:removeZoneOperationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__removeZoneOperationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__removeZoneOperationResponse(struct soap *soap, _ns1__removeZoneOperationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__removeZoneOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__removeZoneOperation(struct soap *soap, _ns1__removeZoneOperation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__removeZoneOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__removeZoneOperation(struct soap *soap, const char *tag, int id, _ns1__removeZoneOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__removeZoneOperation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__removeZoneOperation ** SOAP_FMAC4 soap_in_PointerTo_ns1__removeZoneOperation(struct soap *soap, const char *tag, _ns1__removeZoneOperation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__removeZoneOperation **)soap_malloc(soap, sizeof(_ns1__removeZoneOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__removeZoneOperation *)soap_instantiate__ns1__removeZoneOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__removeZoneOperation ** p = (_ns1__removeZoneOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__removeZoneOperation, sizeof(_ns1__removeZoneOperation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__removeZoneOperation(struct soap *soap, _ns1__removeZoneOperation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__removeZoneOperation);
	if (soap_out_PointerTo_ns1__removeZoneOperation(soap, tag?tag:"ns1:removeZoneOperation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__removeZoneOperation ** SOAP_FMAC4 soap_get_PointerTo_ns1__removeZoneOperation(struct soap *soap, _ns1__removeZoneOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__removeZoneOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__editZoneOperationResponse(struct soap *soap, _ns1__editZoneOperationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__editZoneOperationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__editZoneOperationResponse(struct soap *soap, const char *tag, int id, _ns1__editZoneOperationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__editZoneOperationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__editZoneOperationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__editZoneOperationResponse(struct soap *soap, const char *tag, _ns1__editZoneOperationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__editZoneOperationResponse **)soap_malloc(soap, sizeof(_ns1__editZoneOperationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__editZoneOperationResponse *)soap_instantiate__ns1__editZoneOperationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__editZoneOperationResponse ** p = (_ns1__editZoneOperationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__editZoneOperationResponse, sizeof(_ns1__editZoneOperationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__editZoneOperationResponse(struct soap *soap, _ns1__editZoneOperationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__editZoneOperationResponse);
	if (soap_out_PointerTo_ns1__editZoneOperationResponse(soap, tag?tag:"ns1:editZoneOperationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__editZoneOperationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__editZoneOperationResponse(struct soap *soap, _ns1__editZoneOperationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__editZoneOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__editZoneOperation(struct soap *soap, _ns1__editZoneOperation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__editZoneOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__editZoneOperation(struct soap *soap, const char *tag, int id, _ns1__editZoneOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__editZoneOperation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__editZoneOperation ** SOAP_FMAC4 soap_in_PointerTo_ns1__editZoneOperation(struct soap *soap, const char *tag, _ns1__editZoneOperation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__editZoneOperation **)soap_malloc(soap, sizeof(_ns1__editZoneOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__editZoneOperation *)soap_instantiate__ns1__editZoneOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__editZoneOperation ** p = (_ns1__editZoneOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__editZoneOperation, sizeof(_ns1__editZoneOperation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__editZoneOperation(struct soap *soap, _ns1__editZoneOperation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__editZoneOperation);
	if (soap_out_PointerTo_ns1__editZoneOperation(soap, tag?tag:"ns1:editZoneOperation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__editZoneOperation ** SOAP_FMAC4 soap_get_PointerTo_ns1__editZoneOperation(struct soap *soap, _ns1__editZoneOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__editZoneOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__addZoneOperationResponse(struct soap *soap, _ns1__addZoneOperationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__addZoneOperationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__addZoneOperationResponse(struct soap *soap, const char *tag, int id, _ns1__addZoneOperationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__addZoneOperationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__addZoneOperationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__addZoneOperationResponse(struct soap *soap, const char *tag, _ns1__addZoneOperationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__addZoneOperationResponse **)soap_malloc(soap, sizeof(_ns1__addZoneOperationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__addZoneOperationResponse *)soap_instantiate__ns1__addZoneOperationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__addZoneOperationResponse ** p = (_ns1__addZoneOperationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__addZoneOperationResponse, sizeof(_ns1__addZoneOperationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__addZoneOperationResponse(struct soap *soap, _ns1__addZoneOperationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__addZoneOperationResponse);
	if (soap_out_PointerTo_ns1__addZoneOperationResponse(soap, tag?tag:"ns1:addZoneOperationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__addZoneOperationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__addZoneOperationResponse(struct soap *soap, _ns1__addZoneOperationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__addZoneOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__addZoneOperation(struct soap *soap, _ns1__addZoneOperation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__addZoneOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__addZoneOperation(struct soap *soap, const char *tag, int id, _ns1__addZoneOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__addZoneOperation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__addZoneOperation ** SOAP_FMAC4 soap_in_PointerTo_ns1__addZoneOperation(struct soap *soap, const char *tag, _ns1__addZoneOperation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__addZoneOperation **)soap_malloc(soap, sizeof(_ns1__addZoneOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__addZoneOperation *)soap_instantiate__ns1__addZoneOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__addZoneOperation ** p = (_ns1__addZoneOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__addZoneOperation, sizeof(_ns1__addZoneOperation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__addZoneOperation(struct soap *soap, _ns1__addZoneOperation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__addZoneOperation);
	if (soap_out_PointerTo_ns1__addZoneOperation(soap, tag?tag:"ns1:addZoneOperation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__addZoneOperation ** SOAP_FMAC4 soap_get_PointerTo_ns1__addZoneOperation(struct soap *soap, _ns1__addZoneOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__addZoneOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SetDcuToZoneOperationResponse(struct soap *soap, _ns1__SetDcuToZoneOperationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SetDcuToZoneOperationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SetDcuToZoneOperationResponse(struct soap *soap, const char *tag, int id, _ns1__SetDcuToZoneOperationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SetDcuToZoneOperationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__SetDcuToZoneOperationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__SetDcuToZoneOperationResponse(struct soap *soap, const char *tag, _ns1__SetDcuToZoneOperationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SetDcuToZoneOperationResponse **)soap_malloc(soap, sizeof(_ns1__SetDcuToZoneOperationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SetDcuToZoneOperationResponse *)soap_instantiate__ns1__SetDcuToZoneOperationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__SetDcuToZoneOperationResponse ** p = (_ns1__SetDcuToZoneOperationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SetDcuToZoneOperationResponse, sizeof(_ns1__SetDcuToZoneOperationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SetDcuToZoneOperationResponse(struct soap *soap, _ns1__SetDcuToZoneOperationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__SetDcuToZoneOperationResponse);
	if (soap_out_PointerTo_ns1__SetDcuToZoneOperationResponse(soap, tag?tag:"ns1:SetDcuToZoneOperationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SetDcuToZoneOperationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__SetDcuToZoneOperationResponse(struct soap *soap, _ns1__SetDcuToZoneOperationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SetDcuToZoneOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SetDcuToZoneOperation(struct soap *soap, _ns1__SetDcuToZoneOperation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SetDcuToZoneOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SetDcuToZoneOperation(struct soap *soap, const char *tag, int id, _ns1__SetDcuToZoneOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SetDcuToZoneOperation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__SetDcuToZoneOperation ** SOAP_FMAC4 soap_in_PointerTo_ns1__SetDcuToZoneOperation(struct soap *soap, const char *tag, _ns1__SetDcuToZoneOperation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SetDcuToZoneOperation **)soap_malloc(soap, sizeof(_ns1__SetDcuToZoneOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SetDcuToZoneOperation *)soap_instantiate__ns1__SetDcuToZoneOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__SetDcuToZoneOperation ** p = (_ns1__SetDcuToZoneOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SetDcuToZoneOperation, sizeof(_ns1__SetDcuToZoneOperation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SetDcuToZoneOperation(struct soap *soap, _ns1__SetDcuToZoneOperation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__SetDcuToZoneOperation);
	if (soap_out_PointerTo_ns1__SetDcuToZoneOperation(soap, tag?tag:"ns1:SetDcuToZoneOperation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SetDcuToZoneOperation ** SOAP_FMAC4 soap_get_PointerTo_ns1__SetDcuToZoneOperation(struct soap *soap, _ns1__SetDcuToZoneOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SetDcuToZoneOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getAllZoneForUserOperationResponse(struct soap *soap, _ns1__getAllZoneForUserOperationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getAllZoneForUserOperationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getAllZoneForUserOperationResponse(struct soap *soap, const char *tag, int id, _ns1__getAllZoneForUserOperationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getAllZoneForUserOperationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getAllZoneForUserOperationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getAllZoneForUserOperationResponse(struct soap *soap, const char *tag, _ns1__getAllZoneForUserOperationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getAllZoneForUserOperationResponse **)soap_malloc(soap, sizeof(_ns1__getAllZoneForUserOperationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getAllZoneForUserOperationResponse *)soap_instantiate__ns1__getAllZoneForUserOperationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getAllZoneForUserOperationResponse ** p = (_ns1__getAllZoneForUserOperationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getAllZoneForUserOperationResponse, sizeof(_ns1__getAllZoneForUserOperationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getAllZoneForUserOperationResponse(struct soap *soap, _ns1__getAllZoneForUserOperationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getAllZoneForUserOperationResponse);
	if (soap_out_PointerTo_ns1__getAllZoneForUserOperationResponse(soap, tag?tag:"ns1:getAllZoneForUserOperationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getAllZoneForUserOperationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getAllZoneForUserOperationResponse(struct soap *soap, _ns1__getAllZoneForUserOperationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getAllZoneForUserOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getAllZoneForUserOperation(struct soap *soap, _ns1__getAllZoneForUserOperation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getAllZoneForUserOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getAllZoneForUserOperation(struct soap *soap, const char *tag, int id, _ns1__getAllZoneForUserOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getAllZoneForUserOperation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getAllZoneForUserOperation ** SOAP_FMAC4 soap_in_PointerTo_ns1__getAllZoneForUserOperation(struct soap *soap, const char *tag, _ns1__getAllZoneForUserOperation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getAllZoneForUserOperation **)soap_malloc(soap, sizeof(_ns1__getAllZoneForUserOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getAllZoneForUserOperation *)soap_instantiate__ns1__getAllZoneForUserOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getAllZoneForUserOperation ** p = (_ns1__getAllZoneForUserOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getAllZoneForUserOperation, sizeof(_ns1__getAllZoneForUserOperation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getAllZoneForUserOperation(struct soap *soap, _ns1__getAllZoneForUserOperation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getAllZoneForUserOperation);
	if (soap_out_PointerTo_ns1__getAllZoneForUserOperation(soap, tag?tag:"ns1:getAllZoneForUserOperation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getAllZoneForUserOperation ** SOAP_FMAC4 soap_get_PointerTo_ns1__getAllZoneForUserOperation(struct soap *soap, _ns1__getAllZoneForUserOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getAllZoneForUserOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getAllZoneOperationResponse(struct soap *soap, _ns1__getAllZoneOperationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getAllZoneOperationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getAllZoneOperationResponse(struct soap *soap, const char *tag, int id, _ns1__getAllZoneOperationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getAllZoneOperationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getAllZoneOperationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getAllZoneOperationResponse(struct soap *soap, const char *tag, _ns1__getAllZoneOperationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getAllZoneOperationResponse **)soap_malloc(soap, sizeof(_ns1__getAllZoneOperationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getAllZoneOperationResponse *)soap_instantiate__ns1__getAllZoneOperationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getAllZoneOperationResponse ** p = (_ns1__getAllZoneOperationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getAllZoneOperationResponse, sizeof(_ns1__getAllZoneOperationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getAllZoneOperationResponse(struct soap *soap, _ns1__getAllZoneOperationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getAllZoneOperationResponse);
	if (soap_out_PointerTo_ns1__getAllZoneOperationResponse(soap, tag?tag:"ns1:getAllZoneOperationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getAllZoneOperationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getAllZoneOperationResponse(struct soap *soap, _ns1__getAllZoneOperationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getAllZoneOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getAllZoneOperation(struct soap *soap, _ns1__getAllZoneOperation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getAllZoneOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getAllZoneOperation(struct soap *soap, const char *tag, int id, _ns1__getAllZoneOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getAllZoneOperation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getAllZoneOperation ** SOAP_FMAC4 soap_in_PointerTo_ns1__getAllZoneOperation(struct soap *soap, const char *tag, _ns1__getAllZoneOperation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getAllZoneOperation **)soap_malloc(soap, sizeof(_ns1__getAllZoneOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getAllZoneOperation *)soap_instantiate__ns1__getAllZoneOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getAllZoneOperation ** p = (_ns1__getAllZoneOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getAllZoneOperation, sizeof(_ns1__getAllZoneOperation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getAllZoneOperation(struct soap *soap, _ns1__getAllZoneOperation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getAllZoneOperation);
	if (soap_out_PointerTo_ns1__getAllZoneOperation(soap, tag?tag:"ns1:getAllZoneOperation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getAllZoneOperation ** SOAP_FMAC4 soap_get_PointerTo_ns1__getAllZoneOperation(struct soap *soap, _ns1__getAllZoneOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getAllZoneOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__deleteUserLogOperationResponse(struct soap *soap, _ns1__deleteUserLogOperationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__deleteUserLogOperationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__deleteUserLogOperationResponse(struct soap *soap, const char *tag, int id, _ns1__deleteUserLogOperationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__deleteUserLogOperationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__deleteUserLogOperationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__deleteUserLogOperationResponse(struct soap *soap, const char *tag, _ns1__deleteUserLogOperationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__deleteUserLogOperationResponse **)soap_malloc(soap, sizeof(_ns1__deleteUserLogOperationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__deleteUserLogOperationResponse *)soap_instantiate__ns1__deleteUserLogOperationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__deleteUserLogOperationResponse ** p = (_ns1__deleteUserLogOperationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__deleteUserLogOperationResponse, sizeof(_ns1__deleteUserLogOperationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__deleteUserLogOperationResponse(struct soap *soap, _ns1__deleteUserLogOperationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__deleteUserLogOperationResponse);
	if (soap_out_PointerTo_ns1__deleteUserLogOperationResponse(soap, tag?tag:"ns1:deleteUserLogOperationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__deleteUserLogOperationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__deleteUserLogOperationResponse(struct soap *soap, _ns1__deleteUserLogOperationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__deleteUserLogOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__deleteUserLogOperation(struct soap *soap, _ns1__deleteUserLogOperation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__deleteUserLogOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__deleteUserLogOperation(struct soap *soap, const char *tag, int id, _ns1__deleteUserLogOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__deleteUserLogOperation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__deleteUserLogOperation ** SOAP_FMAC4 soap_in_PointerTo_ns1__deleteUserLogOperation(struct soap *soap, const char *tag, _ns1__deleteUserLogOperation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__deleteUserLogOperation **)soap_malloc(soap, sizeof(_ns1__deleteUserLogOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__deleteUserLogOperation *)soap_instantiate__ns1__deleteUserLogOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__deleteUserLogOperation ** p = (_ns1__deleteUserLogOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__deleteUserLogOperation, sizeof(_ns1__deleteUserLogOperation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__deleteUserLogOperation(struct soap *soap, _ns1__deleteUserLogOperation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__deleteUserLogOperation);
	if (soap_out_PointerTo_ns1__deleteUserLogOperation(soap, tag?tag:"ns1:deleteUserLogOperation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__deleteUserLogOperation ** SOAP_FMAC4 soap_get_PointerTo_ns1__deleteUserLogOperation(struct soap *soap, _ns1__deleteUserLogOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__deleteUserLogOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getUserLogOperationResponse(struct soap *soap, _ns1__getUserLogOperationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getUserLogOperationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getUserLogOperationResponse(struct soap *soap, const char *tag, int id, _ns1__getUserLogOperationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getUserLogOperationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getUserLogOperationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getUserLogOperationResponse(struct soap *soap, const char *tag, _ns1__getUserLogOperationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getUserLogOperationResponse **)soap_malloc(soap, sizeof(_ns1__getUserLogOperationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getUserLogOperationResponse *)soap_instantiate__ns1__getUserLogOperationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getUserLogOperationResponse ** p = (_ns1__getUserLogOperationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getUserLogOperationResponse, sizeof(_ns1__getUserLogOperationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getUserLogOperationResponse(struct soap *soap, _ns1__getUserLogOperationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getUserLogOperationResponse);
	if (soap_out_PointerTo_ns1__getUserLogOperationResponse(soap, tag?tag:"ns1:getUserLogOperationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getUserLogOperationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getUserLogOperationResponse(struct soap *soap, _ns1__getUserLogOperationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getUserLogOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getUserLogOperation(struct soap *soap, _ns1__getUserLogOperation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getUserLogOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getUserLogOperation(struct soap *soap, const char *tag, int id, _ns1__getUserLogOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getUserLogOperation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getUserLogOperation ** SOAP_FMAC4 soap_in_PointerTo_ns1__getUserLogOperation(struct soap *soap, const char *tag, _ns1__getUserLogOperation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getUserLogOperation **)soap_malloc(soap, sizeof(_ns1__getUserLogOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getUserLogOperation *)soap_instantiate__ns1__getUserLogOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getUserLogOperation ** p = (_ns1__getUserLogOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getUserLogOperation, sizeof(_ns1__getUserLogOperation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getUserLogOperation(struct soap *soap, _ns1__getUserLogOperation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getUserLogOperation);
	if (soap_out_PointerTo_ns1__getUserLogOperation(soap, tag?tag:"ns1:getUserLogOperation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getUserLogOperation ** SOAP_FMAC4 soap_get_PointerTo_ns1__getUserLogOperation(struct soap *soap, _ns1__getUserLogOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getUserLogOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__deleteEventLogOperationResponse(struct soap *soap, _ns1__deleteEventLogOperationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__deleteEventLogOperationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__deleteEventLogOperationResponse(struct soap *soap, const char *tag, int id, _ns1__deleteEventLogOperationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__deleteEventLogOperationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__deleteEventLogOperationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__deleteEventLogOperationResponse(struct soap *soap, const char *tag, _ns1__deleteEventLogOperationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__deleteEventLogOperationResponse **)soap_malloc(soap, sizeof(_ns1__deleteEventLogOperationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__deleteEventLogOperationResponse *)soap_instantiate__ns1__deleteEventLogOperationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__deleteEventLogOperationResponse ** p = (_ns1__deleteEventLogOperationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__deleteEventLogOperationResponse, sizeof(_ns1__deleteEventLogOperationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__deleteEventLogOperationResponse(struct soap *soap, _ns1__deleteEventLogOperationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__deleteEventLogOperationResponse);
	if (soap_out_PointerTo_ns1__deleteEventLogOperationResponse(soap, tag?tag:"ns1:deleteEventLogOperationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__deleteEventLogOperationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__deleteEventLogOperationResponse(struct soap *soap, _ns1__deleteEventLogOperationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__deleteEventLogOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__deleteEventLogOperation(struct soap *soap, _ns1__deleteEventLogOperation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__deleteEventLogOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__deleteEventLogOperation(struct soap *soap, const char *tag, int id, _ns1__deleteEventLogOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__deleteEventLogOperation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__deleteEventLogOperation ** SOAP_FMAC4 soap_in_PointerTo_ns1__deleteEventLogOperation(struct soap *soap, const char *tag, _ns1__deleteEventLogOperation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__deleteEventLogOperation **)soap_malloc(soap, sizeof(_ns1__deleteEventLogOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__deleteEventLogOperation *)soap_instantiate__ns1__deleteEventLogOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__deleteEventLogOperation ** p = (_ns1__deleteEventLogOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__deleteEventLogOperation, sizeof(_ns1__deleteEventLogOperation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__deleteEventLogOperation(struct soap *soap, _ns1__deleteEventLogOperation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__deleteEventLogOperation);
	if (soap_out_PointerTo_ns1__deleteEventLogOperation(soap, tag?tag:"ns1:deleteEventLogOperation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__deleteEventLogOperation ** SOAP_FMAC4 soap_get_PointerTo_ns1__deleteEventLogOperation(struct soap *soap, _ns1__deleteEventLogOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__deleteEventLogOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__updateReadEventLogOperationResponse(struct soap *soap, _ns1__updateReadEventLogOperationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__updateReadEventLogOperationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__updateReadEventLogOperationResponse(struct soap *soap, const char *tag, int id, _ns1__updateReadEventLogOperationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__updateReadEventLogOperationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__updateReadEventLogOperationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__updateReadEventLogOperationResponse(struct soap *soap, const char *tag, _ns1__updateReadEventLogOperationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__updateReadEventLogOperationResponse **)soap_malloc(soap, sizeof(_ns1__updateReadEventLogOperationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__updateReadEventLogOperationResponse *)soap_instantiate__ns1__updateReadEventLogOperationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__updateReadEventLogOperationResponse ** p = (_ns1__updateReadEventLogOperationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__updateReadEventLogOperationResponse, sizeof(_ns1__updateReadEventLogOperationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__updateReadEventLogOperationResponse(struct soap *soap, _ns1__updateReadEventLogOperationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__updateReadEventLogOperationResponse);
	if (soap_out_PointerTo_ns1__updateReadEventLogOperationResponse(soap, tag?tag:"ns1:updateReadEventLogOperationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__updateReadEventLogOperationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__updateReadEventLogOperationResponse(struct soap *soap, _ns1__updateReadEventLogOperationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__updateReadEventLogOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__updateReadEventLogOperation(struct soap *soap, _ns1__updateReadEventLogOperation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__updateReadEventLogOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__updateReadEventLogOperation(struct soap *soap, const char *tag, int id, _ns1__updateReadEventLogOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__updateReadEventLogOperation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__updateReadEventLogOperation ** SOAP_FMAC4 soap_in_PointerTo_ns1__updateReadEventLogOperation(struct soap *soap, const char *tag, _ns1__updateReadEventLogOperation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__updateReadEventLogOperation **)soap_malloc(soap, sizeof(_ns1__updateReadEventLogOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__updateReadEventLogOperation *)soap_instantiate__ns1__updateReadEventLogOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__updateReadEventLogOperation ** p = (_ns1__updateReadEventLogOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__updateReadEventLogOperation, sizeof(_ns1__updateReadEventLogOperation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__updateReadEventLogOperation(struct soap *soap, _ns1__updateReadEventLogOperation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__updateReadEventLogOperation);
	if (soap_out_PointerTo_ns1__updateReadEventLogOperation(soap, tag?tag:"ns1:updateReadEventLogOperation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__updateReadEventLogOperation ** SOAP_FMAC4 soap_get_PointerTo_ns1__updateReadEventLogOperation(struct soap *soap, _ns1__updateReadEventLogOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__updateReadEventLogOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getEventLogOperationResponse(struct soap *soap, _ns1__getEventLogOperationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getEventLogOperationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getEventLogOperationResponse(struct soap *soap, const char *tag, int id, _ns1__getEventLogOperationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getEventLogOperationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getEventLogOperationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getEventLogOperationResponse(struct soap *soap, const char *tag, _ns1__getEventLogOperationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getEventLogOperationResponse **)soap_malloc(soap, sizeof(_ns1__getEventLogOperationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getEventLogOperationResponse *)soap_instantiate__ns1__getEventLogOperationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getEventLogOperationResponse ** p = (_ns1__getEventLogOperationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getEventLogOperationResponse, sizeof(_ns1__getEventLogOperationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getEventLogOperationResponse(struct soap *soap, _ns1__getEventLogOperationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getEventLogOperationResponse);
	if (soap_out_PointerTo_ns1__getEventLogOperationResponse(soap, tag?tag:"ns1:getEventLogOperationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getEventLogOperationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getEventLogOperationResponse(struct soap *soap, _ns1__getEventLogOperationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getEventLogOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getEventLogOperation(struct soap *soap, _ns1__getEventLogOperation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getEventLogOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getEventLogOperation(struct soap *soap, const char *tag, int id, _ns1__getEventLogOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getEventLogOperation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getEventLogOperation ** SOAP_FMAC4 soap_in_PointerTo_ns1__getEventLogOperation(struct soap *soap, const char *tag, _ns1__getEventLogOperation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getEventLogOperation **)soap_malloc(soap, sizeof(_ns1__getEventLogOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getEventLogOperation *)soap_instantiate__ns1__getEventLogOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getEventLogOperation ** p = (_ns1__getEventLogOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getEventLogOperation, sizeof(_ns1__getEventLogOperation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getEventLogOperation(struct soap *soap, _ns1__getEventLogOperation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getEventLogOperation);
	if (soap_out_PointerTo_ns1__getEventLogOperation(soap, tag?tag:"ns1:getEventLogOperation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getEventLogOperation ** SOAP_FMAC4 soap_get_PointerTo_ns1__getEventLogOperation(struct soap *soap, _ns1__getEventLogOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getEventLogOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__setProgramDcuOperationResponse(struct soap *soap, _ns1__setProgramDcuOperationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__setProgramDcuOperationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__setProgramDcuOperationResponse(struct soap *soap, const char *tag, int id, _ns1__setProgramDcuOperationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__setProgramDcuOperationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__setProgramDcuOperationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__setProgramDcuOperationResponse(struct soap *soap, const char *tag, _ns1__setProgramDcuOperationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__setProgramDcuOperationResponse **)soap_malloc(soap, sizeof(_ns1__setProgramDcuOperationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__setProgramDcuOperationResponse *)soap_instantiate__ns1__setProgramDcuOperationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__setProgramDcuOperationResponse ** p = (_ns1__setProgramDcuOperationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__setProgramDcuOperationResponse, sizeof(_ns1__setProgramDcuOperationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__setProgramDcuOperationResponse(struct soap *soap, _ns1__setProgramDcuOperationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__setProgramDcuOperationResponse);
	if (soap_out_PointerTo_ns1__setProgramDcuOperationResponse(soap, tag?tag:"ns1:setProgramDcuOperationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__setProgramDcuOperationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__setProgramDcuOperationResponse(struct soap *soap, _ns1__setProgramDcuOperationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__setProgramDcuOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__setProgramDcuOperation(struct soap *soap, _ns1__setProgramDcuOperation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__setProgramDcuOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__setProgramDcuOperation(struct soap *soap, const char *tag, int id, _ns1__setProgramDcuOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__setProgramDcuOperation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__setProgramDcuOperation ** SOAP_FMAC4 soap_in_PointerTo_ns1__setProgramDcuOperation(struct soap *soap, const char *tag, _ns1__setProgramDcuOperation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__setProgramDcuOperation **)soap_malloc(soap, sizeof(_ns1__setProgramDcuOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__setProgramDcuOperation *)soap_instantiate__ns1__setProgramDcuOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__setProgramDcuOperation ** p = (_ns1__setProgramDcuOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__setProgramDcuOperation, sizeof(_ns1__setProgramDcuOperation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__setProgramDcuOperation(struct soap *soap, _ns1__setProgramDcuOperation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__setProgramDcuOperation);
	if (soap_out_PointerTo_ns1__setProgramDcuOperation(soap, tag?tag:"ns1:setProgramDcuOperation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__setProgramDcuOperation ** SOAP_FMAC4 soap_get_PointerTo_ns1__setProgramDcuOperation(struct soap *soap, _ns1__setProgramDcuOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__setProgramDcuOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__controlLineOperationResponse(struct soap *soap, _ns1__controlLineOperationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__controlLineOperationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__controlLineOperationResponse(struct soap *soap, const char *tag, int id, _ns1__controlLineOperationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__controlLineOperationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__controlLineOperationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__controlLineOperationResponse(struct soap *soap, const char *tag, _ns1__controlLineOperationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__controlLineOperationResponse **)soap_malloc(soap, sizeof(_ns1__controlLineOperationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__controlLineOperationResponse *)soap_instantiate__ns1__controlLineOperationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__controlLineOperationResponse ** p = (_ns1__controlLineOperationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__controlLineOperationResponse, sizeof(_ns1__controlLineOperationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__controlLineOperationResponse(struct soap *soap, _ns1__controlLineOperationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__controlLineOperationResponse);
	if (soap_out_PointerTo_ns1__controlLineOperationResponse(soap, tag?tag:"ns1:controlLineOperationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__controlLineOperationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__controlLineOperationResponse(struct soap *soap, _ns1__controlLineOperationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__controlLineOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__controlLineOperation(struct soap *soap, _ns1__controlLineOperation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__controlLineOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__controlLineOperation(struct soap *soap, const char *tag, int id, _ns1__controlLineOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__controlLineOperation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__controlLineOperation ** SOAP_FMAC4 soap_in_PointerTo_ns1__controlLineOperation(struct soap *soap, const char *tag, _ns1__controlLineOperation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__controlLineOperation **)soap_malloc(soap, sizeof(_ns1__controlLineOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__controlLineOperation *)soap_instantiate__ns1__controlLineOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__controlLineOperation ** p = (_ns1__controlLineOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__controlLineOperation, sizeof(_ns1__controlLineOperation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__controlLineOperation(struct soap *soap, _ns1__controlLineOperation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__controlLineOperation);
	if (soap_out_PointerTo_ns1__controlLineOperation(soap, tag?tag:"ns1:controlLineOperation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__controlLineOperation ** SOAP_FMAC4 soap_get_PointerTo_ns1__controlLineOperation(struct soap *soap, _ns1__controlLineOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__controlLineOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__controlLcuOperationResponse(struct soap *soap, _ns1__controlLcuOperationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__controlLcuOperationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__controlLcuOperationResponse(struct soap *soap, const char *tag, int id, _ns1__controlLcuOperationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__controlLcuOperationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__controlLcuOperationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__controlLcuOperationResponse(struct soap *soap, const char *tag, _ns1__controlLcuOperationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__controlLcuOperationResponse **)soap_malloc(soap, sizeof(_ns1__controlLcuOperationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__controlLcuOperationResponse *)soap_instantiate__ns1__controlLcuOperationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__controlLcuOperationResponse ** p = (_ns1__controlLcuOperationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__controlLcuOperationResponse, sizeof(_ns1__controlLcuOperationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__controlLcuOperationResponse(struct soap *soap, _ns1__controlLcuOperationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__controlLcuOperationResponse);
	if (soap_out_PointerTo_ns1__controlLcuOperationResponse(soap, tag?tag:"ns1:controlLcuOperationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__controlLcuOperationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__controlLcuOperationResponse(struct soap *soap, _ns1__controlLcuOperationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__controlLcuOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__controlLcuOperation(struct soap *soap, _ns1__controlLcuOperation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__controlLcuOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__controlLcuOperation(struct soap *soap, const char *tag, int id, _ns1__controlLcuOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__controlLcuOperation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__controlLcuOperation ** SOAP_FMAC4 soap_in_PointerTo_ns1__controlLcuOperation(struct soap *soap, const char *tag, _ns1__controlLcuOperation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__controlLcuOperation **)soap_malloc(soap, sizeof(_ns1__controlLcuOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__controlLcuOperation *)soap_instantiate__ns1__controlLcuOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__controlLcuOperation ** p = (_ns1__controlLcuOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__controlLcuOperation, sizeof(_ns1__controlLcuOperation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__controlLcuOperation(struct soap *soap, _ns1__controlLcuOperation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__controlLcuOperation);
	if (soap_out_PointerTo_ns1__controlLcuOperation(soap, tag?tag:"ns1:controlLcuOperation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__controlLcuOperation ** SOAP_FMAC4 soap_get_PointerTo_ns1__controlLcuOperation(struct soap *soap, _ns1__controlLcuOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__controlLcuOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__removeProgramOperationResponse(struct soap *soap, _ns1__removeProgramOperationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__removeProgramOperationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__removeProgramOperationResponse(struct soap *soap, const char *tag, int id, _ns1__removeProgramOperationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__removeProgramOperationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__removeProgramOperationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__removeProgramOperationResponse(struct soap *soap, const char *tag, _ns1__removeProgramOperationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__removeProgramOperationResponse **)soap_malloc(soap, sizeof(_ns1__removeProgramOperationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__removeProgramOperationResponse *)soap_instantiate__ns1__removeProgramOperationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__removeProgramOperationResponse ** p = (_ns1__removeProgramOperationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__removeProgramOperationResponse, sizeof(_ns1__removeProgramOperationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__removeProgramOperationResponse(struct soap *soap, _ns1__removeProgramOperationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__removeProgramOperationResponse);
	if (soap_out_PointerTo_ns1__removeProgramOperationResponse(soap, tag?tag:"ns1:removeProgramOperationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__removeProgramOperationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__removeProgramOperationResponse(struct soap *soap, _ns1__removeProgramOperationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__removeProgramOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__removeProgramOperation(struct soap *soap, _ns1__removeProgramOperation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__removeProgramOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__removeProgramOperation(struct soap *soap, const char *tag, int id, _ns1__removeProgramOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__removeProgramOperation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__removeProgramOperation ** SOAP_FMAC4 soap_in_PointerTo_ns1__removeProgramOperation(struct soap *soap, const char *tag, _ns1__removeProgramOperation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__removeProgramOperation **)soap_malloc(soap, sizeof(_ns1__removeProgramOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__removeProgramOperation *)soap_instantiate__ns1__removeProgramOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__removeProgramOperation ** p = (_ns1__removeProgramOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__removeProgramOperation, sizeof(_ns1__removeProgramOperation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__removeProgramOperation(struct soap *soap, _ns1__removeProgramOperation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__removeProgramOperation);
	if (soap_out_PointerTo_ns1__removeProgramOperation(soap, tag?tag:"ns1:removeProgramOperation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__removeProgramOperation ** SOAP_FMAC4 soap_get_PointerTo_ns1__removeProgramOperation(struct soap *soap, _ns1__removeProgramOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__removeProgramOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__addProgramOperationResponse(struct soap *soap, _ns1__addProgramOperationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__addProgramOperationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__addProgramOperationResponse(struct soap *soap, const char *tag, int id, _ns1__addProgramOperationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__addProgramOperationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__addProgramOperationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__addProgramOperationResponse(struct soap *soap, const char *tag, _ns1__addProgramOperationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__addProgramOperationResponse **)soap_malloc(soap, sizeof(_ns1__addProgramOperationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__addProgramOperationResponse *)soap_instantiate__ns1__addProgramOperationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__addProgramOperationResponse ** p = (_ns1__addProgramOperationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__addProgramOperationResponse, sizeof(_ns1__addProgramOperationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__addProgramOperationResponse(struct soap *soap, _ns1__addProgramOperationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__addProgramOperationResponse);
	if (soap_out_PointerTo_ns1__addProgramOperationResponse(soap, tag?tag:"ns1:addProgramOperationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__addProgramOperationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__addProgramOperationResponse(struct soap *soap, _ns1__addProgramOperationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__addProgramOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__addProgramOperation(struct soap *soap, _ns1__addProgramOperation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__addProgramOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__addProgramOperation(struct soap *soap, const char *tag, int id, _ns1__addProgramOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__addProgramOperation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__addProgramOperation ** SOAP_FMAC4 soap_in_PointerTo_ns1__addProgramOperation(struct soap *soap, const char *tag, _ns1__addProgramOperation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__addProgramOperation **)soap_malloc(soap, sizeof(_ns1__addProgramOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__addProgramOperation *)soap_instantiate__ns1__addProgramOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__addProgramOperation ** p = (_ns1__addProgramOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__addProgramOperation, sizeof(_ns1__addProgramOperation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__addProgramOperation(struct soap *soap, _ns1__addProgramOperation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__addProgramOperation);
	if (soap_out_PointerTo_ns1__addProgramOperation(soap, tag?tag:"ns1:addProgramOperation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__addProgramOperation ** SOAP_FMAC4 soap_get_PointerTo_ns1__addProgramOperation(struct soap *soap, _ns1__addProgramOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__addProgramOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__editLineOperationResponse(struct soap *soap, _ns1__editLineOperationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__editLineOperationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__editLineOperationResponse(struct soap *soap, const char *tag, int id, _ns1__editLineOperationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__editLineOperationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__editLineOperationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__editLineOperationResponse(struct soap *soap, const char *tag, _ns1__editLineOperationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__editLineOperationResponse **)soap_malloc(soap, sizeof(_ns1__editLineOperationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__editLineOperationResponse *)soap_instantiate__ns1__editLineOperationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__editLineOperationResponse ** p = (_ns1__editLineOperationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__editLineOperationResponse, sizeof(_ns1__editLineOperationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__editLineOperationResponse(struct soap *soap, _ns1__editLineOperationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__editLineOperationResponse);
	if (soap_out_PointerTo_ns1__editLineOperationResponse(soap, tag?tag:"ns1:editLineOperationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__editLineOperationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__editLineOperationResponse(struct soap *soap, _ns1__editLineOperationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__editLineOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__editLineOperation(struct soap *soap, _ns1__editLineOperation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__editLineOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__editLineOperation(struct soap *soap, const char *tag, int id, _ns1__editLineOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__editLineOperation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__editLineOperation ** SOAP_FMAC4 soap_in_PointerTo_ns1__editLineOperation(struct soap *soap, const char *tag, _ns1__editLineOperation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__editLineOperation **)soap_malloc(soap, sizeof(_ns1__editLineOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__editLineOperation *)soap_instantiate__ns1__editLineOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__editLineOperation ** p = (_ns1__editLineOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__editLineOperation, sizeof(_ns1__editLineOperation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__editLineOperation(struct soap *soap, _ns1__editLineOperation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__editLineOperation);
	if (soap_out_PointerTo_ns1__editLineOperation(soap, tag?tag:"ns1:editLineOperation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__editLineOperation ** SOAP_FMAC4 soap_get_PointerTo_ns1__editLineOperation(struct soap *soap, _ns1__editLineOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__editLineOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__removeLineOperationResponse(struct soap *soap, _ns1__removeLineOperationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__removeLineOperationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__removeLineOperationResponse(struct soap *soap, const char *tag, int id, _ns1__removeLineOperationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__removeLineOperationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__removeLineOperationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__removeLineOperationResponse(struct soap *soap, const char *tag, _ns1__removeLineOperationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__removeLineOperationResponse **)soap_malloc(soap, sizeof(_ns1__removeLineOperationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__removeLineOperationResponse *)soap_instantiate__ns1__removeLineOperationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__removeLineOperationResponse ** p = (_ns1__removeLineOperationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__removeLineOperationResponse, sizeof(_ns1__removeLineOperationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__removeLineOperationResponse(struct soap *soap, _ns1__removeLineOperationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__removeLineOperationResponse);
	if (soap_out_PointerTo_ns1__removeLineOperationResponse(soap, tag?tag:"ns1:removeLineOperationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__removeLineOperationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__removeLineOperationResponse(struct soap *soap, _ns1__removeLineOperationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__removeLineOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__removeLineOperation(struct soap *soap, _ns1__removeLineOperation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__removeLineOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__removeLineOperation(struct soap *soap, const char *tag, int id, _ns1__removeLineOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__removeLineOperation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__removeLineOperation ** SOAP_FMAC4 soap_in_PointerTo_ns1__removeLineOperation(struct soap *soap, const char *tag, _ns1__removeLineOperation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__removeLineOperation **)soap_malloc(soap, sizeof(_ns1__removeLineOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__removeLineOperation *)soap_instantiate__ns1__removeLineOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__removeLineOperation ** p = (_ns1__removeLineOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__removeLineOperation, sizeof(_ns1__removeLineOperation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__removeLineOperation(struct soap *soap, _ns1__removeLineOperation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__removeLineOperation);
	if (soap_out_PointerTo_ns1__removeLineOperation(soap, tag?tag:"ns1:removeLineOperation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__removeLineOperation ** SOAP_FMAC4 soap_get_PointerTo_ns1__removeLineOperation(struct soap *soap, _ns1__removeLineOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__removeLineOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__addLineOperationResponse(struct soap *soap, _ns1__addLineOperationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__addLineOperationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__addLineOperationResponse(struct soap *soap, const char *tag, int id, _ns1__addLineOperationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__addLineOperationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__addLineOperationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__addLineOperationResponse(struct soap *soap, const char *tag, _ns1__addLineOperationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__addLineOperationResponse **)soap_malloc(soap, sizeof(_ns1__addLineOperationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__addLineOperationResponse *)soap_instantiate__ns1__addLineOperationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__addLineOperationResponse ** p = (_ns1__addLineOperationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__addLineOperationResponse, sizeof(_ns1__addLineOperationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__addLineOperationResponse(struct soap *soap, _ns1__addLineOperationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__addLineOperationResponse);
	if (soap_out_PointerTo_ns1__addLineOperationResponse(soap, tag?tag:"ns1:addLineOperationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__addLineOperationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__addLineOperationResponse(struct soap *soap, _ns1__addLineOperationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__addLineOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__addLineOperation(struct soap *soap, _ns1__addLineOperation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__addLineOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__addLineOperation(struct soap *soap, const char *tag, int id, _ns1__addLineOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__addLineOperation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__addLineOperation ** SOAP_FMAC4 soap_in_PointerTo_ns1__addLineOperation(struct soap *soap, const char *tag, _ns1__addLineOperation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__addLineOperation **)soap_malloc(soap, sizeof(_ns1__addLineOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__addLineOperation *)soap_instantiate__ns1__addLineOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__addLineOperation ** p = (_ns1__addLineOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__addLineOperation, sizeof(_ns1__addLineOperation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__addLineOperation(struct soap *soap, _ns1__addLineOperation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__addLineOperation);
	if (soap_out_PointerTo_ns1__addLineOperation(soap, tag?tag:"ns1:addLineOperation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__addLineOperation ** SOAP_FMAC4 soap_get_PointerTo_ns1__addLineOperation(struct soap *soap, _ns1__addLineOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__addLineOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__editLcuOperationResponse(struct soap *soap, _ns1__editLcuOperationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__editLcuOperationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__editLcuOperationResponse(struct soap *soap, const char *tag, int id, _ns1__editLcuOperationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__editLcuOperationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__editLcuOperationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__editLcuOperationResponse(struct soap *soap, const char *tag, _ns1__editLcuOperationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__editLcuOperationResponse **)soap_malloc(soap, sizeof(_ns1__editLcuOperationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__editLcuOperationResponse *)soap_instantiate__ns1__editLcuOperationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__editLcuOperationResponse ** p = (_ns1__editLcuOperationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__editLcuOperationResponse, sizeof(_ns1__editLcuOperationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__editLcuOperationResponse(struct soap *soap, _ns1__editLcuOperationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__editLcuOperationResponse);
	if (soap_out_PointerTo_ns1__editLcuOperationResponse(soap, tag?tag:"ns1:editLcuOperationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__editLcuOperationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__editLcuOperationResponse(struct soap *soap, _ns1__editLcuOperationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__editLcuOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__editLcuOperation(struct soap *soap, _ns1__editLcuOperation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__editLcuOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__editLcuOperation(struct soap *soap, const char *tag, int id, _ns1__editLcuOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__editLcuOperation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__editLcuOperation ** SOAP_FMAC4 soap_in_PointerTo_ns1__editLcuOperation(struct soap *soap, const char *tag, _ns1__editLcuOperation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__editLcuOperation **)soap_malloc(soap, sizeof(_ns1__editLcuOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__editLcuOperation *)soap_instantiate__ns1__editLcuOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__editLcuOperation ** p = (_ns1__editLcuOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__editLcuOperation, sizeof(_ns1__editLcuOperation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__editLcuOperation(struct soap *soap, _ns1__editLcuOperation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__editLcuOperation);
	if (soap_out_PointerTo_ns1__editLcuOperation(soap, tag?tag:"ns1:editLcuOperation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__editLcuOperation ** SOAP_FMAC4 soap_get_PointerTo_ns1__editLcuOperation(struct soap *soap, _ns1__editLcuOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__editLcuOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__removeLcuOperationResponse(struct soap *soap, _ns1__removeLcuOperationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__removeLcuOperationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__removeLcuOperationResponse(struct soap *soap, const char *tag, int id, _ns1__removeLcuOperationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__removeLcuOperationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__removeLcuOperationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__removeLcuOperationResponse(struct soap *soap, const char *tag, _ns1__removeLcuOperationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__removeLcuOperationResponse **)soap_malloc(soap, sizeof(_ns1__removeLcuOperationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__removeLcuOperationResponse *)soap_instantiate__ns1__removeLcuOperationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__removeLcuOperationResponse ** p = (_ns1__removeLcuOperationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__removeLcuOperationResponse, sizeof(_ns1__removeLcuOperationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__removeLcuOperationResponse(struct soap *soap, _ns1__removeLcuOperationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__removeLcuOperationResponse);
	if (soap_out_PointerTo_ns1__removeLcuOperationResponse(soap, tag?tag:"ns1:removeLcuOperationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__removeLcuOperationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__removeLcuOperationResponse(struct soap *soap, _ns1__removeLcuOperationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__removeLcuOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__removeLcuOperation(struct soap *soap, _ns1__removeLcuOperation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__removeLcuOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__removeLcuOperation(struct soap *soap, const char *tag, int id, _ns1__removeLcuOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__removeLcuOperation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__removeLcuOperation ** SOAP_FMAC4 soap_in_PointerTo_ns1__removeLcuOperation(struct soap *soap, const char *tag, _ns1__removeLcuOperation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__removeLcuOperation **)soap_malloc(soap, sizeof(_ns1__removeLcuOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__removeLcuOperation *)soap_instantiate__ns1__removeLcuOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__removeLcuOperation ** p = (_ns1__removeLcuOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__removeLcuOperation, sizeof(_ns1__removeLcuOperation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__removeLcuOperation(struct soap *soap, _ns1__removeLcuOperation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__removeLcuOperation);
	if (soap_out_PointerTo_ns1__removeLcuOperation(soap, tag?tag:"ns1:removeLcuOperation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__removeLcuOperation ** SOAP_FMAC4 soap_get_PointerTo_ns1__removeLcuOperation(struct soap *soap, _ns1__removeLcuOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__removeLcuOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__addLcuOperationResponse(struct soap *soap, _ns1__addLcuOperationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__addLcuOperationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__addLcuOperationResponse(struct soap *soap, const char *tag, int id, _ns1__addLcuOperationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__addLcuOperationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__addLcuOperationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__addLcuOperationResponse(struct soap *soap, const char *tag, _ns1__addLcuOperationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__addLcuOperationResponse **)soap_malloc(soap, sizeof(_ns1__addLcuOperationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__addLcuOperationResponse *)soap_instantiate__ns1__addLcuOperationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__addLcuOperationResponse ** p = (_ns1__addLcuOperationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__addLcuOperationResponse, sizeof(_ns1__addLcuOperationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__addLcuOperationResponse(struct soap *soap, _ns1__addLcuOperationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__addLcuOperationResponse);
	if (soap_out_PointerTo_ns1__addLcuOperationResponse(soap, tag?tag:"ns1:addLcuOperationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__addLcuOperationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__addLcuOperationResponse(struct soap *soap, _ns1__addLcuOperationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__addLcuOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__addLcuOperation(struct soap *soap, _ns1__addLcuOperation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__addLcuOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__addLcuOperation(struct soap *soap, const char *tag, int id, _ns1__addLcuOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__addLcuOperation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__addLcuOperation ** SOAP_FMAC4 soap_in_PointerTo_ns1__addLcuOperation(struct soap *soap, const char *tag, _ns1__addLcuOperation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__addLcuOperation **)soap_malloc(soap, sizeof(_ns1__addLcuOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__addLcuOperation *)soap_instantiate__ns1__addLcuOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__addLcuOperation ** p = (_ns1__addLcuOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__addLcuOperation, sizeof(_ns1__addLcuOperation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__addLcuOperation(struct soap *soap, _ns1__addLcuOperation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__addLcuOperation);
	if (soap_out_PointerTo_ns1__addLcuOperation(soap, tag?tag:"ns1:addLcuOperation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__addLcuOperation ** SOAP_FMAC4 soap_get_PointerTo_ns1__addLcuOperation(struct soap *soap, _ns1__addLcuOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__addLcuOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__editDcuOperationResponse(struct soap *soap, _ns1__editDcuOperationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__editDcuOperationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__editDcuOperationResponse(struct soap *soap, const char *tag, int id, _ns1__editDcuOperationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__editDcuOperationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__editDcuOperationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__editDcuOperationResponse(struct soap *soap, const char *tag, _ns1__editDcuOperationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__editDcuOperationResponse **)soap_malloc(soap, sizeof(_ns1__editDcuOperationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__editDcuOperationResponse *)soap_instantiate__ns1__editDcuOperationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__editDcuOperationResponse ** p = (_ns1__editDcuOperationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__editDcuOperationResponse, sizeof(_ns1__editDcuOperationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__editDcuOperationResponse(struct soap *soap, _ns1__editDcuOperationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__editDcuOperationResponse);
	if (soap_out_PointerTo_ns1__editDcuOperationResponse(soap, tag?tag:"ns1:editDcuOperationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__editDcuOperationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__editDcuOperationResponse(struct soap *soap, _ns1__editDcuOperationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__editDcuOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__editDcuOperation(struct soap *soap, _ns1__editDcuOperation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__editDcuOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__editDcuOperation(struct soap *soap, const char *tag, int id, _ns1__editDcuOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__editDcuOperation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__editDcuOperation ** SOAP_FMAC4 soap_in_PointerTo_ns1__editDcuOperation(struct soap *soap, const char *tag, _ns1__editDcuOperation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__editDcuOperation **)soap_malloc(soap, sizeof(_ns1__editDcuOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__editDcuOperation *)soap_instantiate__ns1__editDcuOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__editDcuOperation ** p = (_ns1__editDcuOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__editDcuOperation, sizeof(_ns1__editDcuOperation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__editDcuOperation(struct soap *soap, _ns1__editDcuOperation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__editDcuOperation);
	if (soap_out_PointerTo_ns1__editDcuOperation(soap, tag?tag:"ns1:editDcuOperation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__editDcuOperation ** SOAP_FMAC4 soap_get_PointerTo_ns1__editDcuOperation(struct soap *soap, _ns1__editDcuOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__editDcuOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__removeDcuOperationResponse(struct soap *soap, _ns1__removeDcuOperationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__removeDcuOperationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__removeDcuOperationResponse(struct soap *soap, const char *tag, int id, _ns1__removeDcuOperationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__removeDcuOperationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__removeDcuOperationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__removeDcuOperationResponse(struct soap *soap, const char *tag, _ns1__removeDcuOperationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__removeDcuOperationResponse **)soap_malloc(soap, sizeof(_ns1__removeDcuOperationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__removeDcuOperationResponse *)soap_instantiate__ns1__removeDcuOperationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__removeDcuOperationResponse ** p = (_ns1__removeDcuOperationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__removeDcuOperationResponse, sizeof(_ns1__removeDcuOperationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__removeDcuOperationResponse(struct soap *soap, _ns1__removeDcuOperationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__removeDcuOperationResponse);
	if (soap_out_PointerTo_ns1__removeDcuOperationResponse(soap, tag?tag:"ns1:removeDcuOperationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__removeDcuOperationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__removeDcuOperationResponse(struct soap *soap, _ns1__removeDcuOperationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__removeDcuOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__removeDcuOperation(struct soap *soap, _ns1__removeDcuOperation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__removeDcuOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__removeDcuOperation(struct soap *soap, const char *tag, int id, _ns1__removeDcuOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__removeDcuOperation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__removeDcuOperation ** SOAP_FMAC4 soap_in_PointerTo_ns1__removeDcuOperation(struct soap *soap, const char *tag, _ns1__removeDcuOperation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__removeDcuOperation **)soap_malloc(soap, sizeof(_ns1__removeDcuOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__removeDcuOperation *)soap_instantiate__ns1__removeDcuOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__removeDcuOperation ** p = (_ns1__removeDcuOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__removeDcuOperation, sizeof(_ns1__removeDcuOperation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__removeDcuOperation(struct soap *soap, _ns1__removeDcuOperation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__removeDcuOperation);
	if (soap_out_PointerTo_ns1__removeDcuOperation(soap, tag?tag:"ns1:removeDcuOperation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__removeDcuOperation ** SOAP_FMAC4 soap_get_PointerTo_ns1__removeDcuOperation(struct soap *soap, _ns1__removeDcuOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__removeDcuOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__addDcuOperationResponse(struct soap *soap, _ns1__addDcuOperationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__addDcuOperationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__addDcuOperationResponse(struct soap *soap, const char *tag, int id, _ns1__addDcuOperationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__addDcuOperationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__addDcuOperationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__addDcuOperationResponse(struct soap *soap, const char *tag, _ns1__addDcuOperationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__addDcuOperationResponse **)soap_malloc(soap, sizeof(_ns1__addDcuOperationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__addDcuOperationResponse *)soap_instantiate__ns1__addDcuOperationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__addDcuOperationResponse ** p = (_ns1__addDcuOperationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__addDcuOperationResponse, sizeof(_ns1__addDcuOperationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__addDcuOperationResponse(struct soap *soap, _ns1__addDcuOperationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__addDcuOperationResponse);
	if (soap_out_PointerTo_ns1__addDcuOperationResponse(soap, tag?tag:"ns1:addDcuOperationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__addDcuOperationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__addDcuOperationResponse(struct soap *soap, _ns1__addDcuOperationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__addDcuOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__addDcuOperation(struct soap *soap, _ns1__addDcuOperation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__addDcuOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__addDcuOperation(struct soap *soap, const char *tag, int id, _ns1__addDcuOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__addDcuOperation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__addDcuOperation ** SOAP_FMAC4 soap_in_PointerTo_ns1__addDcuOperation(struct soap *soap, const char *tag, _ns1__addDcuOperation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__addDcuOperation **)soap_malloc(soap, sizeof(_ns1__addDcuOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__addDcuOperation *)soap_instantiate__ns1__addDcuOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__addDcuOperation ** p = (_ns1__addDcuOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__addDcuOperation, sizeof(_ns1__addDcuOperation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__addDcuOperation(struct soap *soap, _ns1__addDcuOperation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__addDcuOperation);
	if (soap_out_PointerTo_ns1__addDcuOperation(soap, tag?tag:"ns1:addDcuOperation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__addDcuOperation ** SOAP_FMAC4 soap_get_PointerTo_ns1__addDcuOperation(struct soap *soap, _ns1__addDcuOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__addDcuOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getLineListOperationResponse(struct soap *soap, _ns1__getLineListOperationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getLineListOperationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getLineListOperationResponse(struct soap *soap, const char *tag, int id, _ns1__getLineListOperationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getLineListOperationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getLineListOperationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getLineListOperationResponse(struct soap *soap, const char *tag, _ns1__getLineListOperationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getLineListOperationResponse **)soap_malloc(soap, sizeof(_ns1__getLineListOperationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getLineListOperationResponse *)soap_instantiate__ns1__getLineListOperationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getLineListOperationResponse ** p = (_ns1__getLineListOperationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getLineListOperationResponse, sizeof(_ns1__getLineListOperationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getLineListOperationResponse(struct soap *soap, _ns1__getLineListOperationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getLineListOperationResponse);
	if (soap_out_PointerTo_ns1__getLineListOperationResponse(soap, tag?tag:"ns1:getLineListOperationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getLineListOperationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getLineListOperationResponse(struct soap *soap, _ns1__getLineListOperationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getLineListOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getLineListOperation(struct soap *soap, _ns1__getLineListOperation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getLineListOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getLineListOperation(struct soap *soap, const char *tag, int id, _ns1__getLineListOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getLineListOperation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getLineListOperation ** SOAP_FMAC4 soap_in_PointerTo_ns1__getLineListOperation(struct soap *soap, const char *tag, _ns1__getLineListOperation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getLineListOperation **)soap_malloc(soap, sizeof(_ns1__getLineListOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getLineListOperation *)soap_instantiate__ns1__getLineListOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getLineListOperation ** p = (_ns1__getLineListOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getLineListOperation, sizeof(_ns1__getLineListOperation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getLineListOperation(struct soap *soap, _ns1__getLineListOperation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getLineListOperation);
	if (soap_out_PointerTo_ns1__getLineListOperation(soap, tag?tag:"ns1:getLineListOperation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getLineListOperation ** SOAP_FMAC4 soap_get_PointerTo_ns1__getLineListOperation(struct soap *soap, _ns1__getLineListOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getLineListOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__updateRuntimeForUserOperationResponse(struct soap *soap, _ns1__updateRuntimeForUserOperationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__updateRuntimeForUserOperationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__updateRuntimeForUserOperationResponse(struct soap *soap, const char *tag, int id, _ns1__updateRuntimeForUserOperationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__updateRuntimeForUserOperationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__updateRuntimeForUserOperationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__updateRuntimeForUserOperationResponse(struct soap *soap, const char *tag, _ns1__updateRuntimeForUserOperationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__updateRuntimeForUserOperationResponse **)soap_malloc(soap, sizeof(_ns1__updateRuntimeForUserOperationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__updateRuntimeForUserOperationResponse *)soap_instantiate__ns1__updateRuntimeForUserOperationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__updateRuntimeForUserOperationResponse ** p = (_ns1__updateRuntimeForUserOperationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__updateRuntimeForUserOperationResponse, sizeof(_ns1__updateRuntimeForUserOperationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__updateRuntimeForUserOperationResponse(struct soap *soap, _ns1__updateRuntimeForUserOperationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__updateRuntimeForUserOperationResponse);
	if (soap_out_PointerTo_ns1__updateRuntimeForUserOperationResponse(soap, tag?tag:"ns1:updateRuntimeForUserOperationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__updateRuntimeForUserOperationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__updateRuntimeForUserOperationResponse(struct soap *soap, _ns1__updateRuntimeForUserOperationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__updateRuntimeForUserOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__updateRuntimeForUserOperation(struct soap *soap, _ns1__updateRuntimeForUserOperation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__updateRuntimeForUserOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__updateRuntimeForUserOperation(struct soap *soap, const char *tag, int id, _ns1__updateRuntimeForUserOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__updateRuntimeForUserOperation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__updateRuntimeForUserOperation ** SOAP_FMAC4 soap_in_PointerTo_ns1__updateRuntimeForUserOperation(struct soap *soap, const char *tag, _ns1__updateRuntimeForUserOperation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__updateRuntimeForUserOperation **)soap_malloc(soap, sizeof(_ns1__updateRuntimeForUserOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__updateRuntimeForUserOperation *)soap_instantiate__ns1__updateRuntimeForUserOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__updateRuntimeForUserOperation ** p = (_ns1__updateRuntimeForUserOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__updateRuntimeForUserOperation, sizeof(_ns1__updateRuntimeForUserOperation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__updateRuntimeForUserOperation(struct soap *soap, _ns1__updateRuntimeForUserOperation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__updateRuntimeForUserOperation);
	if (soap_out_PointerTo_ns1__updateRuntimeForUserOperation(soap, tag?tag:"ns1:updateRuntimeForUserOperation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__updateRuntimeForUserOperation ** SOAP_FMAC4 soap_get_PointerTo_ns1__updateRuntimeForUserOperation(struct soap *soap, _ns1__updateRuntimeForUserOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__updateRuntimeForUserOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getLcuListOperationResponse(struct soap *soap, _ns1__getLcuListOperationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getLcuListOperationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getLcuListOperationResponse(struct soap *soap, const char *tag, int id, _ns1__getLcuListOperationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getLcuListOperationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getLcuListOperationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getLcuListOperationResponse(struct soap *soap, const char *tag, _ns1__getLcuListOperationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getLcuListOperationResponse **)soap_malloc(soap, sizeof(_ns1__getLcuListOperationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getLcuListOperationResponse *)soap_instantiate__ns1__getLcuListOperationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getLcuListOperationResponse ** p = (_ns1__getLcuListOperationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getLcuListOperationResponse, sizeof(_ns1__getLcuListOperationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getLcuListOperationResponse(struct soap *soap, _ns1__getLcuListOperationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getLcuListOperationResponse);
	if (soap_out_PointerTo_ns1__getLcuListOperationResponse(soap, tag?tag:"ns1:getLcuListOperationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getLcuListOperationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getLcuListOperationResponse(struct soap *soap, _ns1__getLcuListOperationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getLcuListOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getLcuListOperation(struct soap *soap, _ns1__getLcuListOperation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getLcuListOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getLcuListOperation(struct soap *soap, const char *tag, int id, _ns1__getLcuListOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getLcuListOperation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getLcuListOperation ** SOAP_FMAC4 soap_in_PointerTo_ns1__getLcuListOperation(struct soap *soap, const char *tag, _ns1__getLcuListOperation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getLcuListOperation **)soap_malloc(soap, sizeof(_ns1__getLcuListOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getLcuListOperation *)soap_instantiate__ns1__getLcuListOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getLcuListOperation ** p = (_ns1__getLcuListOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getLcuListOperation, sizeof(_ns1__getLcuListOperation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getLcuListOperation(struct soap *soap, _ns1__getLcuListOperation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getLcuListOperation);
	if (soap_out_PointerTo_ns1__getLcuListOperation(soap, tag?tag:"ns1:getLcuListOperation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getLcuListOperation ** SOAP_FMAC4 soap_get_PointerTo_ns1__getLcuListOperation(struct soap *soap, _ns1__getLcuListOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getLcuListOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getDcuListOperationResponse(struct soap *soap, _ns1__getDcuListOperationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getDcuListOperationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getDcuListOperationResponse(struct soap *soap, const char *tag, int id, _ns1__getDcuListOperationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getDcuListOperationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getDcuListOperationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getDcuListOperationResponse(struct soap *soap, const char *tag, _ns1__getDcuListOperationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getDcuListOperationResponse **)soap_malloc(soap, sizeof(_ns1__getDcuListOperationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getDcuListOperationResponse *)soap_instantiate__ns1__getDcuListOperationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getDcuListOperationResponse ** p = (_ns1__getDcuListOperationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getDcuListOperationResponse, sizeof(_ns1__getDcuListOperationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getDcuListOperationResponse(struct soap *soap, _ns1__getDcuListOperationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getDcuListOperationResponse);
	if (soap_out_PointerTo_ns1__getDcuListOperationResponse(soap, tag?tag:"ns1:getDcuListOperationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getDcuListOperationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getDcuListOperationResponse(struct soap *soap, _ns1__getDcuListOperationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getDcuListOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getDcuListOperation(struct soap *soap, _ns1__getDcuListOperation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getDcuListOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getDcuListOperation(struct soap *soap, const char *tag, int id, _ns1__getDcuListOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getDcuListOperation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getDcuListOperation ** SOAP_FMAC4 soap_in_PointerTo_ns1__getDcuListOperation(struct soap *soap, const char *tag, _ns1__getDcuListOperation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getDcuListOperation **)soap_malloc(soap, sizeof(_ns1__getDcuListOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getDcuListOperation *)soap_instantiate__ns1__getDcuListOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getDcuListOperation ** p = (_ns1__getDcuListOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getDcuListOperation, sizeof(_ns1__getDcuListOperation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getDcuListOperation(struct soap *soap, _ns1__getDcuListOperation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getDcuListOperation);
	if (soap_out_PointerTo_ns1__getDcuListOperation(soap, tag?tag:"ns1:getDcuListOperation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getDcuListOperation ** SOAP_FMAC4 soap_get_PointerTo_ns1__getDcuListOperation(struct soap *soap, _ns1__getDcuListOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getDcuListOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__LogoutOperationResponse(struct soap *soap, _ns1__LogoutOperationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__LogoutOperationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__LogoutOperationResponse(struct soap *soap, const char *tag, int id, _ns1__LogoutOperationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__LogoutOperationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__LogoutOperationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__LogoutOperationResponse(struct soap *soap, const char *tag, _ns1__LogoutOperationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__LogoutOperationResponse **)soap_malloc(soap, sizeof(_ns1__LogoutOperationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__LogoutOperationResponse *)soap_instantiate__ns1__LogoutOperationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__LogoutOperationResponse ** p = (_ns1__LogoutOperationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__LogoutOperationResponse, sizeof(_ns1__LogoutOperationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__LogoutOperationResponse(struct soap *soap, _ns1__LogoutOperationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__LogoutOperationResponse);
	if (soap_out_PointerTo_ns1__LogoutOperationResponse(soap, tag?tag:"ns1:LogoutOperationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__LogoutOperationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__LogoutOperationResponse(struct soap *soap, _ns1__LogoutOperationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__LogoutOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__LogoutOperation(struct soap *soap, _ns1__LogoutOperation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__LogoutOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__LogoutOperation(struct soap *soap, const char *tag, int id, _ns1__LogoutOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__LogoutOperation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__LogoutOperation ** SOAP_FMAC4 soap_in_PointerTo_ns1__LogoutOperation(struct soap *soap, const char *tag, _ns1__LogoutOperation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__LogoutOperation **)soap_malloc(soap, sizeof(_ns1__LogoutOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__LogoutOperation *)soap_instantiate__ns1__LogoutOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__LogoutOperation ** p = (_ns1__LogoutOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__LogoutOperation, sizeof(_ns1__LogoutOperation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__LogoutOperation(struct soap *soap, _ns1__LogoutOperation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__LogoutOperation);
	if (soap_out_PointerTo_ns1__LogoutOperation(soap, tag?tag:"ns1:LogoutOperation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__LogoutOperation ** SOAP_FMAC4 soap_get_PointerTo_ns1__LogoutOperation(struct soap *soap, _ns1__LogoutOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__LogoutOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__LoginPcOperationResponse(struct soap *soap, _ns1__LoginPcOperationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__LoginPcOperationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__LoginPcOperationResponse(struct soap *soap, const char *tag, int id, _ns1__LoginPcOperationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__LoginPcOperationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__LoginPcOperationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__LoginPcOperationResponse(struct soap *soap, const char *tag, _ns1__LoginPcOperationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__LoginPcOperationResponse **)soap_malloc(soap, sizeof(_ns1__LoginPcOperationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__LoginPcOperationResponse *)soap_instantiate__ns1__LoginPcOperationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__LoginPcOperationResponse ** p = (_ns1__LoginPcOperationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__LoginPcOperationResponse, sizeof(_ns1__LoginPcOperationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__LoginPcOperationResponse(struct soap *soap, _ns1__LoginPcOperationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__LoginPcOperationResponse);
	if (soap_out_PointerTo_ns1__LoginPcOperationResponse(soap, tag?tag:"ns1:LoginPcOperationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__LoginPcOperationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__LoginPcOperationResponse(struct soap *soap, _ns1__LoginPcOperationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__LoginPcOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__LoginPcOperation(struct soap *soap, _ns1__LoginPcOperation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__LoginPcOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__LoginPcOperation(struct soap *soap, const char *tag, int id, _ns1__LoginPcOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__LoginPcOperation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__LoginPcOperation ** SOAP_FMAC4 soap_in_PointerTo_ns1__LoginPcOperation(struct soap *soap, const char *tag, _ns1__LoginPcOperation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__LoginPcOperation **)soap_malloc(soap, sizeof(_ns1__LoginPcOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__LoginPcOperation *)soap_instantiate__ns1__LoginPcOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__LoginPcOperation ** p = (_ns1__LoginPcOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__LoginPcOperation, sizeof(_ns1__LoginPcOperation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__LoginPcOperation(struct soap *soap, _ns1__LoginPcOperation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__LoginPcOperation);
	if (soap_out_PointerTo_ns1__LoginPcOperation(soap, tag?tag:"ns1:LoginPcOperation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__LoginPcOperation ** SOAP_FMAC4 soap_get_PointerTo_ns1__LoginPcOperation(struct soap *soap, _ns1__LoginPcOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__LoginPcOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__LoginOperationResponse(struct soap *soap, _ns1__LoginOperationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__LoginOperationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__LoginOperationResponse(struct soap *soap, const char *tag, int id, _ns1__LoginOperationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__LoginOperationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__LoginOperationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__LoginOperationResponse(struct soap *soap, const char *tag, _ns1__LoginOperationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__LoginOperationResponse **)soap_malloc(soap, sizeof(_ns1__LoginOperationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__LoginOperationResponse *)soap_instantiate__ns1__LoginOperationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__LoginOperationResponse ** p = (_ns1__LoginOperationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__LoginOperationResponse, sizeof(_ns1__LoginOperationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__LoginOperationResponse(struct soap *soap, _ns1__LoginOperationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__LoginOperationResponse);
	if (soap_out_PointerTo_ns1__LoginOperationResponse(soap, tag?tag:"ns1:LoginOperationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__LoginOperationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__LoginOperationResponse(struct soap *soap, _ns1__LoginOperationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__LoginOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__LoginOperation(struct soap *soap, _ns1__LoginOperation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__LoginOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__LoginOperation(struct soap *soap, const char *tag, int id, _ns1__LoginOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__LoginOperation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__LoginOperation ** SOAP_FMAC4 soap_in_PointerTo_ns1__LoginOperation(struct soap *soap, const char *tag, _ns1__LoginOperation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__LoginOperation **)soap_malloc(soap, sizeof(_ns1__LoginOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__LoginOperation *)soap_instantiate__ns1__LoginOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__LoginOperation ** p = (_ns1__LoginOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__LoginOperation, sizeof(_ns1__LoginOperation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__LoginOperation(struct soap *soap, _ns1__LoginOperation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__LoginOperation);
	if (soap_out_PointerTo_ns1__LoginOperation(soap, tag?tag:"ns1:LoginOperation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__LoginOperation ** SOAP_FMAC4 soap_get_PointerTo_ns1__LoginOperation(struct soap *soap, _ns1__LoginOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__LoginOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__LCULOGINFOType(struct soap *soap, ns1__LCULOGINFOType **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__LCULOGINFOType))
		soap_serialize_PointerTons1__LCULOGINFOType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__LCULOGINFOType(struct soap *soap, const char *tag, int id, ns1__LCULOGINFOType **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__LCULOGINFOType);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__LCULOGINFOType(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__LCULOGINFOType *** SOAP_FMAC4 soap_in_PointerToPointerTons1__LCULOGINFOType(struct soap *soap, const char *tag, ns1__LCULOGINFOType ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__LCULOGINFOType ***)soap_malloc(soap, sizeof(ns1__LCULOGINFOType **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__LCULOGINFOType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__LCULOGINFOType ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__LCULOGINFOType, sizeof(ns1__LCULOGINFOType *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__LCULOGINFOType(struct soap *soap, ns1__LCULOGINFOType **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__LCULOGINFOType);
	if (soap_out_PointerToPointerTons1__LCULOGINFOType(soap, tag?tag:"ns1:LCULOGINFOType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__LCULOGINFOType *** SOAP_FMAC4 soap_get_PointerToPointerTons1__LCULOGINFOType(struct soap *soap, ns1__LCULOGINFOType ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__LCULOGINFOType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__LCULOGINFOType(struct soap *soap, ns1__LCULOGINFOType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__LCULOGINFOType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__LCULOGINFOType(struct soap *soap, const char *tag, int id, ns1__LCULOGINFOType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__LCULOGINFOType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__LCULOGINFOType ** SOAP_FMAC4 soap_in_PointerTons1__LCULOGINFOType(struct soap *soap, const char *tag, ns1__LCULOGINFOType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__LCULOGINFOType **)soap_malloc(soap, sizeof(ns1__LCULOGINFOType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__LCULOGINFOType *)soap_instantiate_ns1__LCULOGINFOType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__LCULOGINFOType ** p = (ns1__LCULOGINFOType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__LCULOGINFOType, sizeof(ns1__LCULOGINFOType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__LCULOGINFOType(struct soap *soap, ns1__LCULOGINFOType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__LCULOGINFOType);
	if (soap_out_PointerTons1__LCULOGINFOType(soap, tag?tag:"ns1:LCULOGINFOType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__LCULOGINFOType ** SOAP_FMAC4 soap_get_PointerTons1__LCULOGINFOType(struct soap *soap, ns1__LCULOGINFOType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__LCULOGINFOType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__LISTSCHEDULE_USCOREINFO_USCOREType(struct soap *soap, ns1__LISTSCHEDULE_USCOREINFO_USCOREType **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__LISTSCHEDULE_USCOREINFO_USCOREType))
		soap_serialize_PointerTons1__LISTSCHEDULE_USCOREINFO_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__LISTSCHEDULE_USCOREINFO_USCOREType(struct soap *soap, const char *tag, int id, ns1__LISTSCHEDULE_USCOREINFO_USCOREType **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__LISTSCHEDULE_USCOREINFO_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__LISTSCHEDULE_USCOREINFO_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__LISTSCHEDULE_USCOREINFO_USCOREType *** SOAP_FMAC4 soap_in_PointerToPointerTons1__LISTSCHEDULE_USCOREINFO_USCOREType(struct soap *soap, const char *tag, ns1__LISTSCHEDULE_USCOREINFO_USCOREType ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__LISTSCHEDULE_USCOREINFO_USCOREType ***)soap_malloc(soap, sizeof(ns1__LISTSCHEDULE_USCOREINFO_USCOREType **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__LISTSCHEDULE_USCOREINFO_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__LISTSCHEDULE_USCOREINFO_USCOREType ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__LISTSCHEDULE_USCOREINFO_USCOREType, sizeof(ns1__LISTSCHEDULE_USCOREINFO_USCOREType *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__LISTSCHEDULE_USCOREINFO_USCOREType(struct soap *soap, ns1__LISTSCHEDULE_USCOREINFO_USCOREType **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__LISTSCHEDULE_USCOREINFO_USCOREType);
	if (soap_out_PointerToPointerTons1__LISTSCHEDULE_USCOREINFO_USCOREType(soap, tag?tag:"ns1:LISTSCHEDULE_INFO_Type", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__LISTSCHEDULE_USCOREINFO_USCOREType *** SOAP_FMAC4 soap_get_PointerToPointerTons1__LISTSCHEDULE_USCOREINFO_USCOREType(struct soap *soap, ns1__LISTSCHEDULE_USCOREINFO_USCOREType ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__LISTSCHEDULE_USCOREINFO_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__LISTSCHEDULE_USCOREINFO_USCOREType(struct soap *soap, ns1__LISTSCHEDULE_USCOREINFO_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__LISTSCHEDULE_USCOREINFO_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__LISTSCHEDULE_USCOREINFO_USCOREType(struct soap *soap, const char *tag, int id, ns1__LISTSCHEDULE_USCOREINFO_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__LISTSCHEDULE_USCOREINFO_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__LISTSCHEDULE_USCOREINFO_USCOREType ** SOAP_FMAC4 soap_in_PointerTons1__LISTSCHEDULE_USCOREINFO_USCOREType(struct soap *soap, const char *tag, ns1__LISTSCHEDULE_USCOREINFO_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__LISTSCHEDULE_USCOREINFO_USCOREType **)soap_malloc(soap, sizeof(ns1__LISTSCHEDULE_USCOREINFO_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__LISTSCHEDULE_USCOREINFO_USCOREType *)soap_instantiate_ns1__LISTSCHEDULE_USCOREINFO_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__LISTSCHEDULE_USCOREINFO_USCOREType ** p = (ns1__LISTSCHEDULE_USCOREINFO_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__LISTSCHEDULE_USCOREINFO_USCOREType, sizeof(ns1__LISTSCHEDULE_USCOREINFO_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__LISTSCHEDULE_USCOREINFO_USCOREType(struct soap *soap, ns1__LISTSCHEDULE_USCOREINFO_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__LISTSCHEDULE_USCOREINFO_USCOREType);
	if (soap_out_PointerTons1__LISTSCHEDULE_USCOREINFO_USCOREType(soap, tag?tag:"ns1:LISTSCHEDULE_INFO_Type", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__LISTSCHEDULE_USCOREINFO_USCOREType ** SOAP_FMAC4 soap_get_PointerTons1__LISTSCHEDULE_USCOREINFO_USCOREType(struct soap *soap, ns1__LISTSCHEDULE_USCOREINFO_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__LISTSCHEDULE_USCOREINFO_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__DAYSCHEDULE_USCOREINFO_USCOREType(struct soap *soap, ns1__DAYSCHEDULE_USCOREINFO_USCOREType **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__DAYSCHEDULE_USCOREINFO_USCOREType))
		soap_serialize_PointerTons1__DAYSCHEDULE_USCOREINFO_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__DAYSCHEDULE_USCOREINFO_USCOREType(struct soap *soap, const char *tag, int id, ns1__DAYSCHEDULE_USCOREINFO_USCOREType **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__DAYSCHEDULE_USCOREINFO_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__DAYSCHEDULE_USCOREINFO_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__DAYSCHEDULE_USCOREINFO_USCOREType *** SOAP_FMAC4 soap_in_PointerToPointerTons1__DAYSCHEDULE_USCOREINFO_USCOREType(struct soap *soap, const char *tag, ns1__DAYSCHEDULE_USCOREINFO_USCOREType ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__DAYSCHEDULE_USCOREINFO_USCOREType ***)soap_malloc(soap, sizeof(ns1__DAYSCHEDULE_USCOREINFO_USCOREType **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__DAYSCHEDULE_USCOREINFO_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__DAYSCHEDULE_USCOREINFO_USCOREType ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__DAYSCHEDULE_USCOREINFO_USCOREType, sizeof(ns1__DAYSCHEDULE_USCOREINFO_USCOREType *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__DAYSCHEDULE_USCOREINFO_USCOREType(struct soap *soap, ns1__DAYSCHEDULE_USCOREINFO_USCOREType **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__DAYSCHEDULE_USCOREINFO_USCOREType);
	if (soap_out_PointerToPointerTons1__DAYSCHEDULE_USCOREINFO_USCOREType(soap, tag?tag:"ns1:DAYSCHEDULE_INFO_Type", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__DAYSCHEDULE_USCOREINFO_USCOREType *** SOAP_FMAC4 soap_get_PointerToPointerTons1__DAYSCHEDULE_USCOREINFO_USCOREType(struct soap *soap, ns1__DAYSCHEDULE_USCOREINFO_USCOREType ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__DAYSCHEDULE_USCOREINFO_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__DAYSCHEDULE_USCOREINFO_USCOREType(struct soap *soap, ns1__DAYSCHEDULE_USCOREINFO_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__DAYSCHEDULE_USCOREINFO_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__DAYSCHEDULE_USCOREINFO_USCOREType(struct soap *soap, const char *tag, int id, ns1__DAYSCHEDULE_USCOREINFO_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__DAYSCHEDULE_USCOREINFO_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__DAYSCHEDULE_USCOREINFO_USCOREType ** SOAP_FMAC4 soap_in_PointerTons1__DAYSCHEDULE_USCOREINFO_USCOREType(struct soap *soap, const char *tag, ns1__DAYSCHEDULE_USCOREINFO_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__DAYSCHEDULE_USCOREINFO_USCOREType **)soap_malloc(soap, sizeof(ns1__DAYSCHEDULE_USCOREINFO_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__DAYSCHEDULE_USCOREINFO_USCOREType *)soap_instantiate_ns1__DAYSCHEDULE_USCOREINFO_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__DAYSCHEDULE_USCOREINFO_USCOREType ** p = (ns1__DAYSCHEDULE_USCOREINFO_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__DAYSCHEDULE_USCOREINFO_USCOREType, sizeof(ns1__DAYSCHEDULE_USCOREINFO_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__DAYSCHEDULE_USCOREINFO_USCOREType(struct soap *soap, ns1__DAYSCHEDULE_USCOREINFO_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__DAYSCHEDULE_USCOREINFO_USCOREType);
	if (soap_out_PointerTons1__DAYSCHEDULE_USCOREINFO_USCOREType(soap, tag?tag:"ns1:DAYSCHEDULE_INFO_Type", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__DAYSCHEDULE_USCOREINFO_USCOREType ** SOAP_FMAC4 soap_get_PointerTons1__DAYSCHEDULE_USCOREINFO_USCOREType(struct soap *soap, ns1__DAYSCHEDULE_USCOREINFO_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__DAYSCHEDULE_USCOREINFO_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__PROGRAM_USCOREINFO_USCOREType(struct soap *soap, ns1__PROGRAM_USCOREINFO_USCOREType **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__PROGRAM_USCOREINFO_USCOREType))
		soap_serialize_PointerTons1__PROGRAM_USCOREINFO_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__PROGRAM_USCOREINFO_USCOREType(struct soap *soap, const char *tag, int id, ns1__PROGRAM_USCOREINFO_USCOREType **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__PROGRAM_USCOREINFO_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__PROGRAM_USCOREINFO_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__PROGRAM_USCOREINFO_USCOREType *** SOAP_FMAC4 soap_in_PointerToPointerTons1__PROGRAM_USCOREINFO_USCOREType(struct soap *soap, const char *tag, ns1__PROGRAM_USCOREINFO_USCOREType ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__PROGRAM_USCOREINFO_USCOREType ***)soap_malloc(soap, sizeof(ns1__PROGRAM_USCOREINFO_USCOREType **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__PROGRAM_USCOREINFO_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__PROGRAM_USCOREINFO_USCOREType ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__PROGRAM_USCOREINFO_USCOREType, sizeof(ns1__PROGRAM_USCOREINFO_USCOREType *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__PROGRAM_USCOREINFO_USCOREType(struct soap *soap, ns1__PROGRAM_USCOREINFO_USCOREType **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__PROGRAM_USCOREINFO_USCOREType);
	if (soap_out_PointerToPointerTons1__PROGRAM_USCOREINFO_USCOREType(soap, tag?tag:"ns1:PROGRAM_INFO_Type", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__PROGRAM_USCOREINFO_USCOREType *** SOAP_FMAC4 soap_get_PointerToPointerTons1__PROGRAM_USCOREINFO_USCOREType(struct soap *soap, ns1__PROGRAM_USCOREINFO_USCOREType ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__PROGRAM_USCOREINFO_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__PROGRAM_USCOREINFO_USCOREType(struct soap *soap, ns1__PROGRAM_USCOREINFO_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__PROGRAM_USCOREINFO_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__PROGRAM_USCOREINFO_USCOREType(struct soap *soap, const char *tag, int id, ns1__PROGRAM_USCOREINFO_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__PROGRAM_USCOREINFO_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__PROGRAM_USCOREINFO_USCOREType ** SOAP_FMAC4 soap_in_PointerTons1__PROGRAM_USCOREINFO_USCOREType(struct soap *soap, const char *tag, ns1__PROGRAM_USCOREINFO_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__PROGRAM_USCOREINFO_USCOREType **)soap_malloc(soap, sizeof(ns1__PROGRAM_USCOREINFO_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__PROGRAM_USCOREINFO_USCOREType *)soap_instantiate_ns1__PROGRAM_USCOREINFO_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__PROGRAM_USCOREINFO_USCOREType ** p = (ns1__PROGRAM_USCOREINFO_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__PROGRAM_USCOREINFO_USCOREType, sizeof(ns1__PROGRAM_USCOREINFO_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__PROGRAM_USCOREINFO_USCOREType(struct soap *soap, ns1__PROGRAM_USCOREINFO_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__PROGRAM_USCOREINFO_USCOREType);
	if (soap_out_PointerTons1__PROGRAM_USCOREINFO_USCOREType(soap, tag?tag:"ns1:PROGRAM_INFO_Type", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__PROGRAM_USCOREINFO_USCOREType ** SOAP_FMAC4 soap_get_PointerTons1__PROGRAM_USCOREINFO_USCOREType(struct soap *soap, ns1__PROGRAM_USCOREINFO_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__PROGRAM_USCOREINFO_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__USER_USCOREINFO_USCOREType(struct soap *soap, ns1__USER_USCOREINFO_USCOREType **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__USER_USCOREINFO_USCOREType))
		soap_serialize_PointerTons1__USER_USCOREINFO_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__USER_USCOREINFO_USCOREType(struct soap *soap, const char *tag, int id, ns1__USER_USCOREINFO_USCOREType **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__USER_USCOREINFO_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__USER_USCOREINFO_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__USER_USCOREINFO_USCOREType *** SOAP_FMAC4 soap_in_PointerToPointerTons1__USER_USCOREINFO_USCOREType(struct soap *soap, const char *tag, ns1__USER_USCOREINFO_USCOREType ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__USER_USCOREINFO_USCOREType ***)soap_malloc(soap, sizeof(ns1__USER_USCOREINFO_USCOREType **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__USER_USCOREINFO_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__USER_USCOREINFO_USCOREType ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__USER_USCOREINFO_USCOREType, sizeof(ns1__USER_USCOREINFO_USCOREType *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__USER_USCOREINFO_USCOREType(struct soap *soap, ns1__USER_USCOREINFO_USCOREType **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__USER_USCOREINFO_USCOREType);
	if (soap_out_PointerToPointerTons1__USER_USCOREINFO_USCOREType(soap, tag?tag:"ns1:USER_INFO_Type", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__USER_USCOREINFO_USCOREType *** SOAP_FMAC4 soap_get_PointerToPointerTons1__USER_USCOREINFO_USCOREType(struct soap *soap, ns1__USER_USCOREINFO_USCOREType ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__USER_USCOREINFO_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__USER_USCORELOG_USCOREINFO_USCOREType(struct soap *soap, ns1__USER_USCORELOG_USCOREINFO_USCOREType **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__USER_USCORELOG_USCOREINFO_USCOREType))
		soap_serialize_PointerTons1__USER_USCORELOG_USCOREINFO_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__USER_USCORELOG_USCOREINFO_USCOREType(struct soap *soap, const char *tag, int id, ns1__USER_USCORELOG_USCOREINFO_USCOREType **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__USER_USCORELOG_USCOREINFO_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__USER_USCORELOG_USCOREINFO_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__USER_USCORELOG_USCOREINFO_USCOREType *** SOAP_FMAC4 soap_in_PointerToPointerTons1__USER_USCORELOG_USCOREINFO_USCOREType(struct soap *soap, const char *tag, ns1__USER_USCORELOG_USCOREINFO_USCOREType ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__USER_USCORELOG_USCOREINFO_USCOREType ***)soap_malloc(soap, sizeof(ns1__USER_USCORELOG_USCOREINFO_USCOREType **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__USER_USCORELOG_USCOREINFO_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__USER_USCORELOG_USCOREINFO_USCOREType ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__USER_USCORELOG_USCOREINFO_USCOREType, sizeof(ns1__USER_USCORELOG_USCOREINFO_USCOREType *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__USER_USCORELOG_USCOREINFO_USCOREType(struct soap *soap, ns1__USER_USCORELOG_USCOREINFO_USCOREType **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__USER_USCORELOG_USCOREINFO_USCOREType);
	if (soap_out_PointerToPointerTons1__USER_USCORELOG_USCOREINFO_USCOREType(soap, tag?tag:"ns1:USER_LOG_INFO_Type", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__USER_USCORELOG_USCOREINFO_USCOREType *** SOAP_FMAC4 soap_get_PointerToPointerTons1__USER_USCORELOG_USCOREINFO_USCOREType(struct soap *soap, ns1__USER_USCORELOG_USCOREINFO_USCOREType ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__USER_USCORELOG_USCOREINFO_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__USER_USCORELOG_USCOREINFO_USCOREType(struct soap *soap, ns1__USER_USCORELOG_USCOREINFO_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__USER_USCORELOG_USCOREINFO_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__USER_USCORELOG_USCOREINFO_USCOREType(struct soap *soap, const char *tag, int id, ns1__USER_USCORELOG_USCOREINFO_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__USER_USCORELOG_USCOREINFO_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__USER_USCORELOG_USCOREINFO_USCOREType ** SOAP_FMAC4 soap_in_PointerTons1__USER_USCORELOG_USCOREINFO_USCOREType(struct soap *soap, const char *tag, ns1__USER_USCORELOG_USCOREINFO_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__USER_USCORELOG_USCOREINFO_USCOREType **)soap_malloc(soap, sizeof(ns1__USER_USCORELOG_USCOREINFO_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__USER_USCORELOG_USCOREINFO_USCOREType *)soap_instantiate_ns1__USER_USCORELOG_USCOREINFO_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__USER_USCORELOG_USCOREINFO_USCOREType ** p = (ns1__USER_USCORELOG_USCOREINFO_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__USER_USCORELOG_USCOREINFO_USCOREType, sizeof(ns1__USER_USCORELOG_USCOREINFO_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__USER_USCORELOG_USCOREINFO_USCOREType(struct soap *soap, ns1__USER_USCORELOG_USCOREINFO_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__USER_USCORELOG_USCOREINFO_USCOREType);
	if (soap_out_PointerTons1__USER_USCORELOG_USCOREINFO_USCOREType(soap, tag?tag:"ns1:USER_LOG_INFO_Type", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__USER_USCORELOG_USCOREINFO_USCOREType ** SOAP_FMAC4 soap_get_PointerTons1__USER_USCORELOG_USCOREINFO_USCOREType(struct soap *soap, ns1__USER_USCORELOG_USCOREINFO_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__USER_USCORELOG_USCOREINFO_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__LINE_USCOREINFO_USCOREType(struct soap *soap, ns1__LINE_USCOREINFO_USCOREType **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__LINE_USCOREINFO_USCOREType))
		soap_serialize_PointerTons1__LINE_USCOREINFO_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__LINE_USCOREINFO_USCOREType(struct soap *soap, const char *tag, int id, ns1__LINE_USCOREINFO_USCOREType **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__LINE_USCOREINFO_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__LINE_USCOREINFO_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__LINE_USCOREINFO_USCOREType *** SOAP_FMAC4 soap_in_PointerToPointerTons1__LINE_USCOREINFO_USCOREType(struct soap *soap, const char *tag, ns1__LINE_USCOREINFO_USCOREType ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__LINE_USCOREINFO_USCOREType ***)soap_malloc(soap, sizeof(ns1__LINE_USCOREINFO_USCOREType **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__LINE_USCOREINFO_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__LINE_USCOREINFO_USCOREType ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__LINE_USCOREINFO_USCOREType, sizeof(ns1__LINE_USCOREINFO_USCOREType *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__LINE_USCOREINFO_USCOREType(struct soap *soap, ns1__LINE_USCOREINFO_USCOREType **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__LINE_USCOREINFO_USCOREType);
	if (soap_out_PointerToPointerTons1__LINE_USCOREINFO_USCOREType(soap, tag?tag:"ns1:LINE_INFO_Type", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__LINE_USCOREINFO_USCOREType *** SOAP_FMAC4 soap_get_PointerToPointerTons1__LINE_USCOREINFO_USCOREType(struct soap *soap, ns1__LINE_USCOREINFO_USCOREType ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__LINE_USCOREINFO_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__LINE_USCOREINFO_USCOREType(struct soap *soap, ns1__LINE_USCOREINFO_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__LINE_USCOREINFO_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__LINE_USCOREINFO_USCOREType(struct soap *soap, const char *tag, int id, ns1__LINE_USCOREINFO_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__LINE_USCOREINFO_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__LINE_USCOREINFO_USCOREType ** SOAP_FMAC4 soap_in_PointerTons1__LINE_USCOREINFO_USCOREType(struct soap *soap, const char *tag, ns1__LINE_USCOREINFO_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__LINE_USCOREINFO_USCOREType **)soap_malloc(soap, sizeof(ns1__LINE_USCOREINFO_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__LINE_USCOREINFO_USCOREType *)soap_instantiate_ns1__LINE_USCOREINFO_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__LINE_USCOREINFO_USCOREType ** p = (ns1__LINE_USCOREINFO_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__LINE_USCOREINFO_USCOREType, sizeof(ns1__LINE_USCOREINFO_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__LINE_USCOREINFO_USCOREType(struct soap *soap, ns1__LINE_USCOREINFO_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__LINE_USCOREINFO_USCOREType);
	if (soap_out_PointerTons1__LINE_USCOREINFO_USCOREType(soap, tag?tag:"ns1:LINE_INFO_Type", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__LINE_USCOREINFO_USCOREType ** SOAP_FMAC4 soap_get_PointerTons1__LINE_USCOREINFO_USCOREType(struct soap *soap, ns1__LINE_USCOREINFO_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__LINE_USCOREINFO_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__EVENT_USCORELOG_USCOREINFO_USCOREType(struct soap *soap, ns1__EVENT_USCORELOG_USCOREINFO_USCOREType **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__EVENT_USCORELOG_USCOREINFO_USCOREType))
		soap_serialize_PointerTons1__EVENT_USCORELOG_USCOREINFO_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__EVENT_USCORELOG_USCOREINFO_USCOREType(struct soap *soap, const char *tag, int id, ns1__EVENT_USCORELOG_USCOREINFO_USCOREType **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__EVENT_USCORELOG_USCOREINFO_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__EVENT_USCORELOG_USCOREINFO_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__EVENT_USCORELOG_USCOREINFO_USCOREType *** SOAP_FMAC4 soap_in_PointerToPointerTons1__EVENT_USCORELOG_USCOREINFO_USCOREType(struct soap *soap, const char *tag, ns1__EVENT_USCORELOG_USCOREINFO_USCOREType ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__EVENT_USCORELOG_USCOREINFO_USCOREType ***)soap_malloc(soap, sizeof(ns1__EVENT_USCORELOG_USCOREINFO_USCOREType **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__EVENT_USCORELOG_USCOREINFO_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__EVENT_USCORELOG_USCOREINFO_USCOREType ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__EVENT_USCORELOG_USCOREINFO_USCOREType, sizeof(ns1__EVENT_USCORELOG_USCOREINFO_USCOREType *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__EVENT_USCORELOG_USCOREINFO_USCOREType(struct soap *soap, ns1__EVENT_USCORELOG_USCOREINFO_USCOREType **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__EVENT_USCORELOG_USCOREINFO_USCOREType);
	if (soap_out_PointerToPointerTons1__EVENT_USCORELOG_USCOREINFO_USCOREType(soap, tag?tag:"ns1:EVENT_LOG_INFO_Type", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__EVENT_USCORELOG_USCOREINFO_USCOREType *** SOAP_FMAC4 soap_get_PointerToPointerTons1__EVENT_USCORELOG_USCOREINFO_USCOREType(struct soap *soap, ns1__EVENT_USCORELOG_USCOREINFO_USCOREType ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__EVENT_USCORELOG_USCOREINFO_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__EVENT_USCORELOG_USCOREINFO_USCOREType(struct soap *soap, ns1__EVENT_USCORELOG_USCOREINFO_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__EVENT_USCORELOG_USCOREINFO_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__EVENT_USCORELOG_USCOREINFO_USCOREType(struct soap *soap, const char *tag, int id, ns1__EVENT_USCORELOG_USCOREINFO_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__EVENT_USCORELOG_USCOREINFO_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__EVENT_USCORELOG_USCOREINFO_USCOREType ** SOAP_FMAC4 soap_in_PointerTons1__EVENT_USCORELOG_USCOREINFO_USCOREType(struct soap *soap, const char *tag, ns1__EVENT_USCORELOG_USCOREINFO_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__EVENT_USCORELOG_USCOREINFO_USCOREType **)soap_malloc(soap, sizeof(ns1__EVENT_USCORELOG_USCOREINFO_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__EVENT_USCORELOG_USCOREINFO_USCOREType *)soap_instantiate_ns1__EVENT_USCORELOG_USCOREINFO_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__EVENT_USCORELOG_USCOREINFO_USCOREType ** p = (ns1__EVENT_USCORELOG_USCOREINFO_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__EVENT_USCORELOG_USCOREINFO_USCOREType, sizeof(ns1__EVENT_USCORELOG_USCOREINFO_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__EVENT_USCORELOG_USCOREINFO_USCOREType(struct soap *soap, ns1__EVENT_USCORELOG_USCOREINFO_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__EVENT_USCORELOG_USCOREINFO_USCOREType);
	if (soap_out_PointerTons1__EVENT_USCORELOG_USCOREINFO_USCOREType(soap, tag?tag:"ns1:EVENT_LOG_INFO_Type", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__EVENT_USCORELOG_USCOREINFO_USCOREType ** SOAP_FMAC4 soap_get_PointerTons1__EVENT_USCORELOG_USCOREINFO_USCOREType(struct soap *soap, ns1__EVENT_USCORELOG_USCOREINFO_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__EVENT_USCORELOG_USCOREINFO_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__LCU_USCOREINFO_USCOREType(struct soap *soap, ns1__LCU_USCOREINFO_USCOREType **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__LCU_USCOREINFO_USCOREType))
		soap_serialize_PointerTons1__LCU_USCOREINFO_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__LCU_USCOREINFO_USCOREType(struct soap *soap, const char *tag, int id, ns1__LCU_USCOREINFO_USCOREType **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__LCU_USCOREINFO_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__LCU_USCOREINFO_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__LCU_USCOREINFO_USCOREType *** SOAP_FMAC4 soap_in_PointerToPointerTons1__LCU_USCOREINFO_USCOREType(struct soap *soap, const char *tag, ns1__LCU_USCOREINFO_USCOREType ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__LCU_USCOREINFO_USCOREType ***)soap_malloc(soap, sizeof(ns1__LCU_USCOREINFO_USCOREType **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__LCU_USCOREINFO_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__LCU_USCOREINFO_USCOREType ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__LCU_USCOREINFO_USCOREType, sizeof(ns1__LCU_USCOREINFO_USCOREType *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__LCU_USCOREINFO_USCOREType(struct soap *soap, ns1__LCU_USCOREINFO_USCOREType **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__LCU_USCOREINFO_USCOREType);
	if (soap_out_PointerToPointerTons1__LCU_USCOREINFO_USCOREType(soap, tag?tag:"ns1:LCU_INFO_Type", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__LCU_USCOREINFO_USCOREType *** SOAP_FMAC4 soap_get_PointerToPointerTons1__LCU_USCOREINFO_USCOREType(struct soap *soap, ns1__LCU_USCOREINFO_USCOREType ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__LCU_USCOREINFO_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__LCU_USCOREINFO_USCOREType(struct soap *soap, ns1__LCU_USCOREINFO_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__LCU_USCOREINFO_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__LCU_USCOREINFO_USCOREType(struct soap *soap, const char *tag, int id, ns1__LCU_USCOREINFO_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__LCU_USCOREINFO_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__LCU_USCOREINFO_USCOREType ** SOAP_FMAC4 soap_in_PointerTons1__LCU_USCOREINFO_USCOREType(struct soap *soap, const char *tag, ns1__LCU_USCOREINFO_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__LCU_USCOREINFO_USCOREType **)soap_malloc(soap, sizeof(ns1__LCU_USCOREINFO_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__LCU_USCOREINFO_USCOREType *)soap_instantiate_ns1__LCU_USCOREINFO_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__LCU_USCOREINFO_USCOREType ** p = (ns1__LCU_USCOREINFO_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__LCU_USCOREINFO_USCOREType, sizeof(ns1__LCU_USCOREINFO_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__LCU_USCOREINFO_USCOREType(struct soap *soap, ns1__LCU_USCOREINFO_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__LCU_USCOREINFO_USCOREType);
	if (soap_out_PointerTons1__LCU_USCOREINFO_USCOREType(soap, tag?tag:"ns1:LCU_INFO_Type", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__LCU_USCOREINFO_USCOREType ** SOAP_FMAC4 soap_get_PointerTons1__LCU_USCOREINFO_USCOREType(struct soap *soap, ns1__LCU_USCOREINFO_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__LCU_USCOREINFO_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__DCU_USCOREINFO_USCOREType(struct soap *soap, ns1__DCU_USCOREINFO_USCOREType **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__DCU_USCOREINFO_USCOREType))
		soap_serialize_PointerTons1__DCU_USCOREINFO_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__DCU_USCOREINFO_USCOREType(struct soap *soap, const char *tag, int id, ns1__DCU_USCOREINFO_USCOREType **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__DCU_USCOREINFO_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__DCU_USCOREINFO_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__DCU_USCOREINFO_USCOREType *** SOAP_FMAC4 soap_in_PointerToPointerTons1__DCU_USCOREINFO_USCOREType(struct soap *soap, const char *tag, ns1__DCU_USCOREINFO_USCOREType ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__DCU_USCOREINFO_USCOREType ***)soap_malloc(soap, sizeof(ns1__DCU_USCOREINFO_USCOREType **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__DCU_USCOREINFO_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__DCU_USCOREINFO_USCOREType ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__DCU_USCOREINFO_USCOREType, sizeof(ns1__DCU_USCOREINFO_USCOREType *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__DCU_USCOREINFO_USCOREType(struct soap *soap, ns1__DCU_USCOREINFO_USCOREType **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__DCU_USCOREINFO_USCOREType);
	if (soap_out_PointerToPointerTons1__DCU_USCOREINFO_USCOREType(soap, tag?tag:"ns1:DCU_INFO_Type", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__DCU_USCOREINFO_USCOREType *** SOAP_FMAC4 soap_get_PointerToPointerTons1__DCU_USCOREINFO_USCOREType(struct soap *soap, ns1__DCU_USCOREINFO_USCOREType ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__DCU_USCOREINFO_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__DCU_USCOREINFO_USCOREType(struct soap *soap, ns1__DCU_USCOREINFO_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__DCU_USCOREINFO_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__DCU_USCOREINFO_USCOREType(struct soap *soap, const char *tag, int id, ns1__DCU_USCOREINFO_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__DCU_USCOREINFO_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__DCU_USCOREINFO_USCOREType ** SOAP_FMAC4 soap_in_PointerTons1__DCU_USCOREINFO_USCOREType(struct soap *soap, const char *tag, ns1__DCU_USCOREINFO_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__DCU_USCOREINFO_USCOREType **)soap_malloc(soap, sizeof(ns1__DCU_USCOREINFO_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__DCU_USCOREINFO_USCOREType *)soap_instantiate_ns1__DCU_USCOREINFO_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__DCU_USCOREINFO_USCOREType ** p = (ns1__DCU_USCOREINFO_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__DCU_USCOREINFO_USCOREType, sizeof(ns1__DCU_USCOREINFO_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__DCU_USCOREINFO_USCOREType(struct soap *soap, ns1__DCU_USCOREINFO_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__DCU_USCOREINFO_USCOREType);
	if (soap_out_PointerTons1__DCU_USCOREINFO_USCOREType(soap, tag?tag:"ns1:DCU_INFO_Type", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__DCU_USCOREINFO_USCOREType ** SOAP_FMAC4 soap_get_PointerTons1__DCU_USCOREINFO_USCOREType(struct soap *soap, ns1__DCU_USCOREINFO_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__DCU_USCOREINFO_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(struct soap *soap, ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(struct soap *soap, const char *tag, int id, ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType ** SOAP_FMAC4 soap_in_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(struct soap *soap, const char *tag, ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType **)soap_malloc(soap, sizeof(ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType *)soap_instantiate_ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType ** p = (ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType, sizeof(ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(struct soap *soap, ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType);
	if (soap_out_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, tag?tag:"ns1:CURR_LOGIN_INFO_Type", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType ** SOAP_FMAC4 soap_get_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(struct soap *soap, ns1__CURR_USCORELOGIN_USCOREINFO_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CURR_USCORELOGIN_USCOREINFO_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__USER_USCOREINFO_USCOREType(struct soap *soap, ns1__USER_USCOREINFO_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__USER_USCOREINFO_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__USER_USCOREINFO_USCOREType(struct soap *soap, const char *tag, int id, ns1__USER_USCOREINFO_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__USER_USCOREINFO_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__USER_USCOREINFO_USCOREType ** SOAP_FMAC4 soap_in_PointerTons1__USER_USCOREINFO_USCOREType(struct soap *soap, const char *tag, ns1__USER_USCOREINFO_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__USER_USCOREINFO_USCOREType **)soap_malloc(soap, sizeof(ns1__USER_USCOREINFO_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__USER_USCOREINFO_USCOREType *)soap_instantiate_ns1__USER_USCOREINFO_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__USER_USCOREINFO_USCOREType ** p = (ns1__USER_USCOREINFO_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__USER_USCOREINFO_USCOREType, sizeof(ns1__USER_USCOREINFO_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__USER_USCOREINFO_USCOREType(struct soap *soap, ns1__USER_USCOREINFO_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__USER_USCOREINFO_USCOREType);
	if (soap_out_PointerTons1__USER_USCOREINFO_USCOREType(soap, tag?tag:"ns1:USER_INFO_Type", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__USER_USCOREINFO_USCOREType ** SOAP_FMAC4 soap_get_PointerTons1__USER_USCOREINFO_USCOREType(struct soap *soap, ns1__USER_USCOREINFO_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__USER_USCOREINFO_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__SCHEDULE_USCOREINFO_USCOREType(struct soap *soap, ns1__SCHEDULE_USCOREINFO_USCOREType **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__SCHEDULE_USCOREINFO_USCOREType))
		soap_serialize_PointerTons1__SCHEDULE_USCOREINFO_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__SCHEDULE_USCOREINFO_USCOREType(struct soap *soap, const char *tag, int id, ns1__SCHEDULE_USCOREINFO_USCOREType **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__SCHEDULE_USCOREINFO_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__SCHEDULE_USCOREINFO_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__SCHEDULE_USCOREINFO_USCOREType *** SOAP_FMAC4 soap_in_PointerToPointerTons1__SCHEDULE_USCOREINFO_USCOREType(struct soap *soap, const char *tag, ns1__SCHEDULE_USCOREINFO_USCOREType ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SCHEDULE_USCOREINFO_USCOREType ***)soap_malloc(soap, sizeof(ns1__SCHEDULE_USCOREINFO_USCOREType **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__SCHEDULE_USCOREINFO_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__SCHEDULE_USCOREINFO_USCOREType ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__SCHEDULE_USCOREINFO_USCOREType, sizeof(ns1__SCHEDULE_USCOREINFO_USCOREType *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__SCHEDULE_USCOREINFO_USCOREType(struct soap *soap, ns1__SCHEDULE_USCOREINFO_USCOREType **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__SCHEDULE_USCOREINFO_USCOREType);
	if (soap_out_PointerToPointerTons1__SCHEDULE_USCOREINFO_USCOREType(soap, tag?tag:"ns1:SCHEDULE_INFO_Type", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__SCHEDULE_USCOREINFO_USCOREType *** SOAP_FMAC4 soap_get_PointerToPointerTons1__SCHEDULE_USCOREINFO_USCOREType(struct soap *soap, ns1__SCHEDULE_USCOREINFO_USCOREType ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__SCHEDULE_USCOREINFO_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SCHEDULE_USCOREINFO_USCOREType(struct soap *soap, ns1__SCHEDULE_USCOREINFO_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SCHEDULE_USCOREINFO_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SCHEDULE_USCOREINFO_USCOREType(struct soap *soap, const char *tag, int id, ns1__SCHEDULE_USCOREINFO_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SCHEDULE_USCOREINFO_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__SCHEDULE_USCOREINFO_USCOREType ** SOAP_FMAC4 soap_in_PointerTons1__SCHEDULE_USCOREINFO_USCOREType(struct soap *soap, const char *tag, ns1__SCHEDULE_USCOREINFO_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SCHEDULE_USCOREINFO_USCOREType **)soap_malloc(soap, sizeof(ns1__SCHEDULE_USCOREINFO_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SCHEDULE_USCOREINFO_USCOREType *)soap_instantiate_ns1__SCHEDULE_USCOREINFO_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__SCHEDULE_USCOREINFO_USCOREType ** p = (ns1__SCHEDULE_USCOREINFO_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SCHEDULE_USCOREINFO_USCOREType, sizeof(ns1__SCHEDULE_USCOREINFO_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SCHEDULE_USCOREINFO_USCOREType(struct soap *soap, ns1__SCHEDULE_USCOREINFO_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__SCHEDULE_USCOREINFO_USCOREType);
	if (soap_out_PointerTons1__SCHEDULE_USCOREINFO_USCOREType(soap, tag?tag:"ns1:SCHEDULE_INFO_Type", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__SCHEDULE_USCOREINFO_USCOREType ** SOAP_FMAC4 soap_get_PointerTons1__SCHEDULE_USCOREINFO_USCOREType(struct soap *soap, ns1__SCHEDULE_USCOREINFO_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SCHEDULE_USCOREINFO_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__ZONE_USCOREINFO_USCOREType(struct soap *soap, ns1__ZONE_USCOREINFO_USCOREType **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__ZONE_USCOREINFO_USCOREType))
		soap_serialize_PointerTons1__ZONE_USCOREINFO_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__ZONE_USCOREINFO_USCOREType(struct soap *soap, const char *tag, int id, ns1__ZONE_USCOREINFO_USCOREType **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__ZONE_USCOREINFO_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__ZONE_USCOREINFO_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__ZONE_USCOREINFO_USCOREType *** SOAP_FMAC4 soap_in_PointerToPointerTons1__ZONE_USCOREINFO_USCOREType(struct soap *soap, const char *tag, ns1__ZONE_USCOREINFO_USCOREType ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ZONE_USCOREINFO_USCOREType ***)soap_malloc(soap, sizeof(ns1__ZONE_USCOREINFO_USCOREType **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__ZONE_USCOREINFO_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__ZONE_USCOREINFO_USCOREType ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__ZONE_USCOREINFO_USCOREType, sizeof(ns1__ZONE_USCOREINFO_USCOREType *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__ZONE_USCOREINFO_USCOREType(struct soap *soap, ns1__ZONE_USCOREINFO_USCOREType **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__ZONE_USCOREINFO_USCOREType);
	if (soap_out_PointerToPointerTons1__ZONE_USCOREINFO_USCOREType(soap, tag?tag:"ns1:ZONE_INFO_Type", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ZONE_USCOREINFO_USCOREType *** SOAP_FMAC4 soap_get_PointerToPointerTons1__ZONE_USCOREINFO_USCOREType(struct soap *soap, ns1__ZONE_USCOREINFO_USCOREType ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__ZONE_USCOREINFO_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ZONE_USCOREINFO_USCOREType(struct soap *soap, ns1__ZONE_USCOREINFO_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ZONE_USCOREINFO_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ZONE_USCOREINFO_USCOREType(struct soap *soap, const char *tag, int id, ns1__ZONE_USCOREINFO_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ZONE_USCOREINFO_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ZONE_USCOREINFO_USCOREType ** SOAP_FMAC4 soap_in_PointerTons1__ZONE_USCOREINFO_USCOREType(struct soap *soap, const char *tag, ns1__ZONE_USCOREINFO_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ZONE_USCOREINFO_USCOREType **)soap_malloc(soap, sizeof(ns1__ZONE_USCOREINFO_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ZONE_USCOREINFO_USCOREType *)soap_instantiate_ns1__ZONE_USCOREINFO_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ZONE_USCOREINFO_USCOREType ** p = (ns1__ZONE_USCOREINFO_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ZONE_USCOREINFO_USCOREType, sizeof(ns1__ZONE_USCOREINFO_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ZONE_USCOREINFO_USCOREType(struct soap *soap, ns1__ZONE_USCOREINFO_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ZONE_USCOREINFO_USCOREType);
	if (soap_out_PointerTons1__ZONE_USCOREINFO_USCOREType(soap, tag?tag:"ns1:ZONE_INFO_Type", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ZONE_USCOREINFO_USCOREType ** SOAP_FMAC4 soap_get_PointerTons1__ZONE_USCOREINFO_USCOREType(struct soap *soap, ns1__ZONE_USCOREINFO_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ZONE_USCOREINFO_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
