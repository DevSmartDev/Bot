#include "bot_schedule.h"
#include "bot_soap.h"
#include "bot_ui_method.h"
#include "bot_callback.h"
#include "bot_utils.h"
#include "bot_dcu.h"
#include "bot_login.h"
#include "bot_error.h"

GtkImage  *image_remove;
GtkImage  *image_edit;

static gint startTime, endTime, lastTime, countTime;
static gboolean isDoubleClickOnTreeView = FALSE;
static gint zoneID = -1, programID = -1;

const gchar MONTH_FMT[]     = "Tháng %d      ";
const gchar MONTH_UNKNOWN[] = "Chưa được thiết lập";

struct bot_PROGRAM_Widgets      	*program_widgets;
struct bot_SCHEDULE_ITEM_Widgets	*schedule_item_widgets;



struct botMonthItem
{
    gint    month;
    gint    dayScheduleId;
    gint    Id;
};

struct botYearSchedule
{
    gint        programId;
    struct botMonthItem month[12];
};

static GSList *programChildListDay = NULL;

static botDaySchedule * bot_day_schedule_init()
{
    botDaySchedule *day = g_new0(botDaySchedule, 1);
    day->name           = NULL;
    return day;
}

static void bot_day_schedule_free(botDaySchedule *day)
{
    g_return_if_fail(day);
    g_char_free(day->name);
    if(day->itemlist)
        bot_utils_free_slist(&day->itemlist, g_free);
    g_free(day);
}

struct bot_PROGRAM_POPUP_MENU *program_info_popup_menu = NULL;
struct bot_SCHEDULE_DAY_POPUP_MENU *schedule_day_popup_menu = NULL;
struct bot_SCHEDULE_LIST_POPUP_MENU *schedule_list_popup_menu = NULL;
struct bot_SCHEDULE_ITEM_POPUP_MENU *schedule_item_popup_menu = NULL;

struct bot_SCHEDULE_LIST_NAME_POPUP_MENU *schedule_list_name_popup_menu = NULL;
struct bot_SCHEDULE_LIST_CONTENT_POPUP_MENU *schedule_list_content_popup_menu = NULL;

static gboolean bot_schedule_item_element_init(void);

static void bot_schedule_list_name_popup_menu_init();
static void bot_schedule_list_name_popup_menu_widget_init();
static void bot_schedule_list_name_popup_menu_callback_init();
static void bot_schedule_list_name_popup_menu_clicked(GtkWidget *popup_menu_item, gpointer userdata);
static void bot_schedule_create_new_schedule_item_process(void);
static void bot_schedule_list_name_popup_menu_add_clicked(void);
static void bot_schedule_list_name_popup_menu_remove_clicked(void);
static void bot_schedule_list_starttime_adjustment_changed (GtkAdjustment *adjustment, gpointer user_data);
static void bot_schedule_list_timeon_adjustment_changed (GtkAdjustment *adjustment, gpointer user_data);
static void bot_schedule_list_level_adjustment_changed(GtkAdjustment *adjustment, gpointer user_data);
static gboolean bot_schedule_list_commit_btn_clicked(GtkButton *button, gpointer userdata);
static void bot_schedule_list_append_data(gint starttime, gint timeon, gint level);

static void bot_schedule_list_content_popup_menu_init();
static void bot_schedule_list_content_popup_menu_widget_init();
static void bot_schedule_list_content_popup_menu_callback_init();
static void bot_schedule_list_content_popup_menu_clicked(GtkWidget *popup_menu_item, gpointer userdata);
static void bot_schedule_list_content_popup_menu_add_clicked(void);
static void bot_schedule_list_content_popup_menu_remove_clicked(void);

static gboolean bot_schedule_tree_view_init(void);
static gboolean bot_schedule_store_init(void);
static gboolean bot_schedule_callback_init();
static const gchar * bot_schedule_int2time(const gint value);

static gboolean bot_program_popup_menu_init(void);
static void bot_program_popup_menu_widget_init(void);
static void bot_program_popup_menu_callback_init(void);
static gboolean bot_program_popup_menu_add_clicked(void);
static void bot_program_popup_menu_schedule_clicked(void);
static void bot_program_popup_menu_remove_clicked(void);
static void bot_program_popup_menu_clicked(GtkWidget *popup_menu_item, gpointer userdata);


static gboolean bot_schedule_day_popup_menu_init(void);
static void bot_schedule_day_popup_menu_widget_init(void);
static void bot_schedule_day_popup_menu_callback_init(void);
static void bot_schedule_day_popup_menu_add_clicked(gint program_id);
static void bot_schedule_day_popup_menu_remove_clicked(void);
static void bot_schedule_day_popup_menu_schedule_clicked(void);
static void bot_schedule_day_popup_menu_clicked(GtkWidget *popup_menu_item, gpointer userdata);


static gboolean bot_schedule_list_popup_menu_init(void);
static void bot_schedule_list_popup_menu_widget_init(void);
static void bot_schedule_list_popup_menu_callback_init(void);
static void bot_schedule_list_popup_menu_add_clicked(void);
static void bot_schedule_list_popup_menu_remove_clicked(void);
static void bot_schedule_list_popup_menu_clicked(GtkWidget *popup_menu_item, gpointer userdata);


static gboolean bot_schedule_item_popup_menu_init(void);
static void bot_schedule_item_popup_menu_widget_init(void);
static void bot_schedule_item_popup_menu_callback_init(void);
static void bot_schedule_item_popup_menu_add_clicked(void);
static void bot_schedule_item_popup_menu_remove_clicked(void);
static void bot_schedule_item_popup_menu_clicked(GtkWidget *popup_menu_item, gpointer userdata);




static gboolean check_exist_int(gint *list_value, gint value, gint list_size);
static void bot_schedule_choose_liststore_fill_information(gchar *listschedule_name, gint listschedule_id);

static void bot_schedule_day_create_process(void);
static void bot_schedule_day_change_process(GtkTreeIter *iter);


/** ********************************************************************************************************************** **/
/** ********************************************************************************************************************** **/
/** ********************************************************************************************************************** **/


/**
* Please free the return of this function
*
*/
static gchar *convert_time_tick_to_string(guint timetick)
{
    return g_strdup_printf("%02d:%02d", timetick  / 60, timetick % 60);
}


void bot_program_schedule_finalize(void)
{
    g_slice_free(bot_PROGRAM_Widgets, program_widgets);
    g_slice_free(bot_SCHEDULE_ITEM_Widgets, schedule_item_widgets);

    g_slice_free(bot_PROGRAM_POPUP_MENU      , program_info_popup_menu);
    g_slice_free(bot_SCHEDULE_DAY_POPUP_MENU , schedule_day_popup_menu);
    g_slice_free(bot_SCHEDULE_LIST_POPUP_MENU, schedule_list_popup_menu);
    g_slice_free(bot_SCHEDULE_ITEM_POPUP_MENU, schedule_item_popup_menu);
}


static void on_toggle_radio_toggled (GtkCellRendererToggle *cell,
	       gchar *path_str,
	       gpointer data)
{
	GtkTreeIter iter, iter1;
	GtkTreeStore *store = (GtkTreeStore*)data;
	GtkTreePath *path = gtk_tree_path_new_from_string (path_str);
	gboolean toggle;
	/* get toggled iter */
	gtk_tree_model_get_iter (GTK_TREE_MODEL(store), &iter, path);
	if(gtk_tree_model_get_iter_first(GTK_TREE_MODEL(store), &iter1))
    {
        do
        {
            gtk_tree_store_set (store, &iter1, 0, FALSE, -1);
        }while(gtk_tree_model_iter_next(GTK_TREE_MODEL(store), &iter1));
    }
	/* set new value */
	gtk_tree_store_set (store, &iter, 0, TRUE, -1);
	gtk_tree_path_free (path);
}

static void
on_editable_cell_clicked(GtkCellRenderer *cell,
                 GtkCellEditable *editable,
                 const gchar     *path_str,
                 gpointer         data)
{
    DEBUG("\n");
    static gboolean isInitEditableCell = FALSE;
    static GtkWidget    *dlg = NULL;
    static GtkTreeStore *store;
    GtkTreeIter iter;
    gint responseId;
    if(!isInitEditableCell)
    {
        dlg = GTK_WIDGET(bot_OBJECT("dlg_select_program_day"));
        GtkTreeView *view = GTK_TREE_VIEW(bot_OBJECT("dlg_select_treeview"));
        GtkTreeViewColumn *column;
        GtkCellRenderer *render;
        store = gtk_tree_store_new(3, G_TYPE_BOOLEAN, G_TYPE_STRING, G_TYPE_INT);
        render = gtk_cell_renderer_toggle_new();
        g_object_set(render, "radio", TRUE, NULL);
        column = gtk_tree_view_column_new_with_attributes("", render, "active", 0, NULL);
        g_signal_connect (render, "toggled", G_CALLBACK (on_toggle_radio_toggled), store);
        gtk_tree_view_append_column(view, column);

        render = gtk_cell_renderer_text_new();
        column = gtk_tree_view_column_new_with_attributes("", render, "text", 1, NULL);
        gtk_tree_view_append_column(view, column);


        gtk_tree_view_set_model(view, GTK_TREE_MODEL(store));



        /**Test*/

        gtk_tree_store_append(store, &iter, NULL);
        gtk_tree_store_set(store, &iter, 0, FALSE, 1, "1", -1);

        gtk_tree_store_append(store, &iter, NULL);
        gtk_tree_store_set(store, &iter, 0, FALSE, 1, "2", -1);

        gtk_tree_store_append(store, &iter, NULL);
        gtk_tree_store_set(store, &iter, 0, FALSE, 1, "3", -1);

        gtk_tree_store_append(store, &iter, NULL);
        gtk_tree_store_set(store, &iter, 0, FALSE, 1, "4", -1);

        isInitEditableCell = TRUE;
    }
    //fill inforation to store
    //show
    gtk_widget_show(dlg);
    while(responseId = gtk_dialog_run(GTK_DIALOG(dlg)))
    {
        switch(responseId)
        {
        case GTK_RESPONSE_CLOSE:
        case GTK_RESPONSE_DELETE_EVENT:
            goto _____exit;
            break;
        case GTK_RESPONSE_OK:
            if(gtk_tree_model_get_iter_first(GTK_TREE_MODEL(store), &iter))
            {
                do
                {
                    gboolean check;
                    gchar *name;
                    gtk_tree_model_get(GTK_TREE_MODEL(store), &iter, 0, &check, 1 , &name, -1);
                    if(check)
                    {
                        //set name to cell editable
                        DEBUG("get name: %s\n", name);
                        GtkTreePath *path = gtk_tree_path_new_from_string (path_str);
                        gtk_tree_model_get_iter (GTK_TREE_MODEL(data), &iter, path);
                        gtk_tree_store_set (GTK_TREE_STORE(data), &iter, 1, name, -1);
                        gtk_tree_path_free(path);
                        g_free(name);
                        break;
                    }
                }while(gtk_tree_model_iter_next(GTK_TREE_MODEL(store), &iter));
            }
            goto _____exit;
            break;
        }
    }
_____exit:
    gtk_cell_editable_editing_done(editable);
    gtk_widget_hide_on_delete(dlg);
}

static void bot_month_schedule_init_view()
{
    static gboolean isInitMonthView = FALSE;
    GtkTreeViewColumn *column;
    GtkCellRenderer *renderer;
    if(isInitMonthView)
        return;
    program_widgets->program_month_schedule_treestore = gtk_tree_store_new(SCHEDULE_MONTH_STORE_COUNT_COLUMNS, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_INT);

    program_widgets->program_month_schedule_treeview = GTK_TREE_VIEW(bot_OBJECT("program_month_schedule_treeview"));

    renderer = gtk_cell_renderer_text_new();
    column = gtk_tree_view_column_new_with_attributes ("Tháng", renderer, "text", 0, NULL);
    gtk_tree_view_column_set_resizable(column,TRUE);
    gtk_tree_view_column_set_reorderable(column, TRUE);
    gtk_tree_view_append_column (GTK_TREE_VIEW(program_widgets->program_month_schedule_treeview), column);

    renderer = gtk_cell_renderer_text_new();
    g_object_set(renderer, "editable", TRUE, NULL);
    column = gtk_tree_view_column_new_with_attributes ("Chương trình hoạt động", renderer, "text", 1, NULL);
    gtk_tree_view_column_set_resizable(column,TRUE);
    gtk_tree_view_column_set_reorderable(column, TRUE);
    gtk_tree_view_append_column (GTK_TREE_VIEW(program_widgets->program_month_schedule_treeview), column);

    gtk_tree_view_set_model(program_widgets->program_month_schedule_treeview,
                            GTK_TREE_MODEL(program_widgets->program_month_schedule_treestore));

    //signal connect
    /*
    g_signal_connect(GTK_TREE_VIEW(program_widgets->program_month_schedule_treeview),
                     "button-press-event",
                     G_CALLBACK(on_bot_schedule_specical_clicked), NULL);
    */
    DEBUG("Init signel editable\n");
    g_signal_connect(renderer, "editing-started", G_CALLBACK(on_editable_cell_clicked),
                     program_widgets->program_month_schedule_treestore);
    isInitMonthView = TRUE;
}

static void bot_fill_day_schedule_configuration(botDaySchedule *day, GtkTreeStore *store)
{
    g_return_if_fail(day);
    GSList *list;
    GtkTreeIter iter;
    gtk_tree_store_append(store, &day->iter, NULL);
    gtk_tree_store_set(store, &day->iter,
                       OBJECT_NAME_COLUMN, day->name,
                       OBJECT_POINTER_COLUMN, day,
                       ITEM_ID_COLUMN, day->Id,
                       ITEM_EDIT_COLUMN, gtk_image_get_pixbuf(image_edit),
                       ITEM_REMOVE_COLUMN, gtk_image_get_pixbuf(image_remove),
                       -1);
    //fill it's child
    if(day->itemlist)
    {
        for(list = day->itemlist; list != NULL; list = list->next)
        {
            botDayScheduleItem *item = (botDayScheduleItem*)list->data;
            if(item)
            {
                gchar *startStr = convert_time_tick_to_string(item->timeBegin);
                gchar *endStr   = convert_time_tick_to_string(item->timeBegin + item->timeOn);
                gchar *levelStr = g_strdup_printf("%d", item->level);
                gtk_tree_store_append(store, &iter, &day->iter);
                gtk_tree_store_set(store, &iter,
                                   ITEM_START_TIME_COLUMN, startStr,
                                   ITEM_END_TIME_COLUMN, endStr,
                                   ITEM_BRIGHTNESS_COLUMN, levelStr,
                                   ITEM_ID_COLUMN, item->Id, -1);
                g_char_free(startStr);
                g_char_free(endStr);
                g_char_free(levelStr);
            }
        }
    }
}

static void bot_program_schedule_fill_belong_information(gint progamId)
{
    ns1__DAYSCHEDULE_USCOREINFO_USCOREType  **dayschedule_list  = NULL;
    ns1__LISTSCHEDULE_USCOREINFO_USCOREType **listschedule_list = NULL;
    ns1__SCHEDULE_USCOREINFO_USCOREType     **schedule_list     = NULL;
    gint list_size;
    gint i;
    GSList *list;
    GtkTreeIter iter;
    GtkTreeStore *store;
    static struct botYearSchedule *year = NULL;
    if(year == NULL)
    {
        year = g_new0(botYearSchedule, 1);
        for(i = 0; i < 12; i++)
        {
            year->month[i].month = i + 1;
            year->month[i].Id = 0;
        }
    }
    //reset month of year id
    for(i = 0; i < 12; i++)
        year->month[i].Id = 0;
    year->programId = progamId;

    gtk_tree_store_clear(program_widgets->program_item_schedule_treestore);
    gtk_tree_store_clear(program_widgets->program_month_schedule_treestore);
    /**get list configuration schedule of this program*/
    bot_utils_free_slist(&programChildListDay, (GDestroyNotify)bot_day_schedule_free);
    if (bot_get_list_schedule_nofree_execute(0, progamId, &listschedule_list, &list_size) == TRUE)
    {
        if (listschedule_list!= NULL)
        {
            for (i = 0 ; i < list_size; i++)
            {
                botDaySchedule *day = bot_day_schedule_init();
                day->name       = g_strdup(listschedule_list[i]->listscheduleName);
                day->Id         = listschedule_list[i]->listscheduleId;
                day->programId  = listschedule_list[i]->listscheduleProgramId;

                DEBUG("Configuration name: %s have %d element\n", day->name, list_size);
                if (listschedule_list[i]->sheduleList!= NULL)
                {
                    ns1__SCHEDULE_USCOREINFO_USCOREType **schedule_list = listschedule_list[i]->sheduleList;
                    bot_utils_free_slist(&day->itemlist, (GDestroyNotify)g_free); //well-equipment, it will not happen
                    for(int index = 0; i < listschedule_list[index]->__sizesheduleList; index++)
                    {
                        botDayScheduleItem *item = g_new0(botDayScheduleItem, 1);
                        item->Id = schedule_list[index]->scheduleId;
                        item->level = schedule_list[index]->scheduleLevel;
                        item->timeBegin = schedule_list[index]->scheduleStarttime;
                        item->timeOn = schedule_list[index]->scheduleOntime;
                        item->parent = day;
                        day->itemlist = g_slist_append(day->itemlist, item);
                    }
                }
                programChildListDay = g_slist_append(programChildListDay, day);

            }
        }
    }else
    {
        bot_free_soap_operation();
        return;
    }
    DEBUG("Program id %d have %d element\n", progamId, list_size);
    bot_free_soap_operation();
#if 0 //
    /** get content of day schedule configuration*/
    if(programChildListDay)
    {
        for(list = programChildListDay; list != NULL; list = list->next)
        {
            botDaySchedule *day = (botDaySchedule*)list->data;
            bot_utils_free_slist(&day->itemlist, (GDestroyNotify)g_free); //well-equipment, it will not happen
            if (bot_get_schedule_nofree_execute(day->Id, 0, &schedule_list, &list_size) == TRUE)
            {
                if (schedule_list!= NULL)
                {
                    for(i = 0; i < list_size; i++)
                    {
                        botDayScheduleItem *item = g_new0(botDayScheduleItem, 1);
                        item->Id = schedule_list[i]->scheduleId;
                        item->level = schedule_list[i]->scheduleLevel;
                        item->timeBegin = schedule_list[i]->scheduleStarttime;
                        item->timeOn = schedule_list[i]->scheduleOntime;
                        item->parent = day;
                        day->itemlist = g_slist_append(day->itemlist, item);
                    }
                }

            }
            DEBUG("Configuration name: %s have %d element\n", day->name, list_size);
            bot_free_soap_operation();
        }
    }
#endif
    /**get year schedule*/
    if( bot_get_day_schedule_list_nofree_execute(progamId, 0, &dayschedule_list, &list_size)==TRUE)
    {
        if (dayschedule_list!=NULL)
        {
            for(gint i=0; i < list_size; i++)
            {
                gint month = dayschedule_list[i]->dayschedule_USCOREmonth;
                if(month > 12 || month < 1)
                    continue;
                year->month[month - 1].Id = dayschedule_list[i]->dayschedule_USCOREprogram_USCOREid;
            }
            DEBUG("Year get %d element\n",list_size);
        }
    }
    bot_free_soap_operation();

    /** NOW we will update the interface with which we got above*/
    //update year schedule tree view
    store = program_widgets->program_month_schedule_treestore;
    for(i = 0; i < 12; i++)
    {
        gchar *monthStr = g_strdup_printf(MONTH_FMT, i + 1);
        gchar *nameStr = (gchar*)MONTH_UNKNOWN;
        gint dayScheduleId = year->month[i].Id;
        if( dayScheduleId > 0)
        {
            for(list = programChildListDay; list != NULL; list = list->next)
            {
                botDaySchedule *day = (botDaySchedule*)list->data;
                if(day && day->Id == dayScheduleId)
                {
                    nameStr = day->name;
                    break;
                }
            }
        }
        gtk_tree_store_append(store, &iter, NULL);
        gtk_tree_store_set(store, &iter,
                           SCHEDULE_MONTH_STORE_MONTH_COLUMN, monthStr,
                           SCHEDULE_MONTH_STORE_NAME_COLUMN, nameStr,
                           SCHEDULE_MONTH_STORE_ID_COLUMN, dayScheduleId, -1);
    }
    //update day schedule configuration
    store = program_widgets->program_item_schedule_treestore;
    if(programChildListDay)
    {
        for(list = programChildListDay; list != NULL; list = list->next)
        {
            bot_fill_day_schedule_configuration((botDaySchedule*)list->data, store);
        }
    }

#if 0


GtkTreeIter iter;
    GtkTreeModel *model = GTK_TREE_MODEL(program_widgets->program_item_schedule_treestore);

    gint schedule_list_size;
    gtk_tree_store_append(GTK_TREE_STORE(model), &iter, NULL);

    gtk_tree_store_set(GTK_TREE_STORE(model), &iter,
                                    ITEM_SCHEDULE_NAME_COLUMN, listschedule_name,
                                    ITEM_SCHEDULE_LIST_ID_COLUMN, listschedule_id,
                                    ITEM_SCHEDULE_PROGRAM_ID_COLUMN, listschedule_programid,
                                    ITEM_SCHEDULE_TYPE_COLUMN, (gint)SCHEDULE_NAME_COL_INDEX,
                                    -1);
    bot_schedule_choose_liststore_fill_information(listschedule_name, listschedule_id);


    if (bot_get_schedule_nofree_execute(listschedule_id,0,&schedule_list, &schedule_list_size) == TRUE)
    {
        if (schedule_list!= NULL)
        {
            for(gint i=0; i<schedule_list_size; i++)
            {
                bot_schedule_fill_infomation(0,
                                              &iter,
                                              schedule_list[i]->schedule_USCOREid,
                                              schedule_list[i]->schedule_USCORElistschedule_USCOREid,
                                              schedule_list[i]->schedule_USCOREstarttime,
                                              schedule_list[i]->schedule_USCOREontime,
                                              schedule_list[i]->schedule_USCORElevel);
            }
        }

    }
    bot_free_soap_operation();accumulate




    bot_clear_tree_store(GTK_TREE_MODEL());

    ns1__DCU_USCOREINFO_USCOREType **dcu_list= NULL;
    gint dcu_list_size;

    gtk_label_set_text(GTK_LABEL(bot_OBJECT("program_id_current_show_label")), g_strdup_printf("%d", program_id));

    bot_clear_tree_store(GTK_TREE_MODEL(program_widgets->program_month_schedule_treestore));
    if( bot_get_day_schedule_list_nofree_execute(program_id, 0,&dayschedule_list, &dayschedule_list_size)==TRUE)
    {
        if (dayschedule_list!=NULL)
        {
            for(gint i=0; i<dayschedule_list_size; i++)
            {
                bot_day_schedule_fill_infomation(dayschedule_list[i]->dayschedule_USCOREid,
                                                  dayschedule_list[i]->dayschedule_USCORElistScheduel_USCOREid,
                                                  dayschedule_list[i]->dayschedule_USCOREprogram_USCOREid,
                                                  dayschedule_list[i]->dayschedule_USCOREmonth);
            }
        }
        bot_free_soap_operation();
    }
    else
    {
        bot_free_soap_operation();
        return;
    }


    bot_clear_list_store(GTK_TREE_MODEL(program_widgets->day_schedule_liststore_change));
    bot_schedule_choose_liststore_fill_information(g_strdup_printf("New ..."), -1);




    bot_free_soap_operation();
    bot_clear_tree_store(GTK_TREE_MODEL(program_widgets->program_dcu_list_treestore));
    gint zone_id = (gint)g_ascii_strtoll(gtk_label_get_text(GTK_LABEL(bot_OBJECT("program_id_current_show_label"))), NULL, 0);

    if (bot_get_dcu_list_nofree_execute(zone_id, program_id,&dcu_list, & dcu_list_size)==TRUE)
    {
        if (dcu_list!=NULL)
        {
            for(gint i=0; i<dcu_list_size; i++)
            {
                bot_program_fill_infomation_dcu_list(dcu_list[i]->dcu_USCOREid,
                                                                  dcu_list[i]->dcu_USCOREstatus);
            }
        }
    }
    bot_free_soap_operation();
    #endif // 0
}

static void on_program_view_selection_changed(GtkTreeSelection *treeselection, gpointer user_data)
{
    GtkTreeModel *model;
    GtkTreeIter iter;
    if(gtk_tree_selection_get_selected(treeselection, &model, &iter))
    {
        botZone *zone;
        gint type, progamId;
        gtk_tree_model_get(model, &iter,
                           OBJECT_POINTER_COLUMN, &zone,
                           OBJECT_TYPE_COLUMN, &type,
                           PROGRAM_ID_COLUMN, &progamId, -1);
        zoneID = -1;
        programID = -1;
        if(type == OBJECT_IS_PROGRAM_TYPE && zone)
        {
            zoneID = zone->zonecode;
            programID = progamId;
            //get database with this programId
            bot_program_schedule_fill_belong_information(progamId);

        }
        gtk_tree_model_filter_refilter(program_widgets->program_dcu_list_filter);
    }
}


static gboolean on_program_view_press_callback(GtkTreeView *treeview, GdkEventButton *event, gpointer userdata)
{
    GtkTreeIter iter;
    GtkTreePath *path;
    GtkTreeModel *model = gtk_tree_view_get_model(treeview);
    gint btnType = event->type;
    GtkTreeSelection *selection = gtk_tree_view_get_selection(treeview);
    switch(event->button)
    {
    case GDK_BUTTON_SECONDARY:
        if (gtk_tree_view_get_path_at_pos(GTK_TREE_VIEW(treeview), (gint) event->x, (gint) event->y, &path, NULL, NULL, NULL))
        {
            if(gtk_tree_model_get_iter(model, &iter, path))
            {
                gint type;
                gtk_tree_model_get(model, &iter, OBJECT_TYPE_COLUMN, &type, -1);
                gtk_widget_set_sensitive(program_info_popup_menu->M_Remove, type == OBJECT_IS_PROGRAM_TYPE);
                gtk_widget_show_all(GTK_WIDGET(program_info_popup_menu->M_Popup));
                gtk_menu_popup(GTK_MENU(program_info_popup_menu->M_Popup), NULL, NULL, NULL, NULL,
                           event ? event->button: 0, gdk_event_get_time((GdkEvent*)event));

            }
            if(!gtk_tree_selection_path_is_selected(selection, path))
            {
                gtk_tree_selection_select_path(selection, path);
            }
            gtk_tree_path_free(path);
            return TRUE;
        }
        break;
    default:
        break;
    }
    return FALSE;
}
static void bot_program_schedule_init_view()
{
    static gboolean isInitProgramView = FALSE;
    if(isInitProgramView)
        return;
    GtkTreeView *view;// = program_widgets->program_year_schedule_treeview;
    GtkTreeStore *store;// = program_widgets->program_year_schedule_treestore;
    GtkTreeViewColumn *column;
    GtkCellRenderer *render;
    GtkTreeSelection *selection;
    GtkWidget *separator_item;

    view = GTK_TREE_VIEW(bot_OBJECT("program_year_schedule_treeview"));
    store = gtk_tree_store_new( (PROGRAM_ID_COLUMN + 1), G_TYPE_STRING, G_TYPE_POINTER, G_TYPE_INT, G_TYPE_INT);
    gtk_tree_view_set_model(view, GTK_TREE_MODEL(store));

    render = gtk_cell_renderer_text_new();
    column = gtk_tree_view_column_new_with_attributes("Khu vực", render, "text", OBJECT_NAME_COLUMN, NULL);
    gtk_tree_view_append_column(view, column);

    gtk_tree_view_set_enable_search(view, TRUE);
    gtk_tree_view_set_search_column(view, OBJECT_NAME_COLUMN);
    gtk_tree_view_set_search_entry(view, GTK_ENTRY(bot_OBJECT("program_list_search_entry")));

    selection = gtk_tree_view_get_selection(view);
    gtk_tree_selection_set_mode(selection, GTK_SELECTION_SINGLE);

    program_info_popup_menu = g_new0(struct bot_PROGRAM_POPUP_MENU, 1);
    program_info_popup_menu->M_Popup = gtk_menu_new();
    bot_MENU_CSS(program_info_popup_menu->M_Popup);

    program_info_popup_menu->M_Add = gtk_menu_item_new_with_label("Thêm mới");
    gtk_menu_shell_append(GTK_MENU_SHELL(program_info_popup_menu->M_Popup),program_info_popup_menu->M_Add);

    separator_item = gtk_separator_menu_item_new();
    gtk_menu_shell_append(GTK_MENU_SHELL(program_info_popup_menu->M_Popup), separator_item);

    program_info_popup_menu->M_Remove= gtk_menu_item_new_with_label("Xóa");
    gtk_menu_shell_append(GTK_MENU_SHELL(program_info_popup_menu->M_Popup),program_info_popup_menu->M_Remove);


    //signal connect
    g_signal_connect(view, "button-press-event", G_CALLBACK(on_program_view_press_callback), NULL);
    g_signal_connect(selection, "changed", G_CALLBACK(on_program_view_selection_changed), NULL);
 /*   g_signal_connect(program_info_popup_menu->M_Add, "activate",
                     (GCallback) bot_program_popup_menu_clicked, GINT_TO_POINTER(bot_PROGRAM_M_ADD));
    g_signal_connect(program_info_popup_menu->M_Remove, "activate",
                     (GCallback) bot_program_popup_menu_clicked, GINT_TO_POINTER(bot_PROGRAM_M_REMOVE));
*/
    program_widgets->program_year_schedule_treeview = view;
    program_widgets->program_year_schedule_treestore = store;
    isInitProgramView = TRUE;
}

static gboolean  on_dcu_list_function_visible(GtkTreeModel *model, GtkTreeIter *iter, gpointer data)
{
    if(programID <= 0 || zoneID <= 0)
        return FALSE;
    pbotDcu dcu;
    gtk_tree_model_get(model, iter, OBJECT_POINTER_COLUMN, &dcu, -1);
    if(dcu && dcu->priv && dcu->priv->program > 0)
    {
        /*DEBUG("zoneCode: %d programID: %d ==>RESULT: %d\n", dcu->priv->zonecode, dcu->priv->program,
              dcu->priv->program == programID && dcu->priv->zonecode == zoneID);
        */

        if(dcu->priv->program == programID && dcu->priv->zonecode == zoneID)
        {
            /**if will autoupdate if status of dcu would be changed*/
            /*GtkTreeModelFilter *filter = program_widgets->program_dcu_list_filter;
            GtkTreeIter fIter;
            if(gtk_tree_model_filter_convert_child_iter_to_iter
                               (filter, &fIter, iter))
            {

                //gtk_tree_store_set(GTK_TREE_STORE(filter), &fIter, 4, status_color, -1);
            }
            */
            return TRUE;
        }
    }
    return FALSE;
}

static void bot_dcu_list_schedule_view_init()
{
    static gboolean isInitDcuListView = FALSE;
    if(isInitDcuListView)
        return;
    GtkTreeView         *view;
    GtkTreeStore        *store;
    GtkTreeModelFilter  *filter;
    GtkTreeIter         iter;
    GtkTreeViewColumn   *column;
    GtkCellRenderer     *render;

    view                = GTK_TREE_VIEW(bot_OBJECT("program_dcu_list_treeview"));
    store               = gtk_tree_store_new(OBJECT_NUM_COLUMNS  + 2,
                                             G_TYPE_STRING,
                                             G_TYPE_POINTER,
                                             G_TYPE_INT,
                                             GDK_TYPE_PIXBUF,
                                             GDK_TYPE_RGBA);


    render = gtk_cell_renderer_text_new();
    column = gtk_tree_view_column_new_with_attributes ("Mã Trạm", render,
                                                       "text", OBJECT_NAME_COLUMN,
                                                       "foreground-rgba", OBJECT_NUM_COLUMNS  + 1,
                                                       NULL);
    gtk_tree_view_column_set_resizable(column,TRUE);
    gtk_tree_view_column_set_reorderable(column, TRUE);
    gtk_tree_view_append_column (view, column);

    render = gtk_cell_renderer_pixbuf_new();
    column = gtk_tree_view_column_new_with_attributes ("Trạng thái", render,
                                                       "pixbuf", OBJECT_NUM_COLUMNS, NULL);
    gtk_tree_view_column_set_resizable(column,TRUE);
    gtk_tree_view_column_set_reorderable(column, TRUE);
    gtk_tree_view_append_column (view, column);

    filter = GTK_TREE_MODEL_FILTER(gtk_tree_model_filter_new(GTK_TREE_MODEL(store), NULL));
    gtk_tree_model_filter_set_visible_func(filter, (GtkTreeModelFilterVisibleFunc)on_dcu_list_function_visible, NULL, NULL);
    gtk_tree_view_set_model(view, GTK_TREE_MODEL(filter));


    program_widgets->program_dcu_list_treeview  = view;
    program_widgets->program_dcu_list_treestore = store;
    program_widgets->program_dcu_list_filter    = filter;
    isInitDcuListView = TRUE;
}

static gboolean on_schedule_item_icon_clicked(GtkWidget *w, GdkEventButton *event, gpointer userdata)
{
    DEBUG("%d\n", GPOINTER_TO_INT(userdata));
    return FALSE;
}

static void bot_day_schedule_init_view()
{
    static gboolean isInitDayview = FALSE;
    if(isInitDayview)
        return;
    GtkTreeIter         iter;
    GtkTreeViewColumn   *column;
    GtkCellRenderer     *render;
    GtkTreeView         *view;
    GtkTreeStore        *store;
    GtkTreeSelection    *selection;

    image_edit = GTK_IMAGE(bot_OBJECT("image_edit"));
    image_remove = GTK_IMAGE(bot_OBJECT("image_remove"));

    view    = GTK_TREE_VIEW(bot_OBJECT("program_item_schedule_treeview"));
    store   = gtk_tree_store_new(ITEM_COUNT_COLUMNS,
                                 G_TYPE_STRING,
                                 G_TYPE_POINTER,
                                 G_TYPE_INT,
                                 G_TYPE_STRING,
                                 G_TYPE_STRING,
                                 G_TYPE_STRING,
                                 G_TYPE_INT,
                                 GDK_TYPE_PIXBUF,
                                 GDK_TYPE_PIXBUF);

    render = gtk_cell_renderer_text_new();
    g_object_set(render, "is-expanded", TRUE, NULL);
    column = gtk_tree_view_column_new_with_attributes("Tên cấu hình", render, "text",
                                                      OBJECT_NAME_COLUMN, "expand", TRUE, "resizable",  TRUE, NULL);
    gtk_tree_view_append_column(view, column);

    render = gtk_cell_renderer_text_new();
    column = gtk_tree_view_column_new_with_attributes("Tg bắt đầu", render, "text", ITEM_START_TIME_COLUMN , NULL);
    gtk_tree_view_append_column(view, column);

    render = gtk_cell_renderer_text_new();
    column = gtk_tree_view_column_new_with_attributes("Tg kết thúc", render, "text", ITEM_END_TIME_COLUMN, NULL);
    gtk_tree_view_append_column(view, column);

    render = gtk_cell_renderer_text_new();
    column = gtk_tree_view_column_new_with_attributes("Độ sáng", render, "text", ITEM_BRIGHTNESS_COLUMN, NULL);
    gtk_tree_view_append_column(view, column);

    render = gtk_cell_renderer_pixbuf_new();
    column = gtk_tree_view_column_new_with_attributes("", render, "pixbuf", ITEM_EDIT_COLUMN, "fixed-width", 16, "expand", FALSE, NULL);
    gtk_tree_view_append_column(view, column);
    g_signal_connect(render, "button-press-event",
                     G_CALLBACK(on_schedule_item_icon_clicked), GINT_TO_POINTER(ITEM_EDIT_COLUMN));

    render = gtk_cell_renderer_pixbuf_new();
    g_object_set(render, "width", 16, NULL);
    column = gtk_tree_view_column_new_with_attributes("", render, "pixbuf", ITEM_REMOVE_COLUMN, "fixed-width", 16,
                                                      "expand", FALSE, "resizable", FALSE, NULL);
    gtk_tree_view_append_column(view, column);
    g_signal_connect(render, "button-press-event",
                     G_CALLBACK(on_schedule_item_icon_clicked), GINT_TO_POINTER(ITEM_REMOVE_COLUMN));



    gtk_tree_view_set_model(view, GTK_TREE_MODEL(store));
    selection = gtk_tree_view_get_selection(view);

    program_widgets->program_item_schedule_treeview = view;
    program_widgets->program_item_schedule_treestore = store;

    //signal connect
}

gboolean bot_program_schedule_init(void)
{
    program_widgets = g_slice_new(bot_PROGRAM_Widgets);

    schedule_item_widgets = g_slice_new(bot_SCHEDULE_ITEM_Widgets);

    bot_program_schedule_init_view();

    bot_month_schedule_init_view();

    bot_dcu_list_schedule_view_init();

    bot_day_schedule_init_view();

    if(!bot_schedule_tree_view_init())
        return FALSE;
    if(!bot_schedule_store_init())
        return FALSE;
   /* if(!bot_schedule_callback_init())
        return FALSE;
    if(!bot_program_popup_menu_init())
        return FALSE;
    if(!bot_schedule_day_popup_menu_init())
        return FALSE;
    if(!bot_schedule_list_popup_menu_init())
        return FALSE;
    if(!bot_schedule_item_popup_menu_init())
        return FALSE;
    if(!bot_schedule_item_element_init())
        return FALSE;

    gtk_widget_set_visible(GTK_WIDGET(bot_OBJECT("program_id_current_show_label")), FALSE);
*/
    return TRUE;
}


static gboolean bot_schedule_tree_view_init(void)
{
    GtkTreeViewColumn *column;
    GtkCellRenderer   *renderer;


    /** init for combobox text of day schedule new **/

    program_widgets->program_month_schedule_new_combobox = GTK_COMBO_BOX_TEXT(bot_OBJECT("program_month_schedule_new_combobox"));
#if 0
    /** init for list item schedule **/
    program_widgets->program_item_schedule_treeview = GTK_TREE_VIEW(bot_OBJECT("program_item_schedule_treeview"));

    renderer = gtk_cell_renderer_text_new();
    column = gtk_tree_view_column_new_with_attributes ("Tên", renderer, "text", ITEM_SCHEDULE_NAME_COLUMN, NULL);
    gtk_tree_view_column_set_resizable(column,TRUE);
    gtk_tree_view_column_set_reorderable(column, TRUE);
    gtk_tree_view_append_column (GTK_TREE_VIEW(program_widgets->program_item_schedule_treeview), column);

    renderer = gtk_cell_renderer_text_new();
    column = gtk_tree_view_column_new_with_attributes ("Thời gian mở", renderer, "text", ITEM_SCHEDULE_STARTTIME_COLUMN, NULL);
    gtk_tree_view_column_set_resizable(column,TRUE);
    gtk_tree_view_column_set_reorderable(column, TRUE);
    gtk_tree_view_append_column (GTK_TREE_VIEW(program_widgets->program_item_schedule_treeview), column);

    renderer = gtk_cell_renderer_text_new();
    column = gtk_tree_view_column_new_with_attributes ("Thời gian sáng", renderer, "text", ITEM_SCHEDULE_TIMEON_COLUMN, NULL);
    gtk_tree_view_column_set_resizable(column,TRUE);
    gtk_tree_view_column_set_reorderable(column, TRUE);
    gtk_tree_view_append_column (GTK_TREE_VIEW(program_widgets->program_item_schedule_treeview), column);

    renderer = gtk_cell_renderer_text_new();
    column = gtk_tree_view_column_new_with_attributes ("Mức sáng", renderer, "text", ITEM_SCHEDULE_LEVEL_COLUMN, NULL);
    gtk_tree_view_column_set_resizable(column,TRUE);
    gtk_tree_view_column_set_reorderable(column, TRUE);
    gtk_tree_view_append_column (GTK_TREE_VIEW(program_widgets->program_item_schedule_treeview), column);

     /** init for combobox text of day schedule change **/
#endif // 0
    program_widgets->list_schedule_combobox_change = GTK_COMBO_BOX(bot_OBJECT("list_schedule_combobox_change"));

    /** init for list DCU used specific program **/


    return TRUE;
}

static gboolean bot_schedule_store_init(void)
{
    /** init for YEAR program store **/
    gboolean isInitProgram = FALSE;
    if(isInitProgram)
        return FALSE;
#if 0
    // GDK_TYPE_PIXBUF, GDK_TYPE_RGBA //

    gtk_tree_view_set_model(GTK_TREE_VIEW(program_widgets->program_year_schedule_treeview),
                            GTK_TREE_MODEL(program_widgets->program_year_schedule_treestore));

    g_object_unref(G_OBJECT(program_widgets->program_year_schedule_treestore));



    program_widgets->program_month_schedule_new_liststore = gtk_list_store_new(1, G_TYPE_INT);

    gtk_combo_box_set_model(GTK_COMBO_BOX(program_widgets->program_month_schedule_new_combobox),
                            GTK_TREE_MODEL(program_widgets->program_month_schedule_new_liststore));

    g_object_unref(G_OBJECT(program_widgets->program_month_schedule_new_liststore));

    /** init tree store for list item schedule **/
    /*
        enum
        {
            ITEM_SCHEDULE_NAME_COLUMN = 0,

            ITEM_SCHEDULE_STARTTIME_COLUMN,
            ITEM_SCHEDULE_TIMEON_COLUMN,
            ITEM_SCHEDULE_LEVEL_COLUMN,

            ITEM_SCHEDULE_PROGRAM_ID_COLUMN,
            ITEM_SCHEDULE_LIST_ID_COLUMN,
            ITEM_SCHEDULE_ID_COLUMN,

            ITEM_SCHEDULE_TYPE_COLUMN,

            ITEM_SCHEDULE_NUM_COLUMNS
        };
    */
    program_widgets->program_item_schedule_treestore = gtk_tree_store_new(ITEM_SCHEDULE_NUM_COLUMNS,
                                                                            G_TYPE_STRING,      // Thang + name schedule
                                                                            G_TYPE_STRING,      // starttime
                                                                            G_TYPE_STRING,      // ontine
                                                                            G_TYPE_STRING,      // level
                                                                            G_TYPE_INT,         // program id
                                                                            G_TYPE_INT,         // schedule id
                                                                            G_TYPE_INT,        // list schedule id
                                                                            G_TYPE_INT);        // type column

    gtk_tree_view_set_model(GTK_TREE_VIEW(program_widgets->program_item_schedule_treeview),
                            GTK_TREE_MODEL(program_widgets->program_item_schedule_treestore));

     /** init for day schedule new **/

    program_widgets->day_schedule_liststore_change = gtk_list_store_new(2, G_TYPE_STRING, G_TYPE_INT);

    gtk_combo_box_set_model(GTK_COMBO_BOX(program_widgets->list_schedule_combobox_change),
                            GTK_TREE_MODEL(program_widgets->day_schedule_liststore_change));

    gtk_combo_box_set_entry_text_column(GTK_COMBO_BOX(program_widgets->list_schedule_combobox_change), 0);

    g_object_unref(G_OBJECT(program_widgets->day_schedule_liststore_change));
    /** init for dcu list used specific program **/
    /*
        enum
        {
            PROGRAM_DCU_LIST_NAME_COLUMN = 0,
            PROGRAM_DCU_LIST_STATUS_COLUMN,
            PROGRAM_DCU_LIST_RGBA_COLUMN,

            PROGRAM_DCU_LIST_ZONEID_COLUMN,
            PROGRAM_DCU_LIST_TYPE_COLUMN,

            PROGRAM_DCU_LIST_NUM_COLUMNS
        };
    */
    program_widgets->program_dcu_list_treestore = gtk_tree_store_new(PROGRAM_DCU_LIST_NUM_COLUMNS,
                                                                     G_TYPE_STRING, GDK_TYPE_PIXBUF, GDK_TYPE_RGBA,
                                                                     G_TYPE_INT, G_TYPE_INT);

    gtk_tree_view_set_model(GTK_TREE_VIEW(program_widgets->program_dcu_list_treeview),
                            GTK_TREE_MODEL(program_widgets->program_dcu_list_treestore));

    g_object_unref(G_OBJECT(program_widgets->program_dcu_list_treestore));


    /** init for list schedule item of special schedule **/
    gtk_combo_box_set_model(GTK_COMBO_BOX(gtk_builder_get_object (bot_builder, "dcu_info_program_combobox")),
                            GTK_TREE_MODEL(program_list_store));


/** init for avaliable value for hour combobox **/
    combobox_hour_list_store = gtk_list_store_new(1, G_TYPE_INT);
    combobox_minute_list_store = gtk_list_store_new(1, G_TYPE_INT);

    gtk_combo_box_set_model(GTK_COMBO_BOX(bot_OBJECT("schedule_combobox_hour")),
                            GTK_TREE_MODEL(combobox_hour_list_store));

    gtk_combo_box_set_model(GTK_COMBO_BOX(bot_OBJECT("schedule_combobox_minute")),
                            GTK_TREE_MODEL(combobox_minute_list_store));

    g_object_unref(program_list_store);
    g_object_unref(schedule_list_store);
    g_object_unref(combobox_hour_list_store);
    g_object_unref(combobox_minute_list_store);
#endif // 0
    isInitProgram = TRUE;
    return TRUE;
}

void bot_program_show_all(void)
{
    GtkTreeIter iter;
    GtkTreeStore *store = program_widgets->program_year_schedule_treestore;
    g_return_if_fail(zonelist && store);

    gtk_tree_store_clear(store);

    GSList *item = zonelist;
    //add all zone
    for(; item != NULL; item = item->next)
    {
        botZone *zone = (botZone*)item->data;
        if(zone)
        {
            gtk_tree_store_append(store, &iter, NULL);
            gtk_tree_store_set(store, &iter,
                               OBJECT_NAME_COLUMN, zone->zonename,
                               OBJECT_POINTER_COLUMN, zone,
                               OBJECT_TYPE_COLUMN, OBJECT_IS_ZONE_TYPE, -1);
            bot_program_fill_program_of_zone(zone, &iter);
        }
    }
    //add all list dcu
    store = program_widgets->program_dcu_list_treestore;
    g_return_if_fail(dculist && store);
    item    = dculist;
    for(; item != NULL; item = item->next)
    {
        pbotDcu dcu = (pbotDcu)item->data;
        if(dcu && dcu->priv)
        {
            GdkRGBA *status_color = &BG_COLOR_ERROR;
            if (dcu->priv->status == ACTIVE_STATUS)
            {
                status_color = &BG_COLOR_NORMAL;
            }
            else if (dcu->priv->status & (ERROR_RF_DCU_STATUS       |
                                    ERROR_SYNC_MODE_STATUS          |
                                    ERROR_SYNC_LCU_STATUS           |
                                    ERROR_SYNC_LINE_STATUS          |
                                    ERROR_SCHEDULE_LCU_STATUS       |
                                    ERROR_MEM_STATUS                |
                                    MODE_MANUAL_STATUS                ))
            {
                status_color = &BG_COLOR_ERROR;
            }
            else if (dcu->priv->status & MODE_MANUAL_STATUS) // 0x111 & 0x100 = 0x100
            {
                status_color = &BG_COLOR_MANUAL;
            }
            gtk_tree_store_append(store, &iter, NULL);
            gtk_tree_store_set(store, &iter,
                               OBJECT_NAME_COLUMN, dcu->priv->id,
                               OBJECT_POINTER_COLUMN, dcu,
                               OBJECT_TYPE_COLUMN, OBJECT_IS_DCU_TYPE,
                               OBJECT_NUM_COLUMNS + 1, status_color, -1);
        }
    }
    gtk_tree_model_filter_refilter(program_widgets->program_dcu_list_filter);
}


static void bot_schedule_choose_liststore_fill_information(gchar *listschedule_name, gint listschedule_id)
{
    GtkTreeIter iter;
    gtk_list_store_append(GTK_LIST_STORE(program_widgets->day_schedule_liststore_change), &iter);
    gtk_list_store_set(GTK_LIST_STORE(program_widgets->day_schedule_liststore_change), &iter,
                                                        0, listschedule_name,
                                                        1, listschedule_id, -1);
}


void bot_program_fill_program_of_zone(botZone *zone, GtkTreeIter *parent)
{
    GtkTreeIter iter;
    ns1__PROGRAM_USCOREINFO_USCOREType ** program = NULL;
    gint program_size;
    GtkTreeStore *store = program_widgets->program_year_schedule_treestore;
    g_return_if_fail(zonelist && store && parent);

    if (bot_get_program_list_nofree_execute(zone->zonecode, &program, &program_size) == TRUE)
    {
        if (program != NULL)
        {
            for(gint i = 0; i<program_size; i++)
            {
                gtk_tree_store_append(store, &iter, parent);
                gtk_tree_store_set(store, &iter, OBJECT_NAME_COLUMN, (const gchar *)program[i]->program_USCOREname,
                                   OBJECT_POINTER_COLUMN, zone,
                                   OBJECT_TYPE_COLUMN, OBJECT_IS_PROGRAM_TYPE,
                                   PROGRAM_ID_COLUMN, program[i]->program_USCOREid, -1);
            }
        }
    }
    bot_free_soap_operation();
}



static void on_combo_box_time_activated(GtkWidget *w, gpointer data)
{
    gint hS, hE, mS, mE;
    hS = gtk_combo_box_get_active(GTK_COMBO_BOX(bot_OBJECT("cbb_startHour")));
    hE = gtk_combo_box_get_active(GTK_COMBO_BOX(bot_OBJECT("cbb_endHour")));
    mS = gtk_combo_box_get_active(GTK_COMBO_BOX(bot_OBJECT("cbb_startMinute")));
    mE = gtk_combo_box_get_active(GTK_COMBO_BOX(bot_OBJECT("cbb_endMinute")));

    if(hS == 24 && mS > 0)
        goto __showImageStartFail;
    startTime = hS * 60 + mS;
    if(startTime < lastTime)
        goto __showImageStartFail;
    gtk_widget_set_visible(GTK_WIDGET(bot_OBJECT("image_startTime")), FALSE);
    if(hE == 24 && mE > 0)
        goto __showImageEndFail;
    endTime = hE * 60 + mE;
    if(endTime < startTime)
        goto __showImageEndFail;
    gtk_widget_set_visible(GTK_WIDGET(bot_OBJECT("image_endTime")), FALSE);
    return;
__showImageStartFail:
    gtk_widget_set_visible(GTK_WIDGET(bot_OBJECT("image_startTime")), TRUE);
    startTime = -1;
    return;
__showImageEndFail:
    gtk_widget_set_visible(GTK_WIDGET(bot_OBJECT("image_endTime")), TRUE);
    endTime = -1;
    return;
}

static gboolean bot_schedule_item_element_init(void)
{

    static gboolean isInitSchedule = FALSE;
    GtkTreeViewColumn *column;
    GtkCellRenderer   *renderer;
    GtkTreeIter iter1, iter2;
    gint i = 0;

    if(isInitSchedule)
        return  FALSE;

    schedule_item_widgets->schedule_item_content_treeview = GTK_WIDGET(bot_OBJECT("schedule_item_content_treeview"));
    renderer = gtk_cell_renderer_text_new();
    column = gtk_tree_view_column_new_with_attributes ("Thời gian mở", renderer, "text", NEW_ITEM_SCHEDULE_STARTTIME_COLUMN, NULL);
    gtk_tree_view_column_set_resizable(column,TRUE);
    gtk_tree_view_column_set_reorderable(column, TRUE);
    gtk_tree_view_append_column (GTK_TREE_VIEW(schedule_item_widgets->schedule_item_content_treeview), column);

    renderer = gtk_cell_renderer_text_new();
    column = gtk_tree_view_column_new_with_attributes ("Thời gian tắt", renderer, "text", NEW_ITEM_SCHEDULE_TIMEON_COLUMN, NULL);
    gtk_tree_view_column_set_resizable(column,TRUE);
    gtk_tree_view_column_set_reorderable(column, TRUE);
    gtk_tree_view_append_column (GTK_TREE_VIEW(schedule_item_widgets->schedule_item_content_treeview), column);

    renderer = gtk_cell_renderer_text_new();
    column = gtk_tree_view_column_new_with_attributes ("Mức sáng", renderer, "text", NEW_ITEM_SCHEDULE_LEVEL_COLUMN, NULL);
    gtk_tree_view_column_set_resizable(column,TRUE);
    gtk_tree_view_column_set_reorderable(column, TRUE);
    gtk_tree_view_append_column (GTK_TREE_VIEW(schedule_item_widgets->schedule_item_content_treeview), column);

    schedule_item_widgets->schedule_item_name_entry = GTK_WIDGET(bot_OBJECT("schedule_item_name_entry"));
    schedule_item_widgets->schedule_item_commit_button = GTK_WIDGET(bot_OBJECT("schedule_item_commit_button"));

    schedule_item_widgets->schedule_item_content_liststore = GTK_LIST_STORE(gtk_list_store_new(NEW_ITEM_SCHEDULE_NUM_COLUMNS,
                                                                                            G_TYPE_STRING,      // starttime
                                                                                            G_TYPE_STRING,      // timeon
                                                                                            G_TYPE_STRING,      // level
                                                                                            G_TYPE_INT,         // starttime int
                                                                                            G_TYPE_INT,         // timeon int
                                                                                            G_TYPE_INT));       // level int

    gtk_tree_view_set_model(GTK_TREE_VIEW(schedule_item_widgets->schedule_item_content_treeview),
                            GTK_TREE_MODEL(schedule_item_widgets->schedule_item_content_liststore));


    //set hour for hour combobox
    for(i = 0; i <= 24; i++)
    {
        gchar *item = g_strdup_printf("%d", i);
        gtk_combo_box_text_insert(GTK_COMBO_BOX_TEXT(bot_OBJECT("cbb_startHour")), i, NULL, item);
        gtk_combo_box_text_insert(GTK_COMBO_BOX_TEXT(bot_OBJECT("cbb_endHour")), i, NULL, item);
        g_free(item);
    }

    for(i = 0; i < 60; i++)
    {
        gchar *item = g_strdup_printf("%d", i);
        gtk_combo_box_text_insert(GTK_COMBO_BOX_TEXT(bot_OBJECT("cbb_startMinute")), i, NULL, item);
        gtk_combo_box_text_insert(GTK_COMBO_BOX_TEXT(bot_OBJECT("cbb_endMinute")), i, NULL, item);
        g_free(item);
    }

    //bot_schedule_list_name_popup_menu_init();
   // bot_schedule_list_content_popup_menu_init();

/**signal connect*/
    g_signal_connect(GTK_BUTTON(schedule_item_widgets->schedule_item_commit_button),
                     "clicked",
                     G_CALLBACK(bot_schedule_list_commit_btn_clicked), NULL);
    g_signal_connect(bot_OBJECT("cbb_startHour"), "changed", G_CALLBACK(on_combo_box_time_activated), NULL);
    g_signal_connect(bot_OBJECT("cbb_endHour"), "changed", G_CALLBACK(on_combo_box_time_activated), NULL);
    g_signal_connect(bot_OBJECT("cbb_startMinute"), "changed", G_CALLBACK(on_combo_box_time_activated), NULL);
    g_signal_connect(bot_OBJECT("cbb_endMinute"), "changed", G_CALLBACK(on_combo_box_time_activated), NULL);

    isInitSchedule = TRUE;
    return TRUE;
}




static gboolean bot_schedule_list_commit_btn_clicked(GtkButton *button, gpointer userdata)
{
    GtkTreeIter iter;
    if(endTime < 0 || startTime < 0)
        return FALSE; //show infomation why this fail; //may be
    if(countTime >= 10)
        return FALSE; //add 10 schedule
    lastTime = endTime;
    gint level = (gint)gtk_adjustment_get_value(GTK_ADJUSTMENT(bot_OBJECT("lcu_brightness_adjustment")));
    gchar *start = convert_time_tick_to_string(startTime);
    gchar *end = convert_time_tick_to_string(endTime);
    gchar *slevel = g_strdup_printf("%d", level);
    gtk_list_store_append(GTK_LIST_STORE(schedule_item_widgets->schedule_item_content_liststore), &iter);
    gtk_list_store_set(GTK_LIST_STORE(schedule_item_widgets->schedule_item_content_liststore), &iter,
                                      NEW_ITEM_SCHEDULE_STARTTIME_COLUMN, start,
                                      NEW_ITEM_SCHEDULE_TIMEON_COLUMN, end,
                                      NEW_ITEM_SCHEDULE_LEVEL_COLUMN, slevel,
                                      NEW_ITEM_SCHEDULE_STARTTIME_INT_COLUMN, startTime,
                                      NEW_ITEM_SCHEDULE_TIMEON_INT_COLUMN,    endTime - startTime ,
                                      NEW_ITEM_SCHEDULE_LEVEL_INT_COLUMN,     level, -1);
    gtk_combo_box_set_active(GTK_COMBO_BOX(bot_OBJECT("cbb_startHour")), lastTime / 60);
    gtk_combo_box_set_active(GTK_COMBO_BOX(bot_OBJECT("cbb_startMinute")), lastTime % 60);
    g_free(start);
    g_free(end);
    g_free(slevel);
    countTime++;
}

/** HIEU-FIXED



static void bot_schedule_list_name_popup_menu_init()
{
    schedule_list_name_popup_menu = g_new0(struct bot_SCHEDULE_LIST_NAME_POPUP_MENU, 1);

    bot_schedule_list_name_popup_menu_widget_init();
    bot_schedule_list_name_popup_menu_callback_init();
}

static void bot_schedule_list_content_popup_menu_init()
{
    schedule_list_content_popup_menu = g_new0(struct bot_SCHEDULE_LIST_CONTENT_POPUP_MENU, 1);

    bot_schedule_list_content_popup_menu_widget_init();
    bot_schedule_list_content_popup_menu_callback_init();
}


static void bot_schedule_list_name_popup_menu_widget_init()
{
    GtkWidget *separator_item;
    schedule_list_name_popup_menu->M_Popup = gtk_menu_new();
    bot_MENU_CSS(schedule_list_name_popup_menu->M_Popup);

    schedule_list_name_popup_menu->M_Add = gtk_menu_item_new_with_label("Thêm mới");
    gtk_menu_shell_append(GTK_MENU_SHELL(schedule_list_name_popup_menu->M_Popup),schedule_list_name_popup_menu->M_Add);

    separator_item = gtk_separator_menu_item_new();
    gtk_menu_shell_append(GTK_MENU_SHELL(schedule_list_name_popup_menu->M_Popup), separator_item);

    schedule_list_name_popup_menu->M_Remove= gtk_menu_item_new_with_label("Xóa");
    gtk_menu_shell_append(GTK_MENU_SHELL(schedule_list_name_popup_menu->M_Popup),schedule_list_name_popup_menu->M_Remove);
}

static void bot_schedule_list_name_popup_menu_callback_init()
{
    g_signal_connect(schedule_list_name_popup_menu->M_Add, "activate",
                 (GCallback) bot_schedule_list_name_popup_menu_clicked, GINT_TO_POINTER(bot_SCHEDULE_M_ADD));

    g_signal_connect(schedule_list_name_popup_menu->M_Remove, "activate",
                     (GCallback) bot_schedule_list_name_popup_menu_clicked, GINT_TO_POINTER(bot_SCHEDULE_M_REMOVE));
}

static void bot_schedule_list_name_popup_menu_clicked(GtkWidget *popup_menu_item, gpointer userdata)
{
    bot_SCHEDULE_POPUP_Enum type = (bot_SCHEDULE_POPUP_Enum)GPOINTER_TO_INT(userdata);
    switch(type)
    {
    case bot_SCHEDULE_M_ADD:
        bot_schedule_list_name_popup_menu_add_clicked();
        break;
    case bot_SCHEDULE_M_REMOVE:
        bot_schedule_list_name_popup_menu_remove_clicked();
        break;
    default:
        break;
    }
}

static void bot_schedule_create_new_schedule_item_process(void)
{
    gint program_id = (gint)g_ascii_strtoll(gtk_label_get_text(GTK_LABEL(bot_OBJECT("program_id_current_show_label"))), NULL, 0);
    const gchar *listschedule_name = gtk_entry_get_text(GTK_ENTRY(schedule_item_widgets->schedule_item_name_entry));

    gint listschedule_id = 0;

    if (bot_add_list_schedule_execute(listschedule_name,
                                                   &listschedule_id,
                                                   program_id))
    {
//        bot_add_item_schedule_execute();
        GtkTreeIter iter;
        gint start_time;
        gint on_time;
        gint level;
        ns1__LISTSCHEDULE_USCOREINFO_USCOREType **listschedule_list=NULL;
        gint listschedule_list_size;
        gint schedule_id = 0;

        GtkTreeModel *model = GTK_TREE_MODEL(schedule_item_widgets->schedule_item_content_liststore);
        if(gtk_tree_model_get_iter_first(model, &iter))
        {
            do
            {
                gtk_tree_model_get(model, &iter,
                                    NEW_ITEM_SCHEDULE_STARTTIME_INT_COLUMN, &start_time,
                                    NEW_ITEM_SCHEDULE_TIMEON_INT_COLUMN, &on_time,
                                    NEW_ITEM_SCHEDULE_LEVEL_INT_COLUMN, &level, -1);


                bot_add_item_schedule_execute(listschedule_id,
                                                           start_time,
                                                           on_time,
                                                           level,
                                                           &schedule_id); //???????????????????????
            }
            while(gtk_tree_model_iter_next(model, &iter));
        }

        bot_clear_tree_store(GTK_TREE_MODEL(program_widgets->program_item_schedule_treestore));
        bot_clear_list_store(GTK_TREE_MODEL(program_widgets->day_schedule_liststore_change));
        if (bot_get_list_schedule_nofree_execute(0,program_id,
                                                                &listschedule_list,
                                                                &listschedule_list_size)==TRUE)
        {
            if (listschedule_list!= NULL)
            {
                for (gint i = 0 ; i < listschedule_list_size; i++)
                {
                    bot_schedule_item_fill_infomations(listschedule_list[i]->listschedule_USCOREid,
                                                        listschedule_list[i]->listschedule_USCOREname,
                                                        listschedule_list[i]->listschedule_USCOREprogram_USCOREid);
                }
            }
        }
        bot_free_soap_operation();
    }
    else
    {
        bot_error_notifice_run(g_strdup_printf("Internal Error at %s:%d", __FILE__, __LINE__));
    }
}

static void bot_schedule_list_name_popup_menu_add_clicked(void)
{
    lastTime = 0;
    startTime = endTime =  -1;
    gtk_combo_box_set_active(GTK_COMBO_BOX(bot_OBJECT("cbb_startHour")), 0);
    gtk_combo_box_set_active(GTK_COMBO_BOX(bot_OBJECT("cbb_startMinute")), 0);
    gtk_combo_box_set_active(GTK_COMBO_BOX(bot_OBJECT("cbb_endHour")), 0);
    gtk_combo_box_set_active(GTK_COMBO_BOX(bot_OBJECT("cbb_endMinute")), 0);
    gtk_list_store_clear(GTK_LIST_STORE(schedule_item_widgets->schedule_item_content_liststore));
    gtk_entry_set_text(GTK_ENTRY(bot_OBJECT( "schedule_item_name_entry")), "");
    countTime = 0;
    gint response_id = gtk_dialog_run(GTK_DIALOG(main_widgets->schedule_item_new_dialog));

    switch(response_id)
    {
        case DIALOG_OK_RESPONSE:
            if(g_strcmp0(gtk_entry_get_text(GTK_ENTRY(schedule_item_widgets->schedule_item_name_entry)), "")==0)
            {
                gtk_entry_set_text(GTK_ENTRY(schedule_item_widgets->schedule_item_name_entry), g_strdup("Unname Schedule"));
            }
            bot_schedule_create_new_schedule_item_process();
            break;
        case DIALOG_CANCEL_RESPONSE:
            break;
        default:
            break;
    }
    gtk_widget_hide(main_widgets->schedule_item_new_dialog);
    gtk_widget_set_sensitive(GTK_WIDGET(main_widgets->main_window), TRUE);
}

static void bot_schedule_list_name_popup_menu_remove_clicked(void)
{
    GtkTreeIter      iter;
    GtkTreeModel     *model;
    GtkTreeSelection *selection;

    selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(program_widgets->program_item_schedule_treeview));

    if (gtk_tree_selection_count_selected_rows(selection)  == 1)
    {
        if(gtk_tree_selection_get_selected(selection, &model, &iter))
        {
            gint listschedule_id;
            gint program_id;

            gtk_tree_model_get(model, &iter, ITEM_SCHEDULE_LIST_ID_COLUMN, &listschedule_id,
                                             ITEM_SCHEDULE_PROGRAM_ID_COLUMN, &program_id, -1);

            if(bot_remove_list_schedule_execute(listschedule_id)==TRUE)
            {
//                gtk_tree_store_remove(GTK_TREE_STORE(model), &iter);
                bot_program_year_show_specific(program_id);
            }
        }
    }
}


static void bot_schedule_list_content_popup_menu_widget_init()
{
    GtkWidget *separator_item;
    schedule_list_content_popup_menu->M_Popup = gtk_menu_new();
    bot_MENU_CSS(schedule_list_content_popup_menu->M_Popup);

    schedule_list_content_popup_menu->M_Add = gtk_menu_item_new_with_label("Thêm mới");
    gtk_menu_shell_append(GTK_MENU_SHELL(schedule_list_content_popup_menu->M_Popup),schedule_list_content_popup_menu->M_Add);

    separator_item = gtk_separator_menu_item_new();
    gtk_menu_shell_append(GTK_MENU_SHELL(schedule_list_content_popup_menu->M_Popup), separator_item);

    schedule_list_content_popup_menu->M_Remove= gtk_menu_item_new_with_label("Xóa");
    gtk_menu_shell_append(GTK_MENU_SHELL(schedule_list_content_popup_menu->M_Popup),schedule_list_content_popup_menu->M_Remove);
}

static void bot_schedule_list_content_popup_menu_callback_init()
{
    g_signal_connect(schedule_list_content_popup_menu->M_Add, "activate",
                 (GCallback) bot_schedule_list_content_popup_menu_clicked, GINT_TO_POINTER(bot_PROGRAM_M_ADD));

    g_signal_connect(schedule_list_content_popup_menu->M_Remove, "activate",
                     (GCallback) bot_schedule_list_content_popup_menu_clicked, GINT_TO_POINTER(bot_PROGRAM_M_REMOVE));
}

static void bot_schedule_list_content_popup_menu_clicked(GtkWidget *popup_menu_item, gpointer userdata)
{
    bot_SCHEDULE_POPUP_Enum type = (bot_SCHEDULE_POPUP_Enum)GPOINTER_TO_INT(userdata);
    switch(type)
    {
    case bot_SCHEDULE_M_ADD:
        bot_schedule_list_content_popup_menu_add_clicked();
        break;
    case bot_SCHEDULE_M_REMOVE:
        bot_schedule_list_content_popup_menu_remove_clicked();
        break;
    default:
        break;
    }
}

static void bot_schedule_list_content_popup_menu_add_clicked(void)
{
    DEBUG_1();
}

static void bot_schedule_list_content_popup_menu_remove_clicked(void)
{
    DEBUG_1();
}

static void bot_schedule_list_starttime_adjustment_changed (GtkAdjustment *adjustment, gpointer user_data)
{
    gint value = (gint)gtk_adjustment_get_value(GTK_ADJUSTMENT(schedule_item_widgets->schedule_item_starttime_adjustment));

    gint starttime_min = (gint)g_ascii_strtoll(gtk_label_get_text(GTK_LABEL(schedule_item_widgets->schedule_item_min_starttime_value)),
                                                            NULL, 0);

    if(value<starttime_min)
        value = starttime_min;

    else if(value==starttime_min)
        gtk_widget_set_sensitive(GTK_WIDGET(schedule_item_widgets->schedule_item_starttime_adjustment), FALSE);

    gtk_adjustment_set_value(GTK_ADJUSTMENT(schedule_item_widgets->schedule_item_starttime_adjustment), value);

    gtk_label_set_text(GTK_LABEL(schedule_item_widgets->schedule_item_starttime_label),
                                 bot_schedule_int2time(value));

    gtk_adjustment_configure(GTK_ADJUSTMENT(schedule_item_widgets->schedule_item_timeon_adjustment),
                                            0, 0, MAX_MINUTE-value, 1, 0, 0);
}

static void bot_schedule_list_timeon_adjustment_changed (GtkAdjustment *adjustment, gpointer user_data)
{
    gint value = (gint)gtk_adjustment_get_value(GTK_ADJUSTMENT(schedule_item_widgets->schedule_item_timeon_adjustment));
    if(value < 1)
        value = 1;

    gtk_label_set_text(GTK_LABEL(schedule_item_widgets->schedule_item_timeon_label),
                                 bot_schedule_int2time(value));
    gtk_adjustment_set_value(GTK_ADJUSTMENT(schedule_item_widgets->schedule_item_timeon_adjustment), value);
}

static void bot_schedule_list_level_adjustment_changed (GtkAdjustment *adjustment, gpointer user_data)
{
    gint value = (gint)gtk_adjustment_get_value(GTK_ADJUSTMENT(schedule_item_widgets->schedule_item_level_adjustment));
    gtk_label_set_text(GTK_LABEL(schedule_item_widgets->schedule_item_level_label),
                                 g_strdup_printf("%d", value));
}


void bot_program_fill_infomation_dcu_list(gchar *dcu_id, gint dcu_status)
{
    GtkTreeIter iter;
    GdkRGBA *status_color = &BG_COLOR_ERROR;
    ns1__LCU_USCOREINFO_USCOREType **lcu_list;
    gint lcu_list_size;
    if (dcu_status == ACTIVE_STATUS)
    {
        status_color = &BG_COLOR_NORMAL;
    }
    else if ((dcu_status & (ERROR_RF_DCU_STATUS             |
                            ERROR_SYNC_MODE_STATUS          |
                            ERROR_SYNC_LCU_STATUS           |
                            ERROR_SYNC_LINE_STATUS          |
                            ERROR_SCHEDULE_LCU_STATUS       |
                            ERROR_MEM_STATUS                |
                            MODE_MANUAL_STATUS                )) != 0)
    {
        status_color = &BG_COLOR_ERROR;
    }
    else if ((dcu_status & MODE_MANUAL_STATUS) == MODE_MANUAL_STATUS)
    {
        status_color = &BG_COLOR_MANUAL;
    }
    else
    {
        bot_error_notifice_run(g_strdup_printf("Internal Error: \"DCU's status is invaild.\" at %s:%d", __FILE__, __LINE__));
    }

    gtk_tree_store_append(GTK_TREE_STORE(program_widgets->program_dcu_list_treestore), &iter, NULL);
    gtk_tree_store_set(GTK_TREE_STORE(program_widgets->program_dcu_list_treestore), &iter,
                                                        PROGRAM_DCU_LIST_NAME_COLUMN, dcu_id,
                                                        PROGRAM_DCU_LIST_RGBA_COLUMN, status_color,
                                                        PROGRAM_DCU_LIST_TYPE_COLUMN, PROGRAM_NAME_COL_INDEX, -1);


    if (bot_get_lcu_list_nofree_execute(dcu_id, &lcu_list, &lcu_list_size)==TRUE)
    {
        if (lcu_list!= NULL)
        {
            for(gint i=0; i<lcu_list_size; i++)
            {
                bot_program_fill_infomation_lcu_list(lcu_list[i]->lcu_USCOREid,
                                                                  lcu_list[i]->lcu_USCOREstatus,
                                                                  lcu_list[i]->lcu_USCOREmode,
                                                                  &iter);
            }
        }
    }
    bot_free_soap_operation();
}

void bot_program_fill_infomation_lcu_list(gchar *lcu_id, gint lcu_status, gint lcu_mode, GtkTreeIter *parent_iter)
{
    GtkTreeIter iter;
    GdkRGBA *status_color = &BG_COLOR_ERROR;
    DEBUG("\n\nLCU mode: %d\n",lcu_mode);
    if (lcu_status == NOERROR_STATUS)
    {
//        status_color = &BG_COLOR_NORMAL;
        switch(lcu_mode)
        {
        case PROGRAM_LCU_NO_MODE:
            status_color = &BG_COLOR_UNKNOWN;
        case PROGRAM_LCU_SCHEDULE_MODE:
            status_color = &BG_COLOR_NORMAL;
            break;
        case PROGRAM_LCU_MANUAL_MODE:
            status_color = &BG_COLOR_MANUAL;
            break;
        case PROGRAM_LCU_OFF_MODE:
            status_color = &BG_COLOR_OFF;
            break;
        default:
            bot_error_notifice_run(g_strdup_printf("Internal Error: \"LCU's mode is invaild.\" at %s:%d", __FILE__, __LINE__));
        };
    }
    else if ((lcu_status & (ERROR_RF_LCU_STATUS         |
                            ERROR_LINE_STATUS           |
                            ERROR_SYNC_LCU_STATUS       |
                            ERROR_CLOCK_LCU_STATUS      |
                            ERROR_CURRENT_STATUS            )) != 0)
    {
        status_color = &BG_COLOR_ERROR;
    }
    else
    {
        bot_error_notifice_run(g_strdup_printf("Internal Error: \"LCU's status is invaild.\" at %s:%d", __FILE__, __LINE__));
    }


    gtk_tree_store_append(GTK_TREE_STORE(program_widgets->program_dcu_list_treestore), &iter, parent_iter);
    gtk_tree_store_set(GTK_TREE_STORE(program_widgets->program_dcu_list_treestore), &iter,
                                                        PROGRAM_DCU_LIST_NAME_COLUMN, lcu_id,
                                                        PROGRAM_DCU_LIST_RGBA_COLUMN, status_color,
                                                        PROGRAM_DCU_LIST_TYPE_COLUMN, PROGRAM_CONTENT_COL_INDEX, -1);
}

void bot_day_schedule_fill_infomation(gint day_schedule_id,
                                                   gint list_schedule_id,
                                                   gint program_id,
                                                   gint month)
{


    GtkTreeIter iter;
    ns1__LISTSCHEDULE_USCOREINFO_USCOREType **listschedule_list=NULL;
    gint listschedule_list_size;
    gtk_tree_store_append(GTK_TREE_STORE(program_widgets->program_month_schedule_treestore), &iter, NULL);
    gtk_tree_store_set(GTK_TREE_STORE(program_widgets->program_month_schedule_treestore), &iter,
                                                        SCHEDULE_NAME_COLUMN, g_strdup_printf("Tháng %d", month),
                                                        SCHEDULE_MONTH_COLUMN, month,
                                                        SCHEDULE_PROGRAM_ID_COLUMN, program_id,
                                                        SCHEDULE_DAY_ID_COLUMN, day_schedule_id,
                                                        SCHEDULE_LIST_ID_COLUMN, list_schedule_id,
                                                        SCHEDULE_STARTTIME_COLUMN, NULL,
                                                        SCHEDULE_TIMEON_COLUMN, NULL,
                                                        SCHEDULE_LEVEL_COLUMN, NULL,
                                                        SCHEDULE_TYPE_COLUMN, (gint)SCHEDULE_MONTH_COL_INDEX,
                                                        -1);
    if(list_schedule_id>0)
    {
        if (bot_get_list_schedule_nofree_execute(list_schedule_id,0,
                                                                &listschedule_list,
                                                                &listschedule_list_size)==TRUE)
        {
            if (listschedule_list!= NULL)
            {
                for (gint i = 0 ; i < listschedule_list_size; i++)
                {
                    bot_schedule_name_fill_infomations(&iter, listschedule_list[i]->listschedule_USCOREid,
                                                                                listschedule_list[i]->listschedule_USCOREname);
                }
            }
        }
        bot_free_soap_operation();
    }
}


void bot_schedule_name_fill_infomations(GtkTreeIter *parent_iter, gint listschedule_id, gchar *listschedule_name)
{
    GtkTreeIter iter;
    GtkTreeModel *model = GTK_TREE_MODEL(program_widgets->program_month_schedule_treestore);
    ns1__SCHEDULE_USCOREINFO_USCOREType **schedule_list=NULL;
    gint schedule_list_size;
    gtk_tree_store_append(GTK_TREE_STORE(model), &iter, parent_iter);
    gtk_tree_store_set(GTK_TREE_STORE(model), &iter,
                       SCHEDULE_NAME_COLUMN, listschedule_name,
                       SCHEDULE_TYPE_COLUMN, (gint)SCHEDULE_NAME_COL_INDEX,
                       -1);

    if (bot_get_schedule_nofree_execute(listschedule_id,0,&schedule_list, &schedule_list_size) == TRUE)
    {
        if (schedule_list!= NULL)
        {
            for(gint i=0; i<schedule_list_size; i++)
            {
                bot_schedule_fill_infomation(1,
                                              &iter,
                                              schedule_list[i]->schedule_USCOREid,
                                              schedule_list[i]->schedule_USCORElistschedule_USCOREid,
                                              schedule_list[i]->schedule_USCOREstarttime,
                                              schedule_list[i]->schedule_USCOREontime,
                                              schedule_list[i]->schedule_USCORElevel);
            }
        }

    }
    bot_free_soap_operation();
}

void bot_schedule_item_fill_infomations(gint listschedule_id, gchar *listschedule_name, gint listschedule_programid)
{
    GtkTreeIter iter;
    GtkTreeModel *model = GTK_TREE_MODEL(program_widgets->program_item_schedule_treestore);
    ns1__SCHEDULE_USCOREINFO_USCOREType **schedule_list=NULL;
    gint schedule_list_size;
    gtk_tree_store_append(GTK_TREE_STORE(model), &iter, NULL);

    gtk_tree_store_set(GTK_TREE_STORE(model), &iter,
                                    ITEM_SCHEDULE_NAME_COLUMN, listschedule_name,
                                    ITEM_SCHEDULE_LIST_ID_COLUMN, listschedule_id,
                                    ITEM_SCHEDULE_PROGRAM_ID_COLUMN, listschedule_programid,
                                    ITEM_SCHEDULE_TYPE_COLUMN, (gint)SCHEDULE_NAME_COL_INDEX,
                                    -1);
    bot_schedule_choose_liststore_fill_information(listschedule_name, listschedule_id);


    if (bot_get_schedule_nofree_execute(listschedule_id,0,&schedule_list, &schedule_list_size) == TRUE)
    {
        if (schedule_list!= NULL)
        {
            for(gint i=0; i<schedule_list_size; i++)
            {
                bot_schedule_fill_infomation(0,
                                              &iter,
                                              schedule_list[i]->schedule_USCOREid,
                                              schedule_list[i]->schedule_USCORElistschedule_USCOREid,
                                              schedule_list[i]->schedule_USCOREstarttime,
                                              schedule_list[i]->schedule_USCOREontime,
                                              schedule_list[i]->schedule_USCORElevel);
            }
        }

    }
    bot_free_soap_operation();
}


void bot_schedule_fill_infomation(gint store_index,
                                               GtkTreeIter *parent_iter,
                                               gint schedule_id,
                                               gint schedule_listschedule_id,
                                               gint schedule_starttime,
                                               gint schedule_ontime,
                                               gint schedule_level)
{
    GtkTreeIter iter;
    switch(store_index)
    {
    case 0:

        gtk_tree_store_append(GTK_TREE_STORE(program_widgets->program_item_schedule_treestore), &iter, parent_iter);
        gtk_tree_store_set(GTK_TREE_STORE(program_widgets->program_item_schedule_treestore), &iter,
                                ITEM_SCHEDULE_ID_COLUMN, schedule_id,
                                ITEM_SCHEDULE_LIST_ID_COLUMN, schedule_listschedule_id,
                                ITEM_SCHEDULE_STARTTIME_COLUMN, bot_schedule_int2time(schedule_starttime),
                                ITEM_SCHEDULE_TIMEON_COLUMN, bot_schedule_int2time(schedule_ontime),
                                ITEM_SCHEDULE_LEVEL_COLUMN, g_strdup_printf("%d", schedule_level),
                                ITEM_SCHEDULE_TYPE_COLUMN, (gint)SCHEDULE_CONTENT_COL_INDEX,
                                -1);
        break;
    case 1:

        gtk_tree_store_append(GTK_TREE_STORE(program_widgets->program_month_schedule_treestore), &iter, parent_iter);
        gtk_tree_store_set(GTK_TREE_STORE(program_widgets->program_month_schedule_treestore), &iter,
                                SCHEDULE_ITEM_ID_COLUMN, schedule_id,
                                SCHEDULE_LIST_ID_COLUMN, schedule_listschedule_id,
                                SCHEDULE_STARTTIME_COLUMN, bot_schedule_int2time(schedule_starttime),
                                SCHEDULE_TIMEON_COLUMN, bot_schedule_int2time(schedule_ontime),
                                SCHEDULE_LEVEL_COLUMN, g_strdup_printf("%d", schedule_level),
                                SCHEDULE_TYPE_COLUMN, (gint)SCHEDULE_CONTENT_COL_INDEX,
                                -1);
        break;
    default:
        break;
    };




}


static gboolean bot_schedule_callback_init()
{
    g_signal_connect(GTK_TREE_VIEW(program_widgets->program_year_schedule_treeview),
                     "button-press-event",
                     G_CALLBACK(on_bot_program_year_treeview_clicked), NULL);

    g_signal_connect(GTK_TREE_VIEW(program_widgets->program_item_schedule_treeview),
                     "button-press-event",
                     G_CALLBACK(on_bot_schedule_item_specical_clicked), NULL);
    return TRUE;
}


void bot_program_year_show_specific(gint program_id)
{
    ns1__DAYSCHEDULE_USCOREINFO_USCOREType **dayschedule_list = NULL;
    gint dayschedule_list_size;
    ns1__LISTSCHEDULE_USCOREINFO_USCOREType **listschedule_list=NULL;
    gint listschedule_list_size;
    ns1__DCU_USCOREINFO_USCOREType **dcu_list= NULL;
    gint dcu_list_size;

    gtk_label_set_text(GTK_LABEL(bot_OBJECT("program_id_current_show_label")), g_strdup_printf("%d", program_id));

    bot_clear_tree_store(GTK_TREE_MODEL(program_widgets->program_month_schedule_treestore));
    if( bot_get_day_schedule_list_nofree_execute(program_id, 0,&dayschedule_list, &dayschedule_list_size)==TRUE)
    {
        if (dayschedule_list!=NULL)
        {
            for(gint i=0; i<dayschedule_list_size; i++)
            {
                bot_day_schedule_fill_infomation(dayschedule_list[i]->dayschedule_USCOREid,
                                                  dayschedule_list[i]->dayschedule_USCORElistScheduel_USCOREid,
                                                  dayschedule_list[i]->dayschedule_USCOREprogram_USCOREid,
                                                  dayschedule_list[i]->dayschedule_USCOREmonth);
            }
        }
        bot_free_soap_operation();
    }
    else
    {
        bot_free_soap_operation();
        return;
    }


    bot_clear_list_store(GTK_TREE_MODEL(program_widgets->day_schedule_liststore_change));
    bot_schedule_choose_liststore_fill_information(g_strdup_printf("New ..."), -1);
    bot_clear_tree_store(GTK_TREE_MODEL(program_widgets->program_item_schedule_treestore));


    if (bot_get_list_schedule_nofree_execute(0,program_id, &listschedule_list, &listschedule_list_size) == TRUE)
    {
        if (listschedule_list!= NULL)
        {
            for (gint i = 0 ; i < listschedule_list_size; i++)
            {
                bot_schedule_item_fill_infomations(listschedule_list[i]->listschedule_USCOREid,
                                                    listschedule_list[i]->listschedule_USCOREname,
                                                    listschedule_list[i]->listschedule_USCOREprogram_USCOREid);
            }
        }
    }
    bot_free_soap_operation();
    bot_clear_tree_store(GTK_TREE_MODEL(program_widgets->program_dcu_list_treestore));
    gint zone_id = (gint)g_ascii_strtoll(gtk_label_get_text(GTK_LABEL(bot_OBJECT("program_id_current_show_label"))), NULL, 0);

    if (bot_get_dcu_list_nofree_execute(zone_id, program_id,&dcu_list, & dcu_list_size)==TRUE)
    {
        if (dcu_list!=NULL)
        {
            for(gint i=0; i<dcu_list_size; i++)
            {
                bot_program_fill_infomation_dcu_list(dcu_list[i]->dcu_USCOREid,
                                                                  dcu_list[i]->dcu_USCOREstatus);
            }
        }
    }
    bot_free_soap_operation();
}

static const gchar * bot_schedule_int2time(const gint value)
{
    if(value>MAX_MINUTE)
        return NULL;

    gchar *hh, *mm, *time;

    gint h = value/60;
    gint m = value - (h*60);

    if(h<10)
        hh = g_strdup_printf("02%d", h);
    else
        hh = g_strdup_printf("%d", h);

    if(m<10)
        mm = g_strdup_printf("0%d", m);
    else
        mm = g_strdup_printf("%d", m);

    time = g_strdup_printf("%s:%s:00", hh, mm);

    g_free(hh);
    g_free(mm);

    return time;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
static gboolean bot_program_popup_menu_init(void)
{
    program_info_popup_menu = g_new0(struct bot_PROGRAM_POPUP_MENU, 1);

    bot_program_popup_menu_widget_init();
    bot_program_popup_menu_callback_init();

    return TRUE;
}


static void bot_program_popup_menu_widget_init(void)
{
    GtkWidget *separator_item;
    program_info_popup_menu->M_Popup = gtk_menu_new();
    bot_MENU_CSS(program_info_popup_menu->M_Popup);

    program_info_popup_menu->M_Add = gtk_menu_item_new_with_label("Thêm mới");
    gtk_menu_shell_append(GTK_MENU_SHELL(program_info_popup_menu->M_Popup),program_info_popup_menu->M_Add);

    separator_item = gtk_separator_menu_item_new();
    gtk_menu_shell_append(GTK_MENU_SHELL(program_info_popup_menu->M_Popup), separator_item);

    program_info_popup_menu->M_Schedule = gtk_menu_item_new_with_label("Thêm lập lịch tháng");
    gtk_menu_shell_append(GTK_MENU_SHELL(program_info_popup_menu->M_Popup),program_info_popup_menu->M_Schedule);

    separator_item = gtk_separator_menu_item_new();
    gtk_menu_shell_append(GTK_MENU_SHELL(program_info_popup_menu->M_Popup), separator_item);

    program_info_popup_menu->M_Remove= gtk_menu_item_new_with_label("Xóa");
    gtk_menu_shell_append(GTK_MENU_SHELL(program_info_popup_menu->M_Popup),program_info_popup_menu->M_Remove);
}

static void bot_program_popup_menu_callback_init(void)
{
    g_signal_connect(program_info_popup_menu->M_Add, "activate",
                     (GCallback) bot_program_popup_menu_clicked, GINT_TO_POINTER(bot_PROGRAM_M_ADD));

    g_signal_connect(program_info_popup_menu->M_Schedule, "activate",
                     (GCallback) bot_program_popup_menu_clicked, GINT_TO_POINTER(bot_PROGRAM_M_SCHEDULE));

    g_signal_connect(program_info_popup_menu->M_Remove, "activate",
                     (GCallback) bot_program_popup_menu_clicked, GINT_TO_POINTER(bot_PROGRAM_M_REMOVE));
}

static void bot_program_popup_menu_clicked(GtkWidget *popup_menu_item, gpointer userdata)
{
    bot_PROGRAM_POPUP_MENU_Enum type = (bot_PROGRAM_POPUP_MENU_Enum)GPOINTER_TO_INT(userdata);
    switch(type)
    {
    case bot_PROGRAM_M_ADD:

        gboolean ret;
        do
        {
            ret = bot_program_popup_menu_add_clicked();
        }while(!ret);

        break;
    case bot_PROGRAM_M_SCHEDULE:
        bot_program_popup_menu_schedule_clicked();
        break;
    case bot_PROGRAM_M_REMOVE:
        bot_program_popup_menu_remove_clicked();
        break;
    default:
        break;
    }
}

static gboolean bot_program_popup_menu_add_clicked(void)
{
    gboolean exit_here = FALSE;
    GtkTreeIter      parent_iter, iter;
    GtkTreeModel     *model;
    GtkTreeSelection *selection;
    gint zone_id = -1;
    gint program_id=0;
    GtkWidget *new_program_entry_name = GTK_WIDGET(bot_OBJECT("new_program_entry_name"));
    GtkWidget *add_program_label_error = GTK_WIDGET(bot_OBJECT("add_program_label_error"));

    gtk_widget_set_sensitive(GTK_WIDGET(main_widgets->main_window), FALSE);
    gint response_id = gtk_dialog_run((GtkDialog *)main_widgets->create_schedule_dialog);

    const gchar *program_name = gtk_entry_get_text(GTK_ENTRY(bot_OBJECT("new_program_entry_name")));

    switch(response_id)
    {
        case DIALOG_OK_RESPONSE:
            if(g_strcmp0(program_name, "")==0)
            {
                gtk_label_set_text(GTK_LABEL(add_program_label_error), "Thông tin tên program không được để trống!");
            }
            else
            {
                selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(program_widgets->program_year_schedule_treeview));
                if (gtk_tree_selection_count_selected_rows(selection)  == 1)
                {
                    if(gtk_tree_selection_get_selected(selection, &model, &iter))
                    {
                        if(gtk_tree_model_iter_parent(GTK_TREE_MODEL(model), &parent_iter, &iter))
                        {
                            gtk_tree_model_get(GTK_TREE_MODEL(model), &parent_iter, PROGRAM_ZONEID_COLUMN, &zone_id, -1);
                        }
                    }
                }
                if(bot_add_program_execute(zone_id,program_name,&program_id)==TRUE)
                {
                    if (program_id!=0)
                    {
                        bot_program_fill_infomation(program_name, program_id, zone_id, &parent_iter);
                    }

                }
                exit_here = TRUE;
            }

            break;
        case DIALOG_CANCEL_RESPONSE:
            exit_here = TRUE;
            break;
        default:
            break;
	}

    if(exit_here)
    {
        gtk_entry_set_text(GTK_ENTRY(new_program_entry_name), "");
        gtk_label_set_text(GTK_LABEL(add_program_label_error), "");
    }
    gtk_widget_hide(main_widgets->create_schedule_dialog);
    gtk_widget_set_sensitive(GTK_WIDGET(main_widgets->main_window), TRUE);
    return exit_here;
}

static void bot_program_popup_menu_schedule_clicked(void)
{
    GtkTreeIter      iter;
    GtkTreeModel     *model;
    GtkTreeSelection *selection;

    selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(program_widgets->program_year_schedule_treeview));

    if (gtk_tree_selection_count_selected_rows(selection)  == 1)
    {
        if(gtk_tree_selection_get_selected(selection, &model, &iter))
        {
            gint program_id;
            gtk_tree_model_get(GTK_TREE_MODEL(model), &iter, PROGRAM_ID_COLUMN, &program_id, -1);
            bot_schedule_day_popup_menu_add_clicked(program_id);
        }
    }
}

static void bot_program_popup_menu_remove_clicked(void)
{
    GtkTreeIter      iter;
    GtkTreeModel     *model;
    GtkTreeSelection *selection;

    selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(program_widgets->program_year_schedule_treeview));

    if (gtk_tree_selection_count_selected_rows(selection)  == 1)
    {
        if(gtk_tree_selection_get_selected(selection, &model, &iter))
        {
            gint program_id;
            gchar *program_name;
            gtk_tree_model_get(GTK_TREE_MODEL(model), &iter,
                                            PROGRAM_NAME_COLUMN, &program_name,
                                            PROGRAM_ID_COLUMN, &program_id,
                                            -1);


            gtk_label_set_text(GTK_LABEL(bot_OBJECT("delete_dialog_label")), "Xóa Program với tên sau:");
            gtk_label_set_text(GTK_LABEL(gtk_builder_get_object (bot_builder, "delete_element_id")), program_name);

            gtk_widget_set_sensitive(GTK_WIDGET(main_widgets->main_window), FALSE);
            gint response_id = gtk_dialog_run(GTK_DIALOG(main_widgets->delete_element_dialog));

            switch(response_id)
            {
                case DIALOG_OK_RESPONSE:
                    if(bot_remove_program_execute(program_id)==TRUE)
                    {
                        gtk_list_store_remove(GTK_LIST_STORE(model), &iter);
                    }
                    break;
                case DIALOG_CANCEL_RESPONSE:

                    break;
                default:
                    break;
            }
            gtk_widget_hide(main_widgets->delete_element_dialog);
            gtk_widget_set_sensitive(GTK_WIDGET(main_widgets->main_window), TRUE);
            g_free(program_name);
        }
        else
        {
            bot_error_notifice_run(g_strdup_printf("Internal Error at %s:%d", __FILE__, __LINE__));
        }
    }
    else
    {
        bot_error_notifice_run(g_strdup_printf("Internal Error at %s:%d", __FILE__, __LINE__));
    }
}


void bot_program_popup_menu_show(GtkTreeView *treeview, GdkEventButton *event, gpointer userdata)
{
    gtk_widget_show_all(GTK_WIDGET(program_info_popup_menu->M_Popup));
    gtk_menu_popup(GTK_MENU(program_info_popup_menu->M_Popup), NULL, NULL, NULL, NULL,
                   (event != NULL) ? event->button : 0, gdk_event_get_time((GdkEvent*)event));
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
static gboolean bot_schedule_day_popup_menu_init(void)
{
    schedule_day_popup_menu = g_new0(struct bot_SCHEDULE_DAY_POPUP_MENU, 1);

    bot_schedule_day_popup_menu_widget_init();
    bot_schedule_day_popup_menu_callback_init();

    return TRUE;
}


static void bot_schedule_day_popup_menu_widget_init(void)
{
    GtkWidget *separator_item;
    schedule_day_popup_menu->M_Popup = gtk_menu_new();
    bot_MENU_CSS(schedule_day_popup_menu->M_Popup);

    schedule_day_popup_menu->M_Add = gtk_menu_item_new_with_label("Thêm mới");
    gtk_menu_shell_append(GTK_MENU_SHELL(schedule_day_popup_menu->M_Popup),schedule_day_popup_menu->M_Add);

    separator_item = gtk_separator_menu_item_new();
    gtk_menu_shell_append(GTK_MENU_SHELL(schedule_day_popup_menu->M_Popup), separator_item);

    schedule_day_popup_menu->M_Schedule = gtk_menu_item_new_with_label("Chọn lập lịch");
    gtk_menu_shell_append(GTK_MENU_SHELL(schedule_day_popup_menu->M_Popup),schedule_day_popup_menu->M_Schedule);

    separator_item = gtk_separator_menu_item_new();
    gtk_menu_shell_append(GTK_MENU_SHELL(schedule_day_popup_menu->M_Popup), separator_item);

    schedule_day_popup_menu->M_Remove= gtk_menu_item_new_with_label("Xóa");
    gtk_menu_shell_append(GTK_MENU_SHELL(schedule_day_popup_menu->M_Popup),schedule_day_popup_menu->M_Remove);
}

static void bot_schedule_day_popup_menu_callback_init(void)
{
    g_signal_connect(schedule_day_popup_menu->M_Add, "activate",
                     (GCallback) bot_schedule_day_popup_menu_clicked, GINT_TO_POINTER(bot_SCHEDULE_M_ADD));

    g_signal_connect(schedule_day_popup_menu->M_Schedule, "activate",
                     (GCallback) bot_schedule_day_popup_menu_clicked, GINT_TO_POINTER(bot_SCHEDULE_M_SCHEDULE));

    g_signal_connect(schedule_day_popup_menu->M_Remove, "activate",
                     (GCallback) bot_schedule_day_popup_menu_clicked, GINT_TO_POINTER(bot_SCHEDULE_M_REMOVE));
}


static void bot_schedule_day_popup_menu_clicked(GtkWidget *popup_menu_item, gpointer userdata)
{
    bot_SCHEDULE_POPUP_Enum type = (bot_SCHEDULE_POPUP_Enum)GPOINTER_TO_INT(userdata);
    switch(type)
    {
    case bot_SCHEDULE_M_ADD:
        bot_schedule_day_popup_menu_add_clicked(-1);
        break;
    case bot_SCHEDULE_M_REMOVE:
        bot_schedule_day_popup_menu_remove_clicked();
        break;
    case bot_SCHEDULE_M_SCHEDULE:
        bot_schedule_day_popup_menu_schedule_clicked();
        break;
    default:
        break;
    }
}

static void bot_schedule_day_popup_menu_add_clicked(gint program_id)
{
    GtkTreeIter iter;
    GtkTreeModel *model = GTK_TREE_MODEL(program_widgets->program_month_schedule_treestore);
    gint month;
    gint list_month[12];
    gint n_count = 0;
    gint i;
    gint new_month;
    gint curr_program_id;

    if(gtk_tree_model_get_iter_first(model, &iter))
    {
        if(program_id==-1)
        {
            gtk_tree_model_get(model, &iter, SCHEDULE_PROGRAM_ID_COLUMN, &curr_program_id, -1);
            program_id = curr_program_id;
        }
        do
        {
            gtk_tree_model_get(model, &iter, SCHEDULE_MONTH_COLUMN, &month, -1);
            if(n_count<12 && month < 13 && month > 0)
            {
                list_month[n_count] = month;
                n_count++;
            }
        }
        while(gtk_tree_model_iter_next(model, &iter));
    }

    bot_clear_list_store(GTK_TREE_MODEL(program_widgets->program_month_schedule_new_liststore));

    if(n_count==0)
    {
        for(i=1; i<=12; i++)
        {
            gtk_list_store_append(GTK_LIST_STORE(program_widgets->program_month_schedule_new_liststore), &iter);
            gtk_list_store_set(GTK_LIST_STORE(program_widgets->program_month_schedule_new_liststore), &iter, 0, i, -1);
        }
    }
    else
    {
        for(i=1; i<=12; i++)
        {
            if(!check_exist_int(list_month, i, 12))
            {
                gtk_list_store_append(GTK_LIST_STORE(program_widgets->program_month_schedule_new_liststore), &iter);
                gtk_list_store_set(GTK_LIST_STORE(program_widgets->program_month_schedule_new_liststore), &iter, 0, i, -1);
            }
        }
    }

    gtk_widget_set_sensitive(GTK_WIDGET(main_widgets->main_window), FALSE);
    gint response_id = gtk_dialog_run(GTK_DIALOG(main_widgets->day_schedule_dialog_new));

    switch(response_id)
    {
        case DIALOG_OK_RESPONSE:

//            new_month = gtk_combo_box_text_get_active_text(GTK_COMBO_BOX_TEXT(program_widgets->program_month_schedule_new_combobox));
            if(gtk_combo_box_get_active_iter(GTK_COMBO_BOX(program_widgets->program_month_schedule_new_combobox),  &iter))
            {
                gtk_tree_model_get(GTK_TREE_MODEL(program_widgets->program_month_schedule_new_liststore), &iter, 0, &new_month, -1);

                if(bot_add_day_schedule_execute(program_id, new_month) == TRUE)
                {
                    bot_program_year_show_specific(program_id);
                }
            }
            else
            {
                bot_error_notifice_run(g_strdup_printf("Error with value of month at %s:%d", __FILE__, __LINE__));
            }
            break;
        case DIALOG_CANCEL_RESPONSE:
            break;
        default:
            break;
    }
    gtk_widget_hide(main_widgets->day_schedule_dialog_new);
    gtk_widget_set_sensitive(GTK_WIDGET(main_widgets->main_window), TRUE);

}

static gboolean check_exist_int(gint *list_value, gint value, gint list_size)
{
    gint i;
    for (i=0; i<list_size; i++)
        if(list_value[i] == value)
            return TRUE;
    return FALSE;
}


static void bot_schedule_day_popup_menu_remove_clicked(void)
{
    GtkTreeIter      iter;
    GtkTreeModel     *model;
    GtkTreeSelection *selection;

    selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(program_widgets->program_month_schedule_treeview));

    if (gtk_tree_selection_count_selected_rows(selection)  == 1)
    {
        if(gtk_tree_selection_get_selected(selection, &model, &iter))
        {
            gint day_schedule_id;
            gchar *day_schedule_name;
            gtk_tree_model_get(GTK_TREE_MODEL(model), &iter, SCHEDULE_DAY_ID_COLUMN, &day_schedule_id,
                                                            SCHEDULE_NAME_COLUMN, &day_schedule_name, -1);


            gtk_label_set_text(GTK_LABEL(bot_OBJECT("delete_dialog_label")), "Xóa lập lịch với tên sau:");
            gtk_label_set_text(GTK_LABEL(gtk_builder_get_object (bot_builder, "delete_element_id")), day_schedule_name);

            gtk_widget_set_sensitive(GTK_WIDGET(main_widgets->main_window), FALSE);
            gint response_id = gtk_dialog_run(GTK_DIALOG(main_widgets->delete_element_dialog));

            switch(response_id)
            {
                case DIALOG_OK_RESPONSE:
                    if(bot_remove_day_schedule_execute(day_schedule_id)==TRUE)
                    {
                        gtk_tree_store_remove(GTK_TREE_STORE(model), &iter);
                    }
                    break;
                case DIALOG_CANCEL_RESPONSE:

                    break;
                default:
                    break;
            }
            gtk_widget_hide(main_widgets->delete_element_dialog);
            gtk_widget_set_sensitive(GTK_WIDGET(main_widgets->main_window), TRUE);
            g_free(day_schedule_name);
        }
        else
        {
            bot_error_notifice_run(g_strdup_printf("Internal Error at %s:%d", __FILE__, __LINE__));
        }
    }
    else
    {
        bot_error_notifice_run(g_strdup_printf("Internal Error at %s:%d", __FILE__, __LINE__));
    }
}


static void bot_schedule_day_popup_menu_schedule_clicked(void)
{
    gtk_widget_set_sensitive(GTK_WIDGET(main_widgets->main_window), FALSE);
    gtk_combo_box_set_active(GTK_COMBO_BOX(program_widgets->list_schedule_combobox_change), -1);
    gint response_id = gtk_dialog_run(GTK_DIALOG(main_widgets->list_schedule_dialog_change));
    GtkTreeIter iter;

    switch(response_id)
    {
        case DIALOG_OK_RESPONSE:
            if(gtk_combo_box_get_active(GTK_COMBO_BOX(program_widgets->list_schedule_combobox_change)) == 0)
                bot_schedule_day_create_process();
            else
            {
                if(gtk_combo_box_get_active_iter(GTK_COMBO_BOX(program_widgets->list_schedule_combobox_change), &iter))
                {
//                    gint temp;
//                    gtk_tree_model_get(GTK_TREE_MODEL(program_widgets->day_schedule_liststore_change), &iter, 1, &temp, -1);
                    bot_schedule_day_change_process(&iter);
                }
                else
                {
                    bot_error_notifice_run(g_strdup_printf("Internal Error at %s:%d", __FILE__, __LINE__));
                }
            }

            break;
        case DIALOG_CANCEL_RESPONSE:

            break;
        default:
            break;
    }
    gtk_widget_hide(main_widgets->list_schedule_dialog_change);
    gtk_widget_set_sensitive(GTK_WIDGET(main_widgets->main_window), TRUE);
}

static void bot_schedule_day_create_process(void)
{
    DEBUG_1();
}

static void bot_schedule_day_change_process(GtkTreeIter *iter)
{
    gint listschedule_id;
    gint program_id;
    gint month;
    gint schedule_id;
    gint curr_program_id;

    GtkTreeIter iter1, iter2;
    GtkTreeModel     *model;
    GtkTreeSelection *selection;

    selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(program_widgets->program_month_schedule_treeview));
    if (gtk_tree_selection_count_selected_rows(selection)  == 1)
    {
        if(gtk_tree_selection_get_selected(selection, &model, &iter1))
        {
            gint type_column;
            gtk_tree_model_get(model, &iter1, SCHEDULE_TYPE_COLUMN, &type_column, -1);


            if(type_column==(gint)SCHEDULE_NAME_COL_INDEX)
            {
                if(!gtk_tree_model_iter_parent(model, &iter2, &iter1))
                    bot_error_notifice_run(g_strdup_printf("Internal Error at %s:%d", __FILE__, __LINE__));
            }
            else
                iter2 = iter1;

            gtk_tree_model_get(model, &iter2,
                                 SCHEDULE_PROGRAM_ID_COLUMN, &curr_program_id,
                                 SCHEDULE_MONTH_COLUMN, &month,
                                 SCHEDULE_PROGRAM_ID_COLUMN, &program_id,
                                 SCHEDULE_DAY_ID_COLUMN, &schedule_id, -1);

            gtk_tree_model_get(GTK_TREE_MODEL(program_widgets->day_schedule_liststore_change), iter, 1, &listschedule_id, -1);


            if(bot_edit_day_schedule_execute(schedule_id,
                                                          listschedule_id,
                                                          program_id,
                                                          month))
            {
                bot_program_year_show_specific(curr_program_id);
            }
        }
        else
            bot_error_notifice_run(g_strdup_printf("Internal Error at %s:%d", __FILE__, __LINE__));
    }
    else
        bot_error_notifice_run(g_strdup_printf("Internal Error at %s:%d", __FILE__, __LINE__));
}


void bot_schedule_day_popup_menu_show(GtkTreeView *treeview, GdkEventButton *event, gpointer userdata)
{
    gtk_widget_show_all(GTK_WIDGET(schedule_day_popup_menu->M_Popup));
    gtk_menu_popup(GTK_MENU(schedule_day_popup_menu->M_Popup), NULL, NULL, NULL, NULL,
                   (event != NULL) ? event->button : 0, gdk_event_get_time((GdkEvent*)event));
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
static gboolean bot_schedule_list_popup_menu_init(void)
{
    schedule_list_popup_menu = g_new0(struct bot_SCHEDULE_LIST_POPUP_MENU, 1);

    bot_schedule_list_popup_menu_widget_init();
    bot_schedule_list_popup_menu_callback_init();

    return TRUE;
}


static void bot_schedule_list_popup_menu_widget_init(void)
{
    GtkWidget *separator_item;
    schedule_list_popup_menu->M_Popup = gtk_menu_new();
    bot_MENU_CSS(schedule_list_popup_menu->M_Popup);

    schedule_list_popup_menu->M_Add = gtk_menu_item_new_with_label("Thay đổi");
    gtk_menu_shell_append(GTK_MENU_SHELL(schedule_list_popup_menu->M_Popup),schedule_list_popup_menu->M_Add);

    separator_item = gtk_separator_menu_item_new();
    gtk_menu_shell_append(GTK_MENU_SHELL(schedule_list_popup_menu->M_Popup), separator_item);

    schedule_list_popup_menu->M_Remove= gtk_menu_item_new_with_label("Xóa");
    gtk_menu_shell_append(GTK_MENU_SHELL(schedule_list_popup_menu->M_Popup),schedule_list_popup_menu->M_Remove);
}

static void bot_schedule_list_popup_menu_callback_init(void)
{
    g_signal_connect(schedule_list_popup_menu->M_Add, "activate",
                     (GCallback) bot_schedule_list_popup_menu_clicked, GINT_TO_POINTER(bot_SCHEDULE_M_ADD));

    g_signal_connect(schedule_list_popup_menu->M_Remove, "activate",
                     (GCallback) bot_schedule_list_popup_menu_clicked, GINT_TO_POINTER(bot_SCHEDULE_M_REMOVE));
}


static void bot_schedule_list_popup_menu_clicked(GtkWidget *popup_menu_item, gpointer userdata)
{
    bot_SCHEDULE_POPUP_Enum type = (bot_SCHEDULE_POPUP_Enum)GPOINTER_TO_INT(userdata);
    switch(type)
    {
    case bot_SCHEDULE_M_ADD:
        bot_schedule_list_popup_menu_add_clicked();
        break;
    case bot_SCHEDULE_M_REMOVE:
        bot_schedule_list_popup_menu_remove_clicked();
        break;
    default:
        break;
    }
}

static void bot_schedule_list_popup_menu_add_clicked(void)
{
    bot_schedule_day_popup_menu_schedule_clicked();
}

static void bot_schedule_list_popup_menu_remove_clicked(void)
{
    GtkTreeIter      iter;
    GtkTreeModel     *model;
    GtkTreeSelection *selection;

    selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(program_widgets->program_month_schedule_treeview));
    if (gtk_tree_selection_count_selected_rows(selection)  == 1)
    {
        if(gtk_tree_selection_get_selected(selection, &model, &iter))
        {
        }
    }
}

void bot_schedule_list_popup_menu_show(GtkTreeView *treeview, GdkEventButton *event, gpointer userdata)
{
    gtk_widget_show_all(GTK_WIDGET(schedule_list_popup_menu->M_Popup));
    gtk_menu_popup(GTK_MENU(schedule_list_popup_menu->M_Popup), NULL, NULL, NULL, NULL,
                   (event != NULL) ? event->button : 0, gdk_event_get_time((GdkEvent*)event));
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
static gboolean bot_schedule_item_popup_menu_init(void)
{
    schedule_item_popup_menu = g_new0(struct bot_SCHEDULE_ITEM_POPUP_MENU, 1);

    bot_schedule_item_popup_menu_widget_init();
    bot_schedule_item_popup_menu_callback_init();

    return TRUE;
}


static void bot_schedule_item_popup_menu_widget_init(void)
{
    GtkWidget *separator_item;
    schedule_item_popup_menu->M_Popup = gtk_menu_new();
    bot_MENU_CSS(schedule_item_popup_menu->M_Popup);

    schedule_item_popup_menu->M_Add = gtk_menu_item_new_with_label("Thêm mới");
    gtk_menu_shell_append(GTK_MENU_SHELL(schedule_item_popup_menu->M_Popup),schedule_item_popup_menu->M_Add);

    separator_item = gtk_separator_menu_item_new();
    gtk_menu_shell_append(GTK_MENU_SHELL(schedule_item_popup_menu->M_Popup), separator_item);

    schedule_item_popup_menu->M_Remove= gtk_menu_item_new_with_label("Xóa");
    gtk_menu_shell_append(GTK_MENU_SHELL(schedule_item_popup_menu->M_Popup),schedule_item_popup_menu->M_Remove);
}

static void bot_schedule_item_popup_menu_callback_init(void)
{
    g_signal_connect(schedule_item_popup_menu->M_Add, "activate",
                     (GCallback) bot_schedule_item_popup_menu_clicked, GINT_TO_POINTER(bot_SCHEDULE_M_ADD));

    g_signal_connect(schedule_item_popup_menu->M_Remove, "activate",
                     (GCallback) bot_schedule_item_popup_menu_clicked, GINT_TO_POINTER(bot_SCHEDULE_M_REMOVE));
}


static void bot_schedule_item_popup_menu_clicked(GtkWidget *popup_menu_item, gpointer userdata)
{
    bot_SCHEDULE_POPUP_Enum type = (bot_SCHEDULE_POPUP_Enum)GPOINTER_TO_INT(userdata);
    switch(type)
    {
    case bot_SCHEDULE_M_ADD:
        bot_schedule_item_popup_menu_add_clicked();
        break;
    case bot_SCHEDULE_M_REMOVE:
        bot_schedule_item_popup_menu_remove_clicked();
        break;
    default:
        break;
    }
}

static void bot_schedule_item_popup_menu_add_clicked(void)
{
    DEBUG_1();
}

static void bot_schedule_item_popup_menu_remove_clicked(void)
{
    DEBUG_1();
}

void bot_schedule_item_popup_menu_show(GtkTreeView *treeview, GdkEventButton *event, gpointer userdata)
{
    gtk_widget_show_all(GTK_WIDGET(schedule_item_popup_menu->M_Popup));
    gtk_menu_popup(GTK_MENU(schedule_item_popup_menu->M_Popup), NULL, NULL, NULL, NULL,
                   (event != NULL) ? event->button : 0, gdk_event_get_time((GdkEvent*)event));
}

void bot_schedule_item_name_popup_menu_show(GtkTreeView *treeview, GdkEventButton *event, gpointer userdata)
{
    gtk_widget_show_all(GTK_WIDGET(schedule_list_name_popup_menu->M_Popup));
    gtk_menu_popup(GTK_MENU(schedule_list_name_popup_menu->M_Popup), NULL, NULL, NULL, NULL,
                   (event != NULL) ? event->button : 0, gdk_event_get_time((GdkEvent*)event));
}

void bot_schedule_item_content_popup_menu_show(GtkTreeView *treeview, GdkEventButton *event, gpointer userdata)
{
    gtk_widget_show_all(GTK_WIDGET(schedule_list_content_popup_menu->M_Popup));
    gtk_menu_popup(GTK_MENU(schedule_list_content_popup_menu->M_Popup), NULL, NULL, NULL, NULL,
                   (event != NULL) ? event->button : 0, gdk_event_get_time((GdkEvent*)event));
}

*/
